{"version":3,"sources":["../src/parser.js"],"names":["path","require","Handlebars","markdownLinkFormatRegExp","keyEx","kvsepEx","spacesEx","quoteEx","valEx","argEx","expressionEx","expressionRegExp","RegExp","markerRegExp","codeCounter","count","splitLabelToCommands","label","result","split","map","command","trim","filter","length","strip","s","undefined","indents","match","m","smallestIndent","sort","a","b","replace","containIncludeCommand","commands","reg","test","parseValue","value","type","key","unescapedvalue","substring","console","error","indexOf","parseVariablesFromLabel","kvMap","kv","Object","assign","exec","prototype","hasOwnProperty","call","parsedValue","defaultKeyValueMap","freeze","generateEmbedCode","fileName","originalPath","content","backtick","tContent","contextMap","handlebars","compile","getContent","filePath","embedCode","code","basename","kvmparsed","kvm","unindent","start","end","marker","parse","baseDir","options","results","res","all","absolutePath","resolve","replacedContent","push","target","replaced"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst path = require(\"path\");\nconst Handlebars = require(\"handlebars\");\nimport { defaultKeyValueMap, initOptions, checkMapTypes } from \"./options.js\";\nimport { unescapeString } from \"./unescape-string.js\";\nimport { getLang } from \"./language-detection\";\nimport { getMarker, hasMarker, markerSliceCode, removeMarkers } from \"./marker\";\nimport { sliceCode, hasSliceRange, getSliceRange } from \"./slicer\";\nimport { hasTitle } from \"./title\";\nimport { getTemplateContent, readFileFromPath } from \"./template\";\nimport { codeBlockBacktick } from \"./backtick-maker\";\n\nconst markdownLinkFormatRegExp = /\\[(?=((?:[^\\]]|\\\\.)*))\\1\\]\\((?=((?:[^)]|\\\\.)*))\\2\\)/gm;\n\nconst keyEx = \"\\\\w+\";\nconst kvsepEx = \"[:=]\";\nconst spacesEx = \"\\\\s*\";\nconst quoteEx = \"[\\\"']\";\nconst valEx = \"(?:[^'\\\"\\\\\\\\]|\\\\\\\\.)*\";\nconst argEx = `${quoteEx}${valEx}${quoteEx}|true|false`;\nconst expressionEx = `(${keyEx})${kvsepEx}${spacesEx}(${argEx})`;\nconst expressionRegExp = new RegExp(expressionEx, \"g\");\n\nconst markerRegExp = /^\\s*(([-\\w\\s]*,?)*)$/;\n\n/**\n * A counter to count how many code are imported.\n */\nvar codeCounter = (function () {\n    var count = 0;\n    return function () {\n        return count++;\n    }; // Return and increment\n})();\n\n/**\n * split label to commands\n * @param {string} label\n * @returns {Array}\n */\nexport function splitLabelToCommands(label = \"\") {\n    const result = label.split(/(:|[,\\s])/);\n    if (!result) {\n        return [];\n    }\n    // remove null command\n    return result\n        .map((command) => {\n            return command.trim();\n        })\n        .filter((command) => {\n            return command.length > 0;\n        });\n}\n\n/**\n * Unindent code\n * @param {string} s\n * @return {string}\n */\nexport function strip(s) {\n    // inspired from https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/string/strip.rb\n    if (s === undefined || s === \"\") {\n        return s;\n    }\n    const indents = s\n        .split(/\\n/)\n        .map((s) => s.match(/^[ \\t]*(?=\\S)/))\n        .filter((m) => m)\n        .map((m) => m[0]);\n    const smallestIndent = indents.sort((a, b) => a.length - b.length)[0];\n    return s.replace(new RegExp(`^${smallestIndent}`, \"gm\"), \"\");\n}\n\n/**\n * if contain \"include\" or \"import\" command, then return true\n * @param {Array} commands\n * @returns {boolean}\n */\nexport function containIncludeCommand(commands = []) {\n    const reg = /^(include|import)$/;\n    return commands.length > 0 ? reg.test(commands[0].trim()) : false;\n}\n\n/**\n * Parse the given value to the given type. Returns the value if valid, otherwise returns undefined.\n * @param {string} value\n * @param {string} type \"string\", \"boolean\"\n * @param {string} key\n * @return {boolean|string|undefined}\n */\nexport function parseValue(value, type, key) {\n    if (type === \"string\") {\n        const unescapedvalue = unescapeString(value.substring(1, value.length - 1));\n        if (key === \"marker\" && !markerRegExp.test(unescapedvalue)) {\n            console.error(\n                \"include-codeblock: parseVariablesFromLabel: invalid value \" + `\\`${unescapedvalue}\\` in key \\`marker\\``\n            );\n            return undefined;\n        }\n        return unescapedvalue;\n    }\n\n    if (type === \"boolean\") {\n        if ([\"true\", '\"true\"', \"'true'\"].indexOf(value) >= 0) {\n            return true;\n        }\n\n        if ([\"false\", '\"false\"', \"'false'\"].indexOf(value) >= 0) {\n            return false;\n        }\n\n        console.error(\n            \"include-codeblock: parseVariablesFromLabel: invalid value \" +\n                `\\`${value}\\` in key \\`${key}\\`. Expect true or false.`\n        );\n        return undefined;\n    }\n\n    console.error(`include-codeblock: parseVariablesFromLabel: unknown key type \\`${type}\\` (see options.js)`);\n    return undefined;\n}\n\n/** Parse the command label and return a new key-value object\n * @example\n *      [import,title:\"<thetitle>\",label:\"<thelabel>\"](path/to/file.ext)\n * @param {object} kvMap\n * @param {string} label\n * @return {object}\n */\nexport function parseVariablesFromLabel(kvMap, label) {\n    const kv = Object.assign({}, kvMap);\n\n    let match = \"\";\n    while ((match = expressionRegExp.exec(label))) {\n        let key = match[1];\n        if (key === \"include\" || key === \"import\") {\n            key = \"marker\";\n        }\n        const value = match[2];\n\n        if (!Object.prototype.hasOwnProperty.call(kv, key)) {\n            console.error(\"include-codeblock: parseVariablesFromLabel: unknown key \" + `\\`${key}\\` (see options.js)`);\n            return;\n        }\n\n        const parsedValue = parseValue(value, typeof defaultKeyValueMap[key], key);\n        if (parsedValue !== undefined) {\n            kv[key] = parsedValue;\n        }\n    }\n\n    return Object.freeze(kv);\n}\n\n/**\n * generate code from options\n * @param {object} kvMap\n * @param {string} fileName\n * @param {string} originalPath\n * @param {string} content\n * @param {string} backtick\n * @return {string}\n */\nexport function generateEmbedCode(kvMap, { fileName, originalPath, content, backtick }) {\n    const tContent = getTemplateContent(kvMap);\n    const kv = Object.assign({}, kvMap);\n    const count = hasTitle(kv) ? codeCounter() : -1;\n    checkMapTypes(kvMap, \"generatedEmbedCode\");\n    const contextMap = Object.assign({}, kvMap, {\n        content: content,\n        count: count,\n        fileName: fileName,\n        originalPath: originalPath,\n        backtick\n    });\n    // compile template\n    const handlebars = Handlebars.compile(tContent);\n    // compile with data.\n    return handlebars(contextMap);\n}\n\n/**\n * return content from file or url.\n * @param {string} filePath it should be absolute path\n * @return {string}\n */\nexport function getContent(filePath) {\n    return readFileFromPath(filePath);\n}\n\n/**\n * generate code with options\n * @param {object} kvMap\n * @param {string} filePath\n * @param {string} originalPath\n * @param {string} label\n * @return {string}\n */\nexport function embedCode(kvMap, { filePath, originalPath, label }) {\n    const code = getContent(filePath);\n    const fileName = path.basename(filePath);\n    const kvmparsed = parseVariablesFromLabel(kvMap, label);\n    const kvm = getLang(kvmparsed, originalPath);\n    const unindent = kvm.unindent;\n\n    let content = code;\n    // Slice content via line numbers.\n    if (hasSliceRange(label)) {\n        const [start, end] = getSliceRange(label);\n        content = sliceCode(code, start, end, unindent);\n    } else if (hasMarker(kvm)) {\n        // Slice content via markers.\n        const marker = getMarker(kvm);\n        content = removeMarkers(markerSliceCode(code, marker));\n    }\n    if (unindent === true) {\n        content = strip(content);\n    }\n\n    const backtick = codeBlockBacktick(content);\n    return generateEmbedCode(kvm, { fileName, originalPath, content, backtick });\n}\n\n/**\n * Parse command using options from pluginConfig.\n * @param {string} content\n * @param {string} baseDir\n * @param {{template?: string}} options\n * @return {Array}\n */\nexport function parse(content, baseDir, options = {}) {\n    const results = [];\n    const kvMap = initOptions(options);\n    let res = true;\n    while ((res = markdownLinkFormatRegExp.exec(content))) {\n        const [all, label, originalPath] = res;\n        const commands = splitLabelToCommands(label);\n        if (containIncludeCommand(commands)) {\n            const absolutePath = path.resolve(baseDir, originalPath);\n            const replacedContent = embedCode(kvMap, {\n                filePath: absolutePath,\n                originalPath: originalPath,\n                label\n            });\n            results.push({\n                target: all,\n                replaced: replacedContent\n            });\n        }\n    }\n    return results;\n}\n"],"file":"parser.js"}