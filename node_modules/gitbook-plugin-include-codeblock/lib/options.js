// LICENSE : MIT
// Notes:
// 1) If you add new options type, you have to update type checks in parser.js
// (see parseVariableFromMap).
// 2) The default map (objects) are immutable (frozen). They are updated (new map
// with different names) while parsing book.json options first, then eventually
// overwriten by commands options.
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkMapTypes = checkMapTypes;
exports.convertValue = convertValue;
exports.defaultTemplateMap = exports.defaultKeyValueMap = exports.defaultBookOptionsMap = void 0;
exports.initOptions = initOptions;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var path = require("path");

var cfg = require("../package.json").gitbook.properties;

var defaultTemplateMap = Object.freeze({
  "default": path.join(__dirname, "..", "templates", "default-template.hbs"),
  full: path.join(__dirname, "..", "templates", "full-template.hbs"),
  ace: path.join(__dirname, "..", "templates", "ace-template.hbs"),
  acefull: path.join(__dirname, "..", "templates", "acefull-template.hbs")
}); // Map for Book.json options. (avoid `undefined` for ace options),
// NB: Default book option, type, desc are set in the package.json file.

exports.defaultTemplateMap = defaultTemplateMap;
var defaultBookOptionsMap = Object.freeze({
  check: cfg.check["default"],
  edit: cfg.edit["default"],
  lang: cfg.lang["default"],
  fixlang: cfg.fixlang["default"],
  template: cfg.template["default"],
  theme: cfg.theme["default"],
  unindent: cfg.unindent["default"]
}); // Possible command key-values (kv).
// (avoid undefined default value because we check value types).

exports.defaultBookOptionsMap = defaultBookOptionsMap;
var defaultKeyValueMap = Object.freeze({
  // Local
  "class": "",
  id: "",
  marker: "",
  name: "",
  title: "",
  // Global/Local
  check: defaultBookOptionsMap.check,
  edit: defaultBookOptionsMap.edit,
  lang: defaultBookOptionsMap.lang,
  fixlang: defaultBookOptionsMap.fixlang,
  template: defaultBookOptionsMap.template,
  theme: defaultBookOptionsMap.theme,
  unindent: defaultBookOptionsMap.unindent
});
/**
 * Convert string value to value type.
 * @param {string} valtype
 */

exports.defaultKeyValueMap = defaultKeyValueMap;

function convertValue(valstr, valtype) {
  // remove quotes
  if (valtype === "boolean" || valtype === "number") {
    return JSON.parse(valstr);
  }

  return valstr;
}
/**
 * Check that maps types equal to default key value map.
 * @param {object} kvMap
 * @param {string} funcLabel
 */


function checkMapTypes(kvMap, funcLabel) {
  Object.keys(kvMap).forEach(function (key) {
    if (defaultKeyValueMap[key] !== undefined) {
      var leftType = _typeof(kvMap[key]);

      var rightType = _typeof(defaultKeyValueMap[key]);

      if (!(leftType === rightType)) {
        console.error("include-codeblock: checkMapTypes (".concat(funcLabel, ") : wrong value type for key `").concat(key, "`: key type: `").concat(leftType, "` (!= `").concat(rightType, "`)"));
      }
    }
  });
}
/**
 * Check that maps types equal to default key value map.
 * @param {{template?: string}} options
 * @return {object} kvMap
 */


function initOptions(options) {
  var dbom = defaultBookOptionsMap;
  var kv = Object.assign({}, defaultKeyValueMap); // Overwrite default value with user book options.

  Object.keys(dbom).forEach(function (key) {
    if (options[key] != undefined) {
      kv[key] = convertValue(options[key], _typeof(dbom[key]));
    }
  });
  var kvmap = Object.freeze(kv);
  checkMapTypes(kvmap, "initOptions");
  return kvmap;
}
//# sourceMappingURL=options.js.map